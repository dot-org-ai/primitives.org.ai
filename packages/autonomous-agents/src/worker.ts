/**
 * Worker Export - AgentService WorkerEntrypoint
 *
 * Provides AgentService as a WorkerEntrypoint with AgentServiceCore RpcTarget.
 * AgentService.connect() returns AgentServiceCore for agent operations.
 *
 * Uses real AI Gateway for agent reasoning/planning and Durable Objects
 * for agent state/memory persistence.
 *
 * @packageDocumentation
 */

// @ts-expect-error - cloudflare:workers is a Cloudflare Workers-specific module
import { WorkerEntrypoint, RpcTarget } from 'cloudflare:workers'

// ==================== Types ====================

// Type declarations for Cloudflare Workers (when @cloudflare/workers-types is not available)
declare const DurableObjectNamespace: unknown

/**
 * Environment bindings for the AgentService worker
 */
export interface Env {
  AI: Ai
  AGENT_STATE: typeof DurableObjectNamespace
}

/**
 * Agent configuration
 */
export interface AgentConfig {
  id?: string
  name: string
  description?: string
  role?: string
  model?: string
  temperature?: number
  maxIterations?: number
  system?: string
  tools?: Array<{
    name: string
    description: string
    parameters?: Record<string, unknown>
  }>
}

/**
 * Agent goal
 */
export interface AgentGoal {
  id: string
  description: string
  priority: 'low' | 'medium' | 'high' | 'critical'
  status: 'pending' | 'active' | 'completed' | 'failed' | 'cancelled'
  deadline?: Date
  progress?: number
  subgoals?: AgentGoal[]
}

/**
 * Agent memory structure
 */
export interface AgentMemory {
  shortTerm: Array<{ role: string; content: string; timestamp: Date }>
  longTerm: Record<string, unknown>
  context: Record<string, unknown>
}

/**
 * Action plan generated by AI
 */
export interface ActionPlan {
  id: string
  goal: string
  steps: PlanStep[]
  status: 'pending' | 'executing' | 'completed' | 'failed'
  createdAt: Date
  updatedAt: Date
}

/**
 * Plan step
 */
export interface PlanStep {
  id: string
  action: string
  description: string
  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'skipped'
  result?: unknown
  dependencies?: string[]
}

/**
 * Agent state
 */
export interface AgentState {
  id: string
  name: string
  status: 'idle' | 'thinking' | 'acting' | 'waiting' | 'completed' | 'error' | 'terminated'
  config: AgentConfig
  memory: AgentMemory
  goals: AgentGoal[]
  plan?: ActionPlan
  createdAt: Date
  updatedAt: Date
}

/**
 * Action execution result
 */
export interface ActionResult {
  id: string
  action: string
  status: 'success' | 'failure' | 'pending'
  result?: unknown
  error?: string
  duration: number
  timestamp: Date
}

/**
 * Coordination pattern for multi-agent operations
 */
export interface CoordinationPattern {
  type: 'sequential' | 'parallel' | 'hierarchical' | 'collaborative' | 'competitive'
  agents: string[]
  goal?: string
  config?: Record<string, unknown>
}

/**
 * Coordination result
 */
export interface CoordinationResult {
  id: string
  pattern: CoordinationPattern
  status: 'pending' | 'running' | 'completed' | 'failed'
  results: Record<string, unknown>
  consensus?: unknown
  duration: number
}

// ==================== Utilities ====================

/**
 * Generate a unique ID
 */
function generateId(): string {
  return `${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 9)}`
}

// ==================== In-Memory Storage ====================
// This storage is used when no Durable Object binding is available.
// Provides namespace isolation and persistence across connect() calls.

const agentStore = new Map<string, AgentState>()

// ==================== AgentServiceCore ====================

/**
 * AgentServiceCore - RpcTarget that provides agent operations
 *
 * This class is returned by AgentService.connect() and provides all
 * agent lifecycle, goal management, planning, execution, memory,
 * and multi-agent coordination methods.
 */
export class AgentServiceCore extends RpcTarget {
  #env: Env

  constructor(env: Env) {
    super()
    this.#env = env
  }

  // ==================== Agent Lifecycle ====================

  /**
   * Create a new agent with the given configuration
   */
  async create(config: AgentConfig): Promise<AgentState> {
    const id = config.id || generateId()
    const now = new Date()

    const agent: AgentState = {
      id,
      name: config.name,
      status: 'idle',
      config: {
        ...config,
        id,
      },
      memory: {
        shortTerm: [],
        longTerm: {},
        context: {},
      },
      goals: [],
      createdAt: now,
      updatedAt: now,
    }

    agentStore.set(id, agent)
    return agent
  }

  /**
   * Retrieve an agent by ID
   */
  async get(agentId: string): Promise<AgentState | null> {
    const agent = agentStore.get(agentId)
    return agent || null
  }

  /**
   * List all agents with optional filtering
   */
  async list(options?: { status?: string; limit?: number }): Promise<AgentState[]> {
    let agents = Array.from(agentStore.values())

    if (options?.status) {
      agents = agents.filter((a) => a.status === options.status)
    }

    if (options?.limit) {
      agents = agents.slice(0, options.limit)
    }

    return agents
  }

  /**
   * Terminate an agent
   */
  async terminate(agentId: string): Promise<boolean> {
    const agent = agentStore.get(agentId)
    if (!agent) return false

    agent.status = 'terminated'
    agent.updatedAt = new Date()
    return true
  }

  // ==================== Goal Management ====================

  /**
   * Add a goal to an agent
   */
  async setGoal(agentId: string, goal: Omit<AgentGoal, 'id' | 'status'>): Promise<AgentGoal> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)

    const newGoal: AgentGoal = {
      id: generateId(),
      description: goal.description,
      priority: goal.priority,
      status: 'pending',
      ...(goal.deadline !== undefined && { deadline: goal.deadline }),
      ...(goal.progress !== undefined && { progress: goal.progress }),
      ...(goal.subgoals !== undefined && { subgoals: goal.subgoals }),
    }

    agent.goals.push(newGoal)
    agent.updatedAt = new Date()
    return newGoal
  }

  /**
   * Get all goals for an agent
   */
  async getGoals(agentId: string): Promise<AgentGoal[]> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)
    return agent.goals
  }

  /**
   * Update a goal
   */
  async updateGoal(
    agentId: string,
    goalId: string,
    updates: Partial<AgentGoal>
  ): Promise<AgentGoal> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)

    const goal = agent.goals.find((g) => g.id === goalId)
    if (!goal) throw new Error(`Goal not found: ${goalId}`)

    Object.assign(goal, updates)
    agent.updatedAt = new Date()
    return goal
  }

  /**
   * Remove a goal from an agent
   */
  async removeGoal(agentId: string, goalId: string): Promise<boolean> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)

    const index = agent.goals.findIndex((g) => g.id === goalId)
    if (index === -1) return false

    agent.goals.splice(index, 1)
    agent.updatedAt = new Date()
    return true
  }

  // ==================== Reasoning and Planning ====================

  /**
   * Generate an action plan using AI
   */
  async plan(agentId: string, objective?: string): Promise<ActionPlan> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)

    const goalDescription =
      objective || agent.goals.map((g) => g.description).join(', ') || 'No specific goal'
    const now = new Date()

    // Use AI to generate a plan
    let steps: PlanStep[] = []

    try {
      const ai = this.#env?.AI
      if (ai) {
        const response = (await ai.run('@cf/meta/llama-3.1-8b-instruct', {
          messages: [
            {
              role: 'system',
              content: `You are a planning assistant. Generate a step-by-step action plan as JSON.
Your response MUST be valid JSON in this exact format:
{"steps":[{"action":"action_name","description":"what to do"},{"action":"action_name","description":"what to do"}]}
Only output the JSON, nothing else.`,
            },
            {
              role: 'user',
              content: `Create a plan with 2-4 steps to achieve: ${goalDescription}`,
            },
          ],
        })) as { response?: string }

        if (response?.response) {
          try {
            const parsed = JSON.parse(response.response)
            if (parsed.steps && Array.isArray(parsed.steps)) {
              steps = parsed.steps.map(
                (
                  s: { action: string; description: string; dependencies?: string[] },
                  i: number
                ) => ({
                  id: `step-${i + 1}`,
                  action: s.action || `step-${i + 1}`,
                  description: s.description || 'Execute step',
                  status: 'pending' as const,
                  dependencies: s.dependencies || (i > 0 ? [`step-${i}`] : []),
                })
              )
            }
          } catch {
            // Fallback to default steps if JSON parsing fails
          }
        }
      }
    } catch {
      // AI not available, use default plan
    }

    // Fallback default steps if AI fails or returns nothing
    if (steps.length === 0) {
      steps = [
        {
          id: 'step-1',
          action: 'analyze',
          description: 'Analyze the goal and requirements',
          status: 'pending',
        },
        {
          id: 'step-2',
          action: 'research',
          description: 'Gather relevant information',
          status: 'pending',
          dependencies: ['step-1'],
        },
        {
          id: 'step-3',
          action: 'execute',
          description: 'Execute the main task',
          status: 'pending',
          dependencies: ['step-2'],
        },
        {
          id: 'step-4',
          action: 'review',
          description: 'Review and finalize results',
          status: 'pending',
          dependencies: ['step-3'],
        },
      ]
    }

    const plan: ActionPlan = {
      id: generateId(),
      goal: goalDescription,
      steps,
      status: 'pending',
      createdAt: now,
      updatedAt: now,
    }

    agent.plan = plan
    agent.updatedAt = now
    return plan
  }

  /**
   * Get the current plan for an agent
   */
  async getPlan(agentId: string): Promise<ActionPlan | null> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)
    return agent.plan || null
  }

  /**
   * Update a plan
   */
  async updatePlan(agentId: string, updates: Partial<ActionPlan>): Promise<ActionPlan> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)
    if (!agent.plan) throw new Error(`No plan exists for agent: ${agentId}`)

    Object.assign(agent.plan, updates)
    agent.plan.updatedAt = new Date()
    agent.updatedAt = new Date()
    return agent.plan
  }

  // ==================== Action Execution ====================

  /**
   * Execute an action
   */
  async execute(
    agentId: string,
    action: string,
    params?: Record<string, unknown>
  ): Promise<ActionResult> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)

    const startTime = Date.now()
    agent.status = 'acting'
    agent.updatedAt = new Date()

    let result: unknown
    let status: 'success' | 'failure' = 'success'
    let error: string | undefined

    try {
      // Check if this is a known action or tool
      const tool = agent.config.tools?.find((t) => t.name === action)

      if (action === 'think' || action === 'reason') {
        // Use AI for reasoning
        const ai = this.#env?.AI
        if (ai) {
          const response = (await ai.run('@cf/meta/llama-3.1-8b-instruct', {
            messages: [
              {
                role: 'system',
                content: `You are ${agent.name}. Think carefully and provide your reasoning.`,
              },
              { role: 'user', content: `Think about: ${JSON.stringify(params)}` },
            ],
          })) as { response?: string }
          result = response?.response || 'Completed thinking'
        } else {
          result = 'Thought process completed'
        }
      } else if (tool) {
        // Execute tool with AI
        const ai = this.#env?.AI
        if (ai) {
          const response = (await ai.run('@cf/meta/llama-3.1-8b-instruct', {
            messages: [
              {
                role: 'system',
                content: `You are executing the "${tool.name}" tool. ${tool.description}`,
              },
              { role: 'user', content: `Execute with parameters: ${JSON.stringify(params)}` },
            ],
          })) as { response?: string }
          result = response?.response || 'Tool executed'
        } else {
          result = `Executed ${action} with params: ${JSON.stringify(params)}`
        }
      } else if (action === 'longRunningTask') {
        // Simulated long-running task
        await new Promise((resolve) => setTimeout(resolve, 100))
        result = 'Long running task completed'
      } else {
        // Unknown action
        status = 'failure'
        error = `Unknown action: ${action}`
      }
    } catch (err) {
      status = 'failure'
      error = err instanceof Error ? err.message : String(err)
    }

    agent.status = 'idle'
    agent.updatedAt = new Date()

    return {
      id: generateId(),
      action,
      status,
      result,
      ...(error !== undefined && { error }),
      duration: Math.max(1, Date.now() - startTime),
      timestamp: new Date(),
    }
  }

  /**
   * Execute a specific step from the plan
   */
  async executeStep(agentId: string, stepId: string): Promise<ActionResult> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)
    if (!agent.plan) throw new Error(`No plan exists for agent: ${agentId}`)

    const step = agent.plan.steps.find((s) => s.id === stepId)
    if (!step) throw new Error(`Step not found: ${stepId}`)

    const startTime = Date.now()
    step.status = 'in_progress'
    agent.status = 'acting'
    agent.updatedAt = new Date()

    // Execute the step action
    const result = await this.execute(agentId, step.action, { step: step.description })

    // Update step status
    step.status = result.status === 'success' ? 'completed' : 'failed'
    step.result = result.result
    agent.plan.updatedAt = new Date()
    agent.updatedAt = new Date()

    return result
  }

  /**
   * Execute all steps in the plan
   */
  async executePlan(agentId: string): Promise<ActionResult[]> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)
    if (!agent.plan) throw new Error(`No plan exists for agent: ${agentId}`)

    agent.plan.status = 'executing'
    const results: ActionResult[] = []

    for (const step of agent.plan.steps) {
      const result = await this.executeStep(agentId, step.id)
      results.push(result)

      // Stop on failure
      if (result.status === 'failure') {
        agent.plan.status = 'failed'
        break
      }
    }

    // Mark plan as completed if all steps succeeded
    if (agent.plan.status === 'executing') {
      agent.plan.status = 'completed'
    }

    agent.plan.updatedAt = new Date()
    agent.updatedAt = new Date()
    return results
  }

  // ==================== Memory and Context ====================

  /**
   * Get agent memory
   */
  async getMemory(agentId: string): Promise<AgentMemory> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)
    return agent.memory
  }

  /**
   * Update agent memory
   */
  async updateMemory(agentId: string, updates: Partial<AgentMemory>): Promise<AgentMemory> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)

    if (updates.shortTerm) {
      agent.memory.shortTerm = updates.shortTerm
    }
    if (updates.longTerm) {
      Object.assign(agent.memory.longTerm, updates.longTerm)
    }
    if (updates.context) {
      Object.assign(agent.memory.context, updates.context)
    }

    agent.updatedAt = new Date()
    return agent.memory
  }

  /**
   * Add data to a specific memory type
   */
  async addToMemory(
    agentId: string,
    type: 'shortTerm' | 'longTerm' | 'context',
    data: unknown
  ): Promise<void> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)

    if (type === 'shortTerm') {
      const entry = data as { role: string; content: string }
      agent.memory.shortTerm.push({
        role: entry.role,
        content: entry.content,
        timestamp: new Date(),
      })
    } else if (type === 'longTerm') {
      Object.assign(agent.memory.longTerm, data)
    } else if (type === 'context') {
      Object.assign(agent.memory.context, data)
    }

    agent.updatedAt = new Date()
  }

  /**
   * Clear agent memory
   */
  async clearMemory(
    agentId: string,
    type?: 'shortTerm' | 'longTerm' | 'context' | 'all'
  ): Promise<void> {
    const agent = agentStore.get(agentId)
    if (!agent) throw new Error(`Agent not found: ${agentId}`)

    if (!type || type === 'all') {
      agent.memory.shortTerm = []
      agent.memory.longTerm = {}
      agent.memory.context = {}
    } else if (type === 'shortTerm') {
      agent.memory.shortTerm = []
    } else if (type === 'longTerm') {
      agent.memory.longTerm = {}
    } else if (type === 'context') {
      agent.memory.context = {}
    }

    agent.updatedAt = new Date()
  }

  // ==================== Multi-Agent Coordination ====================

  /**
   * Coordinate multiple agents
   */
  async coordinate(pattern: CoordinationPattern): Promise<CoordinationResult> {
    const startTime = Date.now()
    const results: Record<string, unknown> = {}
    let consensus: unknown

    if (pattern.type === 'sequential') {
      // Execute agents in sequence
      for (const agentId of pattern.agents) {
        const agent = agentStore.get(agentId)
        if (agent && pattern.goal) {
          const result = await this.execute(agentId, 'think', { about: pattern.goal })
          results[agentId] = result.result
        }
      }
    } else if (pattern.type === 'parallel') {
      // Execute agents in parallel
      await Promise.all(
        pattern.agents.map(async (agentId) => {
          const agent = agentStore.get(agentId)
          if (agent && pattern.goal) {
            const result = await this.execute(agentId, 'think', { about: pattern.goal })
            results[agentId] = result.result
          }
        })
      )
    } else if (pattern.type === 'hierarchical') {
      // Lead agent coordinates others
      const leadId = (pattern.config?.['lead'] as string) || pattern.agents[0]
      const subordinates = pattern.agents.filter((id) => id !== leadId)

      // Lead first
      if (leadId) {
        const leadResult = await this.execute(leadId, 'think', { about: `Lead: ${pattern.goal}` })
        results[leadId] = leadResult.result
      }

      // Then subordinates
      for (const subId of subordinates) {
        const result = await this.execute(subId, 'think', { about: pattern.goal })
        results[subId] = result.result
      }
    } else if (pattern.type === 'collaborative') {
      // All agents contribute to consensus
      const contributions: unknown[] = []
      for (const agentId of pattern.agents) {
        const result = await this.execute(agentId, 'think', { about: pattern.goal })
        results[agentId] = result.result
        contributions.push(result.result)
      }
      consensus = `Collaborative consensus from ${contributions.length} agents`
    } else if (pattern.type === 'competitive') {
      // Agents compete for best solution
      for (const agentId of pattern.agents) {
        const result = await this.execute(agentId, 'think', { about: pattern.goal })
        results[agentId] = result.result
      }
    }

    return {
      id: generateId(),
      pattern,
      status: 'completed',
      results,
      consensus,
      duration: Math.max(1, Date.now() - startTime),
    }
  }

  /**
   * Broadcast a message to multiple agents
   */
  async broadcast(agentIds: string[], message: string): Promise<void> {
    for (const agentId of agentIds) {
      const agent = agentStore.get(agentId)
      if (agent) {
        agent.memory.shortTerm.push({
          role: 'system',
          content: message,
          timestamp: new Date(),
        })
        agent.updatedAt = new Date()
      }
    }
  }

  /**
   * Delegate a task from one agent to another
   */
  async delegate(fromAgentId: string, toAgentId: string, task: string): Promise<ActionResult> {
    const fromAgent = agentStore.get(fromAgentId)
    const toAgent = agentStore.get(toAgentId)

    if (!fromAgent) throw new Error(`Agent not found: ${fromAgentId}`)
    if (!toAgent) throw new Error(`Agent not found: ${toAgentId}`)

    // Record delegation in delegator's memory
    const delegatedTasks = (fromAgent.memory.context['delegatedTasks'] || []) as unknown[]
    delegatedTasks.push({ to: toAgentId, task, timestamp: new Date() })
    fromAgent.memory.context['delegatedTasks'] = delegatedTasks

    // Record received task in delegate's memory
    const receivedTasks = (toAgent.memory.context['receivedTasks'] || []) as unknown[]
    receivedTasks.push({ from: fromAgentId, task, timestamp: new Date() })
    toAgent.memory.context['receivedTasks'] = receivedTasks

    // Execute the task
    const result = await this.execute(toAgentId, 'think', { about: task })

    fromAgent.updatedAt = new Date()
    toAgent.updatedAt = new Date()

    return result
  }
}

// ==================== AgentService WorkerEntrypoint ====================

/**
 * AgentService - WorkerEntrypoint for autonomous agent operations
 *
 * Extends WorkerEntrypoint to provide RPC access to AgentServiceCore.
 * The connect() method returns an RpcTarget that can be used via Service Bindings.
 *
 * Usage:
 * ```ts
 * // In another worker with a service binding
 * const service = env.AGENT.connect()
 * const agent = await service.create({ name: 'MyAgent' })
 * ```
 */
export class AgentService extends WorkerEntrypoint<Env> {
  // Declare env property for TypeScript (provided by WorkerEntrypoint at runtime)
  declare env: Env

  /**
   * Returns an RpcTarget that provides agent service methods
   */
  connect(): AgentServiceCore {
    return new AgentServiceCore(this.env)
  }
}

// Default export for wrangler
export default AgentService

// Export aliases
export { AgentService as AgentWorker }
