{"type":"route","meta":{"status":200,"headers":{"content-type":"text/plain;charset=UTF-8","x-next-cache-tags":"_N_T_/layout,_N_T_/llms-full.txt/layout,_N_T_/llms-full.txt/route,_N_T_/llms-full.txt"}},"body":"# Action\n\nURL: https://primitives.org.ai/action\n\n> Bound operations ready for execution\n\n\n\n# Action\n\nAn Action is a [Verb](/verb) bound to specific [Things](/thing), ready to be executed.\n\n## Overview\n\nWhile a **Verb** defines an operation abstractly, an **Action** is that operation bound to specific arguments. Actions can be queued, scheduled, approved, or executed immediately.\n\n```typescript\nimport { Verb, Action } from 'ai-database'\n\n// Define a verb\nconst Approve = Verb('approve')\n\n// Create an action (bound verb)\nconst approveInvoice = Action(Approve, {\n  subject: currentUser,\n  object: invoice,\n})\n\n// Execute the action\nawait approveInvoice.execute()\n```\n\n## Creating Actions\n\nActions are created by binding verbs to things:\n\n```typescript\n// From a verb\nconst action = Approve.bind(user, document)\n\n// Using Action constructor\nconst action = Action(Approve, { subject: user, object: document })\n\n// From natural language\nconst action = await Action.from('Approve invoice #1234 as admin')\n```\n\n## Action States\n\nActions have a lifecycle:\n\n```typescript\naction.status  // 'pending' | 'approved' | 'executing' | 'completed' | 'failed'\n\n// Check state\naction.isPending    // true if not yet executed\naction.isCompleted  // true if successfully executed\naction.isFailed     // true if execution failed\n```\n\n## Queuing Actions\n\nActions can be queued for later execution:\n\n```typescript\nimport { Queue } from 'digital-tasks'\n\n// Add to queue\nawait Queue.push(action)\n\n// With delay\nawait Queue.push(action, { delay: '1 hour' })\n\n// With priority\nawait Queue.push(action, { priority: 'high' })\n```\n\n## Approval Workflows\n\nActions can require approval before execution:\n\n```typescript\nimport { requireApproval } from 'human-in-the-loop'\n\nconst action = Action(TransferFunds, {\n  from: account1,\n  to: account2,\n  amount: 50000,\n})\n\n// Require human approval for large transfers\nif (action.args.amount > 10000) {\n  await requireApproval(action, {\n    approvers: ['finance-team'],\n    reason: 'Large transfer requires approval',\n  })\n}\n\nawait action.execute()\n```\n\n## Action Results\n\nExecuting an action returns a result and emits an [Event](/event):\n\n```typescript\nconst result = await action.execute()\n\nresult.success    // boolean\nresult.output     // the result data\nresult.event      // the emitted event\nresult.duration   // execution time\n```\n\n## See Also\n\n* [Verb](/verb) - Abstract operation definitions\n* [Thing](/thing) - Entities that actions operate on\n* [Event](/event) - Records of action execution\n* [Task](/task) - Higher-level work units\n\n\n# Domain\n\nURL: https://primitives.org.ai/domain\n\n> URL-based namespaces for everything\n\n\n\n# Domain\n\nA Domain is the foundational namespace for all primitives. In this architecture, everything is URL-addressable - agents don't know file systems, they only know URLs.\n\n## Overview\n\nEvery [Noun](/noun), [Verb](/verb), [Thing](/thing), [Function](/function), and [Agent](/agent) lives within a domain. Domains provide identity, discovery, and access control.\n\n```typescript\nimport { Domain } from 'ai-functions'\n\n// Define your domain\nconst domain = Domain('acme.do')\n\n// Everything is URL-addressable\ndomain.nouns      // https://acme.do/nouns\ndomain.functions  // https://acme.do/functions\ndomain.agents     // https://acme.do/agents\ndomain.things     // https://acme.do/things\n```\n\n## URL-First Architecture\n\nAgents interact with the world through URLs:\n\n```typescript\n// Agents discover capabilities via URLs\nconst customer = await fetch('https://acme.do/things/customer/cust_123')\nconst approve = await fetch('https://acme.do/verbs/approve')\nconst summarize = await fetch('https://acme.do/functions/summarize')\n\n// Execute functions via HTTP\nconst result = await fetch('https://acme.do/functions/summarize', {\n  method: 'POST',\n  body: JSON.stringify({ text: document }),\n})\n```\n\n## Domain Configuration\n\n```typescript\nimport { Domain } from 'ai-functions'\n\nconst domain = Domain('mycompany.do', {\n  // Display name\n  name: 'My Company',\n\n  // Domain description for discovery\n  description: 'AI-powered business automation',\n\n  // Authentication\n  auth: {\n    provider: 'oauth.do',\n    methods: ['api-key', 'oauth2'],\n  },\n\n  // Access control\n  access: {\n    public: ['functions/summarize', 'nouns/*'],\n    authenticated: ['things/*', 'actions/*'],\n    admin: ['agents/*', 'config/*'],\n  },\n})\n```\n\n## Resource URLs\n\nEvery resource has a canonical URL:\n\n```typescript\n// Nouns (type definitions)\nhttps://acme.do/nouns/Customer\nhttps://acme.do/nouns/Invoice\n\n// Things (instances)\nhttps://acme.do/things/customer/cust_123\nhttps://acme.do/things/invoice/inv_456\n\n// Verbs (operations)\nhttps://acme.do/verbs/approve\nhttps://acme.do/verbs/ship\n\n// Functions (AI capabilities)\nhttps://acme.do/functions/summarize\nhttps://acme.do/functions/translate\n\n// Agents\nhttps://acme.do/agents/sales-assistant\nhttps://acme.do/agents/support-bot\n\n// Workflows\nhttps://acme.do/workflows/onboarding\nhttps://acme.do/workflows/order-fulfillment\n```\n\n## Discovery\n\nDomains expose their capabilities for AI discovery:\n\n```typescript\n// Well-known discovery endpoint\nconst capabilities = await fetch('https://acme.do/.well-known/ai')\n\n// Returns structured capability manifest\n{\n  domain: 'acme.do',\n  nouns: ['Customer', 'Invoice', 'Order'],\n  verbs: ['create', 'approve', 'ship', 'refund'],\n  functions: ['summarize', 'classify', 'extract'],\n  agents: ['sales-assistant', 'support-bot'],\n}\n```\n\n## Cross-Domain References\n\nThings can reference resources in other domains:\n\n```typescript\nconst order = Thing(Order, {\n  customer: 'https://crm.do/things/customer/cust_123',\n  payment: 'https://payments.do/things/charge/ch_789',\n  shipping: 'https://logistics.do/things/shipment/ship_456',\n})\n```\n\n## Domain Federation\n\nDomains can federate and trust each other:\n\n```typescript\nconst domain = Domain('acme.do', {\n  federation: {\n    trusted: ['partners.do', 'suppliers.do'],\n    permissions: {\n      'partners.do': ['read:things', 'execute:functions'],\n      'suppliers.do': ['read:nouns'],\n    },\n  },\n})\n```\n\n## See Also\n\n* [Noun](/noun) - Types within a domain\n* [Thing](/thing) - Instances within a domain\n* [Function](/function) - Capabilities exposed by a domain\n* [Agent](/agent) - Actors operating within domains\n\n\n# Event\n\nURL: https://primitives.org.ai/event\n\n> Records of what happened in your system\n\n\n\n# Event\n\nEvents are immutable records of things that happened in your system.\n\n## Overview\n\nAn **Event** captures the fact that something occurred - a [Verb](/verb) was executed, a [Thing](/thing) changed, or an external trigger fired. Events are the foundation for audit logs, event sourcing, and reactive systems.\n\n```typescript\nimport { Event } from 'ai-database'\n\n// Events are emitted automatically when verbs execute\nawait Approve(user, document)\n// Emits: { type: 'Document.approved', actor: user, target: document, ... }\n\n// Subscribe to events\nEvent.on('Document.approved', async (event) => {\n  await notify(event.target.author, 'Your document was approved!')\n})\n```\n\n## Event Structure\n\nEvery event has a consistent structure:\n\n```typescript\ninterface Event {\n  id: string           // Unique event ID\n  type: string         // Event type (e.g., 'Order.shipped')\n  timestamp: Date      // When it occurred\n\n  actor?: Thing        // Who/what caused it\n  target?: Thing       // What it affected\n\n  data: object         // Event-specific data\n  metadata: object     // Additional context\n}\n```\n\n## Subscribing to Events\n\n```typescript\nimport { Event } from 'ai-database'\n\n// Subscribe to specific event type\nEvent.on('Order.created', async (event) => {\n  await sendConfirmation(event.target)\n})\n\n// Subscribe to all events for a noun\nEvent.on('Order.*', async (event) => {\n  await updateAnalytics(event)\n})\n\n// Subscribe to all events\nEvent.on('*', async (event) => {\n  await auditLog.append(event)\n})\n```\n\n## Emitting Events\n\n```typescript\n// Events are usually emitted by verbs, but can be manual\nimport { emit } from 'ai-database'\n\nawait emit({\n  type: 'User.signedIn',\n  actor: user,\n  data: { method: 'oauth', provider: 'google' },\n})\n```\n\n## Event Sourcing\n\nEvents can be the source of truth:\n\n```typescript\nimport { EventStore } from 'ai-database'\n\n// Replay events to rebuild state\nconst account = await EventStore.replay('Account', accountId)\n\n// Get event history\nconst history = await EventStore.history('Order', orderId)\n\n// Time travel\nconst orderAtTime = await EventStore.at('Order', orderId, pastDate)\n```\n\n## Event Patterns\n\nCommon event-driven patterns:\n\n```typescript\n// Saga / Process Manager\nEvent.on('Order.paid', async (event) => {\n  await Action(Ship, event.target).execute()\n})\n\n// Event notification\nEvent.on('*.created', async (event) => {\n  await webhooks.notify(event)\n})\n\n// Materialized view\nEvent.on('Order.*', async (event) => {\n  await views.orders.update(event)\n})\n```\n\n## See Also\n\n* [Verb](/verb) - Operations that emit events\n* [Action](/action) - Bound operations\n* [Workflow](/workflow) - Event-driven orchestration\n* [Database Events](/database/events) - Detailed event handling\n\n\n# Experiment\n\nURL: https://primitives.org.ai/experiment\n\n> Controlled testing and iteration\n\n\n\n# Experiment\n\nExperiments enable controlled testing, A/B testing, and systematic iteration on AI functions and workflows.\n\n## Overview\n\nAn **Experiment** lets you test variations of prompts, models, parameters, or entire workflows against each other. Track metrics, compare results, and gradually roll out winning variants.\n\n```typescript\nimport { Experiment } from 'ai-experiments'\n\nconst experiment = Experiment('summarization-v2', {\n  variants: {\n    control: { model: 'gpt-4', prompt: existingPrompt },\n    treatment: { model: 'claude-3', prompt: newPrompt },\n  },\n  metrics: ['quality', 'latency', 'cost'],\n  allocation: { control: 50, treatment: 50 },\n})\n\n// Run with experiment\nconst result = await experiment.run(input)\n```\n\n## Defining Experiments\n\n```typescript\nimport { Experiment } from 'ai-experiments'\n\nconst experiment = Experiment('checkout-flow', {\n  // Define variants to test\n  variants: {\n    baseline: {\n      steps: ['cart', 'shipping', 'payment', 'confirm'],\n    },\n    streamlined: {\n      steps: ['cart', 'payment'], // Combined shipping + confirm\n    },\n  },\n\n  // Metrics to track\n  metrics: ['conversion', 'time_to_complete', 'abandonment'],\n\n  // Traffic allocation (percentages)\n  allocation: { baseline: 80, streamlined: 20 },\n\n  // Experiment duration\n  duration: '2 weeks',\n})\n```\n\n## A/B Testing AI Functions\n\n```typescript\nimport { AI } from 'ai-functions'\nimport { Experiment } from 'ai-experiments'\n\n// Test different prompt strategies\nconst experiment = Experiment('email-generation', {\n  variants: {\n    concise: AI('Write a brief, professional email', { maxTokens: 200 }),\n    detailed: AI('Write a comprehensive, friendly email', { maxTokens: 500 }),\n  },\n  metrics: ['user_satisfaction', 'response_rate'],\n})\n\n// Use in production\nexport const generateEmail = experiment.wrap(async (context) => {\n  return await experiment.run(context)\n})\n```\n\n## Tracking Metrics\n\n```typescript\n// Record outcomes\nawait experiment.record(variantId, {\n  quality: 0.92,\n  latency: 450,\n  userSatisfaction: 4.5,\n})\n\n// Get current results\nconst results = await experiment.results()\n// {\n//   control: { quality: 0.88, latency: 520, n: 1000 },\n//   treatment: { quality: 0.92, latency: 450, n: 1000 },\n//   winner: 'treatment',\n//   confidence: 0.95\n// }\n```\n\n## Gradual Rollout\n\n```typescript\n// Start with small allocation\nawait experiment.setAllocation({ control: 95, treatment: 5 })\n\n// If metrics look good, increase\nawait experiment.setAllocation({ control: 50, treatment: 50 })\n\n// Promote winner to 100%\nawait experiment.promote('treatment')\n```\n\n## Experiment Lifecycle\n\n```typescript\nexperiment.status  // 'draft' | 'running' | 'paused' | 'completed'\n\nawait experiment.start()\nawait experiment.pause()\nawait experiment.resume()\nawait experiment.complete()\n\n// Archive with results\nawait experiment.archive()\n```\n\n## See Also\n\n* [Function](/function) - AI functions to experiment on\n* [Workflow](/workflow) - Workflow variations\n* [Database](/database) - Storing experiment data\n\n\n# Goal\n\nURL: https://primitives.org.ai/goal\n\n> Desired outcomes and objectives\n\n\n\n# Goal\n\nGoals represent desired outcomes - the \"why\" behind work. Goals break down into [Plans](/plan), which become [Projects](/project), which contain [Tasks](/task).\n\n## Overview\n\nA **Goal** is a high-level objective with measurable success criteria. Goals provide direction and context for all downstream work.\n\n```typescript\nimport { Goal } from 'business-as-code'\n\nconst goal = Goal('Increase customer retention', {\n  metric: 'retention_rate',\n  target: 0.95,        // 95% retention\n  baseline: 0.82,      // Current 82%\n  deadline: '2024-Q4',\n})\n\n// Track progress\ngoal.progress  // 0.65 (65% of the way to target)\ngoal.onTrack   // true/false based on trajectory\n```\n\n## Defining Goals\n\n```typescript\nimport { Goal } from 'business-as-code'\n\nconst goal = Goal('Launch mobile app', {\n  description: 'Ship iOS and Android apps to production',\n\n  // Success criteria\n  criteria: [\n    'App approved in App Store',\n    'App approved in Play Store',\n    '1000+ downloads in first week',\n    'Rating above 4.0 stars',\n  ],\n\n  // Timeline\n  deadline: '2024-06-01',\n\n  // Owner\n  owner: 'mobile-team',\n})\n```\n\n## Goal Hierarchies\n\nGoals can have sub-goals:\n\n```typescript\nconst companyGoal = Goal('Become market leader', {\n  subgoals: [\n    Goal('Double revenue', { target: 2_000_000 }),\n    Goal('Expand to 3 new markets'),\n    Goal('Achieve 50 NPS'),\n  ],\n})\n\n// Progress rolls up\ncompanyGoal.progress  // Average of subgoal progress\n```\n\n## Goals to Plans\n\nGoals break down into actionable plans:\n\n```typescript\nimport { Plan } from 'business-as-code'\n\nconst goal = Goal('Reduce churn by 20%')\n\nconst plan = Plan.for(goal, {\n  strategies: [\n    'Improve onboarding experience',\n    'Add proactive customer success',\n    'Build self-service help center',\n  ],\n})\n```\n\n## Tracking Progress\n\n```typescript\n// Quantitative goals\ngoal.current = 0.88  // Current metric value\ngoal.progress        // (0.88 - 0.82) / (0.95 - 0.82) = 0.46\n\n// Criteria-based goals\nawait goal.complete('App approved in App Store')\ngoal.progress  // 0.25 (1 of 4 criteria met)\n\n// Time-based tracking\ngoal.daysRemaining   // 45\ngoal.velocity        // Progress per day\ngoal.projectedDate   // When goal will be met at current velocity\n```\n\n## Goal States\n\n```typescript\ngoal.status  // 'not_started' | 'in_progress' | 'at_risk' | 'achieved' | 'missed'\n\n// Automatic status based on progress and timeline\ngoal.isAtRisk    // Behind trajectory\ngoal.isAchieved  // Met or exceeded target\n```\n\n## See Also\n\n* [Plan](/plan) - Strategies to achieve goals\n* [Project](/project) - Concrete initiatives\n* [Task](/task) - Individual work items\n* [Business](/business) - Business primitives\n\n\n# Primitives.org.ai\n\nURL: https://primitives.org.ai/\n\n> The fundamental abstractions for building AI-native software\n\n\n\n# Build Business-as-Code & AI-Delivered Services-as-Software\n\nPrimitives for building software where humans and AI work together seamlessly.\nFrom functions to businesses, every layer is designed for the age of AI.\n\n<Cards columns={3}>\n  <Card icon={<Code />} title=\"Function\" href=\"/function\">\n    Code, Generative, Agentic, Humanâ€”unified interface\n  </Card>\n\n  <Card icon={<Database />} title=\"Database\" href=\"/database\">\n    Schema-driven with vector embeddings\n  </Card>\n\n  <Card icon={<GitBranch />} title=\"Workflow\" href=\"/workflow\">\n    Durable execution and state machines\n  </Card>\n\n  <Card icon={<ListTodo />} title=\"Task\" href=\"/task\">\n    Work units with assignment and tracking\n  </Card>\n\n  <Card icon={<Bot />} title=\"Agent\" href=\"/agent\">\n    Autonomous entities with real identity\n  </Card>\n\n  <Card icon={<UserCircle />} title=\"Human\" href=\"/human\">\n    Approvals, reviews, and judgment calls\n  </Card>\n\n  <Card icon={<Package />} title=\"Product\" href=\"/product\">\n    Compose primitives into products\n  </Card>\n\n  <Card icon={<Briefcase />} title=\"Service\" href=\"/service\">\n    AI delivering human-quality work\n  </Card>\n\n  <Card icon={<Building2 />} title=\"Business\" href=\"/business\">\n    Organizations as executable code\n  </Card>\n</Cards>\n\n## Built for the AI Era\n\nThe age of AI requires new primitives. Traditional software abstractions assume deterministic execution and human-only workflows.\n\n* **Heterogeneous Computation** â€” Code, AI models, autonomous agents, and humans all participate in the same workflows with the same interfaces.\n* **Uncertain Execution** â€” Generative and agentic functions produce variable outputs. The primitives handle retries, validation, and fallbacks transparently.\n* **Distributed State** â€” Context flows across systems, conversations, and time horizons. Vector embeddings enable semantic understanding.\n* **Collaborative Work** â€” AI and humans hand off tasks seamlessly. Each contributes their strengths with clear escalation paths.\n\n## Get Started\n\n```bash\nnpm install ai-functions\n```\n\nStart with [Functions](/function)â€”the foundation everything else builds on.\n\n\n# Noun\n\nURL: https://primitives.org.ai/noun\n\n> Named entities and concepts in your domain\n\n\n\n# Noun\n\nNouns represent the named entities and concepts in your domain - the \"things\" you're working with.\n\n## Overview\n\nIn the primitives framework, a **Noun** is a type definition for domain entities. Nouns define the schema for [Things](/thing) - the actual instances that exist in your system.\n\n```typescript\nimport { Noun } from 'ai-database'\n\n// Define a noun (type/schema)\nconst Customer = Noun('Customer', {\n  name: 'string',\n  email: 'string',\n  tier: ['free', 'pro', 'enterprise'],\n})\n\n// Create a thing (instance)\nconst customer = Customer.create({\n  name: 'Acme Corp',\n  email: 'hello@acme.com',\n  tier: 'pro',\n})\n```\n\n## Defining Nouns\n\nNouns are defined with a name and a schema:\n\n```typescript\nimport { Noun } from 'ai-database'\n\nconst Invoice = Noun('Invoice', {\n  number: 'string',\n  amount: 'number',\n  status: ['draft', 'sent', 'paid', 'overdue'],\n  dueDate: 'Date',\n})\n```\n\n## AI-Inferred Nouns\n\nNouns can be inferred from natural language:\n\n```typescript\nimport { Noun } from 'ai-database'\n\n// AI infers the schema from the description\nconst Product = Noun('Product', `\n  A product in our catalog with a name, description,\n  price, and inventory count. Products belong to categories\n  and can have multiple variants.\n`)\n```\n\n## Relationships\n\nNouns can define relationships to other nouns:\n\n```typescript\nconst Order = Noun('Order', {\n  number: 'string',\n  customer: Customer,        // belongs to Customer\n  items: [OrderItem],        // has many OrderItems\n  status: ['pending', 'processing', 'shipped', 'delivered'],\n})\n```\n\n## See Also\n\n* [Thing](/thing) - Instances of nouns\n* [Verb](/verb) - Actions that operate on nouns\n* [Database](/database) - Storage and querying of nouns and things\n\n\n# Plan\n\nURL: https://primitives.org.ai/plan\n\n> Strategies and approaches to achieve goals\n\n\n\n# Plan\n\nPlans define the strategy and approach to achieve [Goals](/goal). Plans break down into [Projects](/project) with concrete deliverables.\n\n## Overview\n\nA **Plan** bridges the gap between aspirational goals and executable work. It outlines the approach, resources, milestones, and success criteria.\n\n```typescript\nimport { Plan } from 'business-as-code'\n\nconst plan = Plan('Customer Retention Initiative', {\n  goal: retentionGoal,\n\n  approach: `\n    Focus on early warning detection and proactive engagement.\n    Invest in customer success tooling and expand the CS team.\n  `,\n\n  phases: [\n    { name: 'Discovery', duration: '2 weeks' },\n    { name: 'Build', duration: '6 weeks' },\n    { name: 'Rollout', duration: '4 weeks' },\n  ],\n})\n```\n\n## Creating Plans\n\n```typescript\nimport { Plan } from 'business-as-code'\n\nconst plan = Plan('Mobile App Launch', {\n  // Link to goal\n  goal: Goal.get('launch-mobile-app'),\n\n  // High-level approach\n  approach: 'Build native apps with shared business logic',\n\n  // Key decisions\n  decisions: [\n    'Use React Native for cross-platform development',\n    'Launch iOS first, Android 2 weeks later',\n    'Soft launch to beta users before public release',\n  ],\n\n  // Resource requirements\n  resources: {\n    team: ['2 mobile devs', '1 designer', '0.5 PM'],\n    budget: 150000,\n    duration: '4 months',\n  },\n\n  // Risk mitigation\n  risks: [\n    { risk: 'App Store rejection', mitigation: 'Early TestFlight reviews' },\n    { risk: 'Scope creep', mitigation: 'Strict MVP definition' },\n  ],\n})\n```\n\n## Plan Phases\n\n```typescript\nconst plan = Plan('Platform Migration', {\n  phases: [\n    {\n      name: 'Assessment',\n      duration: '2 weeks',\n      deliverables: ['Current state analysis', 'Migration roadmap'],\n    },\n    {\n      name: 'Pilot',\n      duration: '4 weeks',\n      deliverables: ['Migrate 1 service', 'Validate approach'],\n    },\n    {\n      name: 'Migration',\n      duration: '8 weeks',\n      deliverables: ['All services migrated', 'Data validated'],\n    },\n    {\n      name: 'Cutover',\n      duration: '1 week',\n      deliverables: ['Production traffic switched', 'Old system decommissioned'],\n    },\n  ],\n})\n\n// Track phase progress\nplan.currentPhase  // 'Pilot'\nplan.phaseProgress // 0.6 (60% through current phase)\n```\n\n## Plans to Projects\n\nPlans spawn concrete projects:\n\n```typescript\nimport { Project } from 'business-as-code'\n\n// Generate projects from plan\nconst projects = await plan.createProjects()\n\n// Or manually\nconst project = Project.for(plan, {\n  name: 'Build Churn Prediction Model',\n  phase: 'Build',\n  deliverables: ['ML model', 'Integration API', 'Dashboard'],\n})\n```\n\n## AI-Assisted Planning\n\n```typescript\nimport { AI } from 'ai-functions'\n\n// Generate plan from goal\nconst plan = await AI.plan(goal, {\n  constraints: ['Budget under $100k', '3 month timeline'],\n  context: await getCompanyContext(),\n})\n\n// Critique and improve plan\nconst feedback = await AI.review(plan, {\n  criteria: ['feasibility', 'completeness', 'risk coverage'],\n})\n```\n\n## Plan States\n\n```typescript\nplan.status  // 'draft' | 'approved' | 'in_progress' | 'completed' | 'cancelled'\n\nawait plan.submit()   // Submit for approval\nawait plan.approve()  // Approve and start\nawait plan.complete() // Mark as done\n```\n\n## See Also\n\n* [Goal](/goal) - What plans aim to achieve\n* [Project](/project) - Concrete initiatives from plans\n* [Task](/task) - Work items within projects\n* [Workflow](/workflow) - Automated execution\n\n\n# Project\n\nURL: https://primitives.org.ai/project\n\n> Concrete initiatives with deliverables\n\n\n\n# Project\n\nProjects are concrete initiatives with defined scope, deliverables, and timelines. Projects contain [Tasks](/task) and roll up to [Plans](/plan).\n\n## Overview\n\nA **Project** is a bounded effort to produce specific deliverables. Unlike ongoing operations, projects have a clear start, end, and success criteria.\n\n```typescript\nimport { Project } from 'business-as-code'\n\nconst project = Project('Customer Portal Redesign', {\n  plan: retentionPlan,\n\n  deliverables: [\n    'New dashboard UI',\n    'Self-service account management',\n    'Usage analytics page',\n  ],\n\n  timeline: {\n    start: '2024-03-01',\n    end: '2024-05-15',\n  },\n\n  team: ['@alice', '@bob', '@carol'],\n})\n```\n\n## Creating Projects\n\n```typescript\nimport { Project } from 'business-as-code'\n\nconst project = Project('API v2 Development', {\n  // Optional link to plan\n  plan: apiModernizationPlan,\n\n  // What we're building\n  description: 'Build next-generation REST and GraphQL APIs',\n\n  deliverables: [\n    'REST API with OpenAPI spec',\n    'GraphQL API with schema',\n    'SDK for JavaScript and Python',\n    'API documentation site',\n  ],\n\n  // Timeline\n  timeline: {\n    start: '2024-02-01',\n    end: '2024-04-30',\n    milestones: [\n      { name: 'API Design Complete', date: '2024-02-15' },\n      { name: 'Alpha Release', date: '2024-03-15' },\n      { name: 'Beta Release', date: '2024-04-15' },\n    ],\n  },\n\n  // Resources\n  team: {\n    lead: '@sarah',\n    members: ['@mike', '@lisa', '@john'],\n  },\n  budget: 75000,\n})\n```\n\n## Project Tasks\n\nProjects contain tasks:\n\n```typescript\nimport { Task } from 'digital-tasks'\n\n// Add tasks to project\nawait project.addTask(Task('Design API schema'))\nawait project.addTask(Task('Implement authentication'))\nawait project.addTask(Task('Write integration tests'))\n\n// Get all tasks\nconst tasks = await project.tasks()\n\n// Task completion drives project progress\nproject.progress  // Based on completed tasks\n```\n\n## Project Boards\n\n```typescript\n// Kanban-style board\nconst board = await project.board()\n// {\n//   backlog: [task1, task2],\n//   todo: [task3],\n//   inProgress: [task4, task5],\n//   review: [task6],\n//   done: [task7, task8, task9]\n// }\n\n// Move tasks\nawait task4.moveTo('review')\n```\n\n## Milestones\n\n```typescript\n// Track milestone progress\nconst milestones = project.milestones\n\nfor (const milestone of milestones) {\n  console.log(milestone.name, milestone.status, milestone.progress)\n}\n\n// Mark milestone complete\nawait project.completeMilestone('Alpha Release')\n```\n\n## Project Health\n\n```typescript\nproject.health  // 'healthy' | 'at_risk' | 'critical'\n\n// Health factors\nproject.schedule.status    // 'on_track' | 'behind' | 'ahead'\nproject.budget.status      // 'on_track' | 'over' | 'under'\nproject.scope.status       // 'stable' | 'creeping' | 'reduced'\n\n// Blockers\nconst blockers = await project.blockers()\n```\n\n## Project States\n\n```typescript\nproject.status  // 'planning' | 'active' | 'paused' | 'completed' | 'cancelled'\n\nawait project.start()\nawait project.pause('Waiting for dependency')\nawait project.resume()\nawait project.complete()\n```\n\n## See Also\n\n* [Plan](/plan) - Strategic context for projects\n* [Task](/task) - Work items within projects\n* [Goal](/goal) - What projects contribute to\n* [Workflow](/workflow) - Automated project workflows\n\n\n# Thing\n\nURL: https://primitives.org.ai/thing\n\n> Instances and entities in your system\n\n\n\n# Thing\n\nThings are the concrete instances of [Nouns](/noun) - the actual entities that exist in your system.\n\n## Overview\n\nWhile a **Noun** defines a type or schema, a **Thing** is an actual instance with real data. Things have identity, state, and can be acted upon by [Verbs](/verb).\n\n```typescript\nimport { Noun, Thing } from 'ai-database'\n\n// Define the noun (type)\nconst Customer = Noun('Customer', {\n  name: 'string',\n  email: 'string',\n  tier: ['free', 'pro', 'enterprise'],\n})\n\n// Create a thing (instance)\nconst acme = Thing(Customer, {\n  id: 'cust_acme',\n  name: 'Acme Corp',\n  email: 'hello@acme.com',\n  tier: 'pro',\n})\n```\n\n## Creating Things\n\nThings can be created in several ways:\n\n```typescript\n// From a noun's create method\nconst customer = await Customer.create({\n  name: 'Acme Corp',\n  email: 'hello@acme.com',\n})\n\n// Using the Thing constructor\nconst customer = Thing(Customer, {\n  name: 'Acme Corp',\n  email: 'hello@acme.com',\n})\n\n// From natural language\nconst customer = await Thing.from(`\n  Create a new enterprise customer called Acme Corp\n  with email hello@acme.com\n`)\n```\n\n## Thing Identity\n\nEvery thing has a unique identity:\n\n```typescript\nconst customer = await Customer.create({ name: 'Acme' })\n\ncustomer.id        // \"cust_abc123\" - unique identifier\ncustomer.$type     // \"Customer\" - the noun type\ncustomer.$uri      // \"customers/cust_abc123\" - resource URI\n```\n\n## Reading Things\n\n```typescript\n// By ID\nconst customer = await Customer.get('cust_abc123')\n\n// By query\nconst customers = await Customer.find({ tier: 'enterprise' })\n\n// By natural language\nconst customers = await Customer.find('all enterprise customers from California')\n```\n\n## Updating Things\n\n```typescript\n// Direct update\nawait customer.update({ tier: 'enterprise' })\n\n// Via verb\nawait Upgrade(customer, { tier: 'enterprise' })\n\n// Returns updated thing\nconst updated = await Customer.update('cust_abc123', { tier: 'enterprise' })\n```\n\n## Deleting Things\n\n```typescript\n// Direct delete\nawait customer.delete()\n\n// By ID\nawait Customer.delete('cust_abc123')\n\n// Soft delete (if configured)\nawait customer.archive()\n```\n\n## See Also\n\n* [Noun](/noun) - Type definitions for things\n* [Verb](/verb) - Operations on things\n* [Action](/action) - Bound operations on specific things\n* [Database](/database) - Persistence and querying\n\n\n# Verb\n\nURL: https://primitives.org.ai/verb\n\n> Actions and operations in your domain\n\n\n\n# Verb\n\nVerbs represent actions and operations that can be performed on [Things](/thing) in your domain.\n\n## Overview\n\nA **Verb** defines an operation with its parameters, preconditions, and effects. Verbs create [Actions](/action) when applied to specific things, and emit [Events](/event) when executed.\n\n```typescript\nimport { Verb } from 'ai-database'\n\n// Define a verb\nconst Approve = Verb('approve', {\n  subject: 'User',\n  object: 'Document',\n  preconditions: (user, doc) => doc.status === 'pending',\n  effect: (user, doc) => ({ ...doc, status: 'approved', approvedBy: user.id }),\n})\n\n// Use the verb\nawait Approve(currentUser, document)\n```\n\n## Defining Verbs\n\nVerbs capture the semantics of domain operations:\n\n```typescript\nimport { Verb } from 'ai-database'\n\nconst Ship = Verb('ship', {\n  subject: 'Warehouse',\n  object: 'Order',\n  preconditions: (warehouse, order) =>\n    order.status === 'paid' && warehouse.hasInventory(order.items),\n  effect: (warehouse, order) => ({\n    ...order,\n    status: 'shipped',\n    shippedFrom: warehouse.id,\n    shippedAt: new Date(),\n  }),\n})\n```\n\n## Verb Conjugation\n\nVerbs automatically conjugate for different contexts:\n\n```typescript\nconst verb = Verb('create')\n\nverb.infinitive  // \"create\"\nverb.pastTense   // \"created\"\nverb.present     // \"creates\"\nverb.gerund      // \"creating\"\n```\n\n## Events from Verbs\n\nWhen a verb executes, it emits an event:\n\n```typescript\n// Executing a verb\nconst result = await Ship(warehouse, order)\n\n// Emits event:\n// {\n//   type: 'Order.shipped',\n//   subject: warehouse,\n//   object: order,\n//   timestamp: Date,\n//   result: { ...updatedOrder }\n// }\n```\n\n## Built-in Verbs\n\nCommon CRUD verbs are built-in:\n\n```typescript\nimport { create, read, update, delete as remove, list } from 'ai-database'\n\nawait create(Customer, { name: 'Acme' })\nawait read(Customer, 'cust_123')\nawait update(Customer, 'cust_123', { tier: 'pro' })\nawait remove(Customer, 'cust_123')\nawait list(Customer, { tier: 'pro' })\n```\n\n## See Also\n\n* [Noun](/noun) - Types that verbs operate on\n* [Thing](/thing) - Instances that verbs act upon\n* [Action](/action) - Bound verb invocations\n* [Event](/event) - Records of verb execution\n\n\n# Autonomy\n\nURL: https://primitives.org.ai/agent/autonomy\n\n> Independent decision-making and action\n\n\n\n# Agent Autonomy\n\nAgents work independently, making decisions and taking actions without constant supervision while operating within defined boundaries.\n\n## Autonomy Configuration\n\n```typescript\nimport { agent } from 'autonomous-agents'\n\nconst agent = agent({\n  name: 'autonomous-support',\n\n  autonomy: {\n    // Actions the agent can take independently\n    canDo: [\n      'answer-common-questions',\n      'look-up-documentation',\n      'create-tickets',\n      'send-status-updates',\n    ],\n\n    // Actions requiring approval\n    requiresApproval: [\n      'close-tickets',\n      'issue-refunds',\n      'modify-user-accounts',\n    ],\n\n    // When to escalate\n    escalateTo: 'support-team',\n    escalateWhen: [\n      'confidence < 0.7',\n      'customer-sentiment = angry',\n      'topic = legal',\n    ],\n  },\n})\n```\n\n## Decision Making\n\n### Making Decisions\n\n```typescript\n// Agent evaluates options and decides\nconst decision = await agent.decide({\n  situation: 'Customer asking about enterprise pricing',\n  context: await agent.memory.recall({ customer }),\n\n  options: [\n    { action: 'answer-directly', confidence: 0.3 },\n    { action: 'escalate-to-sales', confidence: 0.9 },\n    { action: 'schedule-call', confidence: 0.7 },\n    { action: 'send-pricing-doc', confidence: 0.6 },\n  ],\n})\n\nconsole.log(decision.chosen)      // 'escalate-to-sales'\nconsole.log(decision.reasoning)   // Explanation of why\nconsole.log(decision.confidence)  // 0.9\n```\n\n### Decision Logging\n\n```typescript\n// All decisions are logged\nconst recentDecisions = await agent.getDecisionLog({\n  since: lastWeek,\n  includeReasoning: true,\n})\n\n// Review decisions\nrecentDecisions.forEach((decision) => {\n  console.log(decision.situation)\n  console.log(decision.chosen)\n  console.log(decision.outcome)  // If feedback provided\n})\n```\n\n## Action Execution\n\n### Autonomous Actions\n\n```typescript\n// Define what agent can do\nconst capabilities = [\n  capability({\n    name: 'answer-question',\n    description: 'Answer common support questions',\n    autonomous: true,  // Can execute without approval\n    handler: async (question) => {\n      const answer = await agent.think(question)\n      return answer\n    },\n  }),\n\n  capability({\n    name: 'issue-refund',\n    description: 'Process customer refunds',\n    autonomous: false,  // Requires approval\n    approvalFrom: 'finance-team',\n    handler: async (refund) => {\n      await processRefund(refund)\n    },\n  }),\n]\n\n// Execute autonomous action\nawait agent.execute('answer-question', { question: 'How do I reset my password?' })\n\n// Request approval for restricted action\nconst approval = await agent.requestApproval('issue-refund', {\n  amount: 150,\n  reason: 'Service disruption',\n  customer: 'customer@example.com',\n})\n\nif (approval.granted) {\n  await agent.execute('issue-refund', approval.params)\n}\n```\n\n### Action Policies\n\n```typescript\nconst agent = agent({\n  policies: {\n    // Rate limits\n    maxActionsPerHour: 100,\n    maxActionsPerDay: 1000,\n\n    // Spending limits\n    maxRefundAmount: 100,\n    maxTotalRefundsPerDay: 500,\n\n    // Time restrictions\n    activeHours: { start: '09:00', end: '18:00', timezone: 'America/New_York' },\n\n    // Content restrictions\n    prohibitedTopics: ['competitor-comparisons', 'future-roadmap'],\n  },\n})\n```\n\n## Escalation\n\n### Automatic Escalation\n\n```typescript\nagent.onInteraction(async (interaction) => {\n  // Check escalation conditions\n  const shouldEscalate = await agent.checkEscalation({\n    confidence: interaction.confidence,\n    sentiment: interaction.customerSentiment,\n    topic: interaction.topic,\n    duration: interaction.duration,\n  })\n\n  if (shouldEscalate) {\n    await agent.escalate({\n      to: shouldEscalate.team,\n      reason: shouldEscalate.reason,\n      context: interaction,\n      priority: shouldEscalate.priority,\n    })\n  }\n})\n```\n\n### Escalation Rules\n\n```typescript\nconst escalationRules = [\n  {\n    condition: 'confidence < 0.5',\n    action: 'escalate',\n    to: 'support-team',\n    priority: 'normal',\n  },\n  {\n    condition: 'customer.sentiment = angry',\n    action: 'escalate',\n    to: 'senior-support',\n    priority: 'high',\n  },\n  {\n    condition: 'topic = billing AND amount > 1000',\n    action: 'escalate',\n    to: 'finance-team',\n    priority: 'high',\n  },\n  {\n    condition: 'attempts > 3',\n    action: 'escalate',\n    to: 'escalations',\n    priority: 'urgent',\n  },\n]\n```\n\n## Learning from Outcomes\n\n### Outcome Tracking\n\n```typescript\n// Track outcomes of decisions\nawait agent.recordOutcome({\n  decisionId: 'dec_123',\n  outcome: 'success',\n  customerSatisfied: true,\n  resolutionTime: 300000,  // ms\n  notes: 'Customer confirmed issue resolved',\n})\n\n// Agent learns from outcomes\nawait agent.learn()\n```\n\n### Feedback Integration\n\n```typescript\n// Human provides feedback\nawait agent.feedback({\n  decisionId: 'dec_456',\n  outcome: 'incorrect',\n  correction: 'Should have escalated this to billing',\n  reason: 'Customer had a valid refund request',\n})\n\n// Agent adjusts behavior\nagent.onFeedback(async (feedback) => {\n  if (feedback.outcome === 'incorrect') {\n    // Adjust confidence thresholds\n    await agent.adjust({\n      situation: feedback.situation,\n      adjustment: 'lower-confidence',\n      amount: 0.1,\n    })\n  }\n})\n```\n\n## Confidence and Uncertainty\n\n### Confidence Scoring\n\n```typescript\n// Agent tracks confidence in its decisions\nconst response = await agent.think({\n  question: 'Can I get a refund after 90 days?',\n})\n\nconsole.log(response.answer)\nconsole.log(response.confidence)  // 0.85\nconsole.log(response.sources)     // What informed the answer\n\n// Act based on confidence\nif (response.confidence < 0.7) {\n  await agent.requestHumanReview(response)\n}\n```\n\n### Uncertainty Handling\n\n```typescript\nagent.onUncertain(async (situation) => {\n  // Options when uncertain\n  const action = await agent.decide({\n    situation,\n    options: [\n      { action: 'ask-clarifying-question', confidence: 0.8 },\n      { action: 'provide-partial-answer', confidence: 0.5 },\n      { action: 'escalate-to-human', confidence: 0.9 },\n    ],\n  })\n\n  await agent.execute(action)\n})\n```\n\n## Proactive Behavior\n\n```typescript\nconst agent = agent({\n  proactive: {\n    // Agent initiates actions based on conditions\n    triggers: [\n      {\n        condition: 'ticket.age > 24h AND ticket.status = open',\n        action: 'follow-up',\n        message: 'Checking in on your request...',\n      },\n      {\n        condition: 'user.activity = none AND user.onboarding = incomplete',\n        action: 'send-reminder',\n        delay: '7d',\n      },\n    ],\n\n    // Scheduled proactive tasks\n    scheduled: [\n      {\n        cron: '0 9 * * MON',\n        action: 'weekly-summary',\n        recipients: ['team@company.com'],\n      },\n    ],\n  },\n})\n```\n\n## Autonomy Levels\n\n```typescript\n// Configure autonomy level\nconst agent = agent({\n  autonomyLevel: 'supervised',  // 'manual' | 'supervised' | 'autonomous'\n})\n\n// Manual: Human approves every action\n// Supervised: Agent acts, human reviews\n// Autonomous: Agent acts independently\n\n// Adjust dynamically\nawait agent.setAutonomyLevel('autonomous', {\n  for: ['answer-common-questions'],\n  because: 'High accuracy demonstrated over 1000 interactions',\n})\n```\n\n## Audit Trail\n\n```typescript\n// All autonomous actions logged\nconst auditLog = await agent.getAuditLog({\n  since: lastMonth,\n  actions: ['decision', 'execution', 'escalation'],\n})\n\n// Each entry includes\nauditLog.forEach((entry) => {\n  console.log(entry.timestamp)\n  console.log(entry.action)\n  console.log(entry.context)\n  console.log(entry.outcome)\n  console.log(entry.reasoning)\n})\n```\n\n## Best Practices\n\n1. **Start supervised** - Build trust before full autonomy\n2. **Clear escalation paths** - Always have human fallback\n3. **Log everything** - Maintain audit trail\n4. **Learn from outcomes** - Use feedback to improve\n5. **Set appropriate limits** - Prevent runaway actions\n6. **Regular review** - Audit agent decisions periodically\n\n\n# Guardrails\n\nURL: https://primitives.org.ai/agent/guardrails\n\n> Safety boundaries and operational limits\n\n\n\n# Agent Guardrails\n\nGuardrails define the boundaries within which agents operate, ensuring safe, predictable, and compliant behavior.\n\n## Guardrails Configuration\n\n```typescript\nimport { agent } from 'autonomous-agents'\n\nconst agent = agent({\n  name: 'safe-agent',\n\n  guardrails: {\n    // Rate limits\n    maxActionsPerHour: 100,\n    maxActionsPerDay: 1000,\n\n    // Content policies\n    neverMention: ['competitor-names', 'internal-financials'],\n    alwaysInclude: ['disclaimer-for-legal-advice'],\n\n    // Approval requirements\n    requireApprovalFor: [\n      { action: 'send-email', when: 'external-recipient' },\n      { action: 'create-ticket', when: 'priority = critical' },\n      { action: 'modify-data', when: 'production-environment' },\n    ],\n  },\n})\n```\n\n## Rate Limiting\n\n### Action Limits\n\n```typescript\nconst guardrails = {\n  limits: {\n    // Overall limits\n    maxActionsPerMinute: 10,\n    maxActionsPerHour: 100,\n    maxActionsPerDay: 1000,\n\n    // Per-action limits\n    actions: {\n      'send-email': { perHour: 20, perDay: 100 },\n      'create-ticket': { perHour: 50, perDay: 500 },\n      'api-call': { perMinute: 60 },\n    },\n\n    // Per-recipient limits\n    perRecipient: {\n      email: { perDay: 5 },\n      slack: { perHour: 10 },\n    },\n  },\n}\n\n// Check before action\nconst canProceed = await agent.checkLimit('send-email')\nif (!canProceed) {\n  await agent.waitOrEscalate()\n}\n```\n\n### Spending Limits\n\n```typescript\nconst guardrails = {\n  spending: {\n    // Monetary limits\n    maxRefundAmount: 100,\n    maxRefundsPerDay: 500,\n    maxPurchaseAmount: 50,\n\n    // Resource limits\n    maxApiCosts: { perDay: 100, perMonth: 2000 },\n    maxComputeMinutes: { perDay: 60 },\n  },\n}\n```\n\n## Content Policies\n\n### Prohibited Content\n\n```typescript\nconst guardrails = {\n  content: {\n    // Never include\n    prohibited: [\n      'competitor-names',\n      'internal-financials',\n      'employee-salaries',\n      'unreleased-products',\n      'personal-opinions',\n    ],\n\n    // Topics to avoid\n    avoidTopics: ['politics', 'religion', 'controversial-subjects'],\n\n    // Patterns to block\n    blockedPatterns: [\n      /\\b(password|secret|api.?key)\\s*[:=]/i,\n      /\\b\\d{3}-\\d{2}-\\d{4}\\b/,  // SSN pattern\n    ],\n  },\n}\n\n// Check content before sending\nconst safe = await agent.checkContent(message)\nif (!safe) {\n  message = await agent.sanitize(message)\n}\n```\n\n### Required Content\n\n```typescript\nconst guardrails = {\n  content: {\n    // Always include when relevant\n    required: {\n      'legal-topics': 'This is not legal advice. Please consult a lawyer.',\n      'medical-topics': 'This is not medical advice. Please consult a doctor.',\n      'financial-topics': 'Past performance does not guarantee future results.',\n    },\n\n    // Signatures\n    signature: {\n      email: '- Your AI Assistant\\nThis message was generated by AI.',\n      chat: 'ðŸ¤– AI Assistant',\n    },\n  },\n}\n```\n\n## Approval Requirements\n\n```typescript\nconst guardrails = {\n  approvals: {\n    // Actions requiring approval\n    required: [\n      {\n        action: 'send-external-email',\n        approver: 'communications-team',\n        timeout: '4h',\n      },\n      {\n        action: 'modify-production-data',\n        approver: 'engineering-lead',\n        timeout: '1h',\n      },\n      {\n        action: 'large-refund',\n        condition: 'amount > 500',\n        approver: 'finance-team',\n        timeout: '24h',\n      },\n    ],\n\n    // What to do if approval times out\n    onTimeout: 'escalate',  // 'escalate' | 'deny' | 'auto-approve'\n  },\n}\n\n// Request approval\nconst approval = await agent.requestApproval({\n  action: 'send-external-email',\n  details: emailDraft,\n  reason: 'Customer follow-up',\n})\n\nif (approval.granted) {\n  await agent.execute(action)\n}\n```\n\n## Time Restrictions\n\n```typescript\nconst guardrails = {\n  schedule: {\n    // Active hours\n    activeHours: {\n      start: '09:00',\n      end: '18:00',\n      timezone: 'America/New_York',\n    },\n\n    // Days of operation\n    activeDays: ['monday', 'tuesday', 'wednesday', 'thursday', 'friday'],\n\n    // Blackout periods\n    blackouts: [\n      { name: 'holidays', dates: ['2024-12-25', '2024-01-01'] },\n      { name: 'maintenance', schedule: 'sunday 02:00-06:00' },\n    ],\n\n    // What to do outside hours\n    outsideHours: {\n      action: 'queue',  // 'queue' | 'reject' | 'emergency-only'\n      message: 'I am currently offline. Your request will be handled tomorrow.',\n    },\n  },\n}\n```\n\n## Access Control\n\n```typescript\nconst guardrails = {\n  access: {\n    // Data access restrictions\n    data: {\n      canRead: ['public-docs', 'team-resources'],\n      cannotRead: ['hr-records', 'financial-data', 'legal-documents'],\n    },\n\n    // System access\n    systems: {\n      allowed: ['ticketing', 'documentation', 'calendar'],\n      denied: ['billing', 'admin-panel', 'production-db'],\n    },\n\n    // User data\n    userData: {\n      canAccess: ['name', 'email', 'preferences'],\n      cannotAccess: ['ssn', 'payment-info', 'medical-records'],\n    },\n  },\n}\n```\n\n## Output Validation\n\n```typescript\nconst guardrails = {\n  validation: {\n    // Validate all outputs\n    outputs: [\n      {\n        type: 'email',\n        validators: ['no-pii', 'tone-check', 'brand-voice'],\n      },\n      {\n        type: 'code',\n        validators: ['security-scan', 'license-check'],\n      },\n      {\n        type: 'customer-response',\n        validators: ['sentiment', 'accuracy', 'completeness'],\n      },\n    ],\n\n    // On validation failure\n    onFailure: 'block-and-alert',  // 'block' | 'warn' | 'block-and-alert'\n  },\n}\n\n// Validate before sending\nconst validation = await agent.validate(output)\nif (!validation.passed) {\n  await agent.alert('validation-failed', validation.issues)\n}\n```\n\n## Escalation Rules\n\n```typescript\nconst guardrails = {\n  escalation: {\n    // Automatic escalation triggers\n    triggers: [\n      { condition: 'confidence < 0.5', to: 'senior-support' },\n      { condition: 'customer.sentiment = very-negative', to: 'manager' },\n      { condition: 'topic matches legal|lawsuit|attorney', to: 'legal-team' },\n      { condition: 'error-rate > 0.1', to: 'engineering' },\n    ],\n\n    // Escalation path\n    path: ['tier-1', 'tier-2', 'manager', 'director'],\n\n    // Maximum attempts before escalation\n    maxAttempts: 3,\n  },\n}\n```\n\n## Audit and Compliance\n\n```typescript\nconst guardrails = {\n  audit: {\n    // Log all actions\n    logAll: true,\n\n    // Detailed logging for sensitive actions\n    detailed: ['modify-data', 'send-external', 'access-pii'],\n\n    // Retention\n    retention: '7y',  // 7 years for compliance\n\n    // Required fields in logs\n    requiredFields: ['timestamp', 'action', 'actor', 'target', 'outcome'],\n  },\n\n  compliance: {\n    // Regulatory frameworks\n    frameworks: ['SOC2', 'GDPR', 'HIPAA'],\n\n    // Data residency\n    dataResidency: 'US',\n\n    // Encryption requirements\n    encryption: {\n      atRest: true,\n      inTransit: true,\n      keyRotation: '90d',\n    },\n  },\n}\n```\n\n## Emergency Controls\n\n```typescript\n// Emergency stop\nawait agent.emergencyStop({\n  reason: 'Detected anomalous behavior',\n  preserveState: true,\n})\n\n// Pause agent\nawait agent.pause({\n  duration: '1h',\n  reason: 'Investigating reported issue',\n})\n\n// Resume with restrictions\nawait agent.resume({\n  restrictions: ['read-only', 'no-external-communication'],\n})\n\n// Kill switch\nagent.onKillSwitch(async () => {\n  await agent.gracefulShutdown()\n  await agent.notifyAdmins('Kill switch activated')\n})\n```\n\n## Monitoring and Alerts\n\n```typescript\nconst guardrails = {\n  monitoring: {\n    // Metrics to track\n    metrics: ['action-rate', 'error-rate', 'response-time', 'escalation-rate'],\n\n    // Alert thresholds\n    alerts: [\n      { metric: 'error-rate', threshold: 0.05, action: 'alert' },\n      { metric: 'error-rate', threshold: 0.1, action: 'pause' },\n      { metric: 'action-rate', threshold: 200, action: 'throttle' },\n    ],\n\n    // Alert destinations\n    alertTo: ['ops-team@company.com', '#agent-alerts'],\n  },\n}\n```\n\n## Best Practices\n\n1. **Defense in depth** - Multiple layers of guardrails\n2. **Start restrictive** - Loosen limits as trust builds\n3. **Clear escalation** - Always have human fallback\n4. **Comprehensive logging** - Audit all actions\n5. **Regular review** - Adjust guardrails based on incidents\n6. **Emergency controls** - Always have a kill switch\n\n\n# Identity\n\nURL: https://primitives.org.ai/agent/identity\n\n> Real presence in organizational systems\n\n\n\n# Agent Identity\n\nAgents exist as first-class entities in your organization with real identity across communication systems, enabling natural integration with existing workflows.\n\n## Identity Configuration\n\n```typescript\nimport { agent } from 'autonomous-agents'\n\nconst supportAgent = agent({\n  name: 'support-agent',\n\n  identity: {\n    displayName: 'Support Assistant',\n    email: 'support-agent@company.com',\n    slack: '@support-agent',\n    phone: '+1-555-SUPPORT',\n    calendar: 'support-agent@company.com',\n    avatar: 'https://cdn.company.com/agents/support.png',\n  },\n})\n```\n\n## Email Integration\n\nAgents can send, receive, and respond to email:\n\n```typescript\n// Handle incoming email\nagent.onEmail(async (email) => {\n  // Access email properties\n  console.log(email.from)      // sender address\n  console.log(email.subject)   // email subject\n  console.log(email.body)      // email content\n  console.log(email.attachments) // array of attachments\n\n  // Process and respond\n  const response = await agent.think(email.body)\n  await agent.reply(email, response)\n})\n\n// Send email proactively\nawait agent.email.send({\n  to: 'customer@example.com',\n  cc: ['manager@company.com'],\n  subject: 'Follow-up on your request',\n  body: 'Thank you for contacting us...',\n  attachments: [{ name: 'report.pdf', content: reportBuffer }],\n})\n```\n\n### Email Routing\n\n```typescript\nagent.onEmail(async (email) => {\n  // Route based on content\n  if (email.subject.includes('urgent')) {\n    await agent.email.forward(email, 'urgent-team@company.com')\n    return\n  }\n\n  if (email.hasAttachment('invoice')) {\n    await agent.capabilities.processInvoice(email.attachments)\n    return\n  }\n\n  // Default handling\n  await agent.capabilities.handleSupport(email)\n})\n```\n\n## Slack Integration\n\nFull presence in Slack workspaces:\n\n```typescript\n// Join channels\nawait agent.slack.join(['#support', '#general', '#dev-questions'])\n\n// Listen for mentions\nagent.slack.onMention(async (message) => {\n  const response = await agent.think(message.text)\n  await agent.slack.reply(message, response)\n})\n\n// Listen for direct messages\nagent.slack.onDM(async (message) => {\n  const response = await agent.think(message.text)\n  await agent.slack.reply(message, response)\n})\n\n// React to messages\nagent.slack.onMessage(async (message) => {\n  if (message.text.includes('thank')) {\n    await agent.slack.react(message, ':heart:')\n  }\n})\n```\n\n### Slack Actions\n\n```typescript\n// Send message to channel\nawait agent.slack.send('#support', 'Daily metrics report ready!')\n\n// Send with rich formatting\nawait agent.slack.send('#support', {\n  blocks: [\n    {\n      type: 'section',\n      text: { type: 'mrkdwn', text: '*Daily Report*' },\n    },\n    {\n      type: 'section',\n      fields: [\n        { type: 'mrkdwn', text: '*Tickets Resolved:* 42' },\n        { type: 'mrkdwn', text: '*Avg Response Time:* 5m' },\n      ],\n    },\n  ],\n})\n\n// Start thread\nconst thread = await agent.slack.startThread('#support', 'Starting investigation...')\nawait agent.slack.reply(thread, 'Found the issue!')\nawait agent.slack.reply(thread, 'Resolution applied.')\n```\n\n## Calendar Integration\n\nManage time and scheduling:\n\n```typescript\n// Create meetings\nawait agent.calendar.createMeeting({\n  title: 'SDK Office Hours',\n  description: 'Weekly Q&A session',\n  attendees: ['team@company.com'],\n  recurrence: 'weekly',\n  day: 'wednesday',\n  time: '14:00',\n  duration: '1h',\n  conferenceLink: true,\n})\n\n// Check availability\nconst available = await agent.calendar.isAvailable({\n  start: new Date('2024-01-15T10:00:00'),\n  end: new Date('2024-01-15T11:00:00'),\n})\n\n// Find meeting time\nconst slot = await agent.calendar.findTime({\n  participants: ['alice@company.com', 'bob@company.com'],\n  duration: '30m',\n  within: '7d',\n})\n\n// Accept/decline invites\nagent.calendar.onInvite(async (invite) => {\n  if (await agent.shouldAttend(invite)) {\n    await invite.accept()\n  } else {\n    await invite.decline('Scheduling conflict')\n  }\n})\n```\n\n## Phone/SMS Integration\n\nVoice and text communication:\n\n```typescript\n// Handle incoming calls\nagent.phone.onCall(async (call) => {\n  await call.answer()\n  await call.say('Hello, this is the support assistant.')\n\n  const transcript = await call.listen()\n  const response = await agent.think(transcript)\n\n  await call.say(response)\n  await call.end()\n})\n\n// Send SMS\nawait agent.sms.send('+15551234567', 'Your verification code is 123456')\n\n// Handle incoming SMS\nagent.sms.onMessage(async (message) => {\n  const response = await agent.think(message.text)\n  await agent.sms.reply(message, response)\n})\n```\n\n## Webhook Integrations\n\nConnect to external services:\n\n```typescript\n// GitHub webhooks\nagent.webhook.on('github', async (event) => {\n  if (event.type === 'pull_request' && event.action === 'opened') {\n    await agent.capabilities.reviewPullRequest(event.payload)\n  }\n})\n\n// JIRA webhooks\nagent.webhook.on('jira', async (event) => {\n  if (event.type === 'issue_created') {\n    await agent.capabilities.triageIssue(event.payload)\n  }\n})\n\n// Generic webhooks\nagent.webhook.on('custom', async (payload) => {\n  await agent.process(payload)\n})\n```\n\n## Status and Presence\n\n```typescript\n// Set agent status\nawait agent.setStatus({\n  state: 'active',        // 'active' | 'busy' | 'away' | 'offline'\n  message: 'Handling support requests',\n  emoji: ':robot_face:',\n})\n\n// Schedule status changes\nawait agent.scheduleStatus({\n  state: 'away',\n  message: 'Off for maintenance',\n  start: new Date('2024-01-20T00:00:00'),\n  end: new Date('2024-01-20T06:00:00'),\n})\n\n// Respond based on status\nagent.onMessage(async (message) => {\n  if (agent.status.state === 'away') {\n    await message.reply('I am currently away. I will respond when I return.')\n    return\n  }\n  // Normal processing\n})\n```\n\n## Identity Verification\n\n```typescript\nconst agent = agent({\n  identity: {\n    email: 'agent@company.com',\n    verification: {\n      dkim: true,          // Sign outgoing emails\n      spf: true,           // Include in SPF records\n      signature: true,     // Add digital signature\n    },\n  },\n})\n\n// Verify incoming messages\nagent.onMessage(async (message) => {\n  const verified = await agent.verifyIdentity(message.from)\n  if (!verified) {\n    await message.reply('Unable to verify your identity.')\n    return\n  }\n  // Process verified message\n})\n```\n\n## Multi-Channel Coordination\n\n```typescript\n// Coordinate across channels\nconst conversation = await agent.startConversation({\n  user: 'alice@company.com',\n  topic: 'Support request #123',\n})\n\n// Continue conversation across channels\nawait conversation.send('I am looking into this now.', { via: 'email' })\nawait conversation.send('Quick update: found the issue!', { via: 'slack' })\nawait conversation.send('Resolution applied. Please verify.', { via: 'email' })\n\n// Full conversation history available\nconsole.log(conversation.messages)\n```\n\n## Best Practices\n\n1. **Use consistent identity** - Same name/avatar across channels\n2. **Set appropriate presence** - Update status for maintenance\n3. **Verify incoming messages** - Prevent impersonation\n4. **Coordinate channels** - Track conversations across mediums\n5. **Respect rate limits** - Don't spam users across channels\n\n\n# Agent\n\nURL: https://primitives.org.ai/agent\n\n> Truly autonomous entities with real identity, long-term memory, and presence in your organization\n\n\n\nUnlike simple chatbots or task runners, Agents have real identity, persistent memory, and the ability to work independently over extended time horizons.\n\n## What Makes an Agent\n\nAn Agent is more than an AI model wrapped in an API. It's an entity with:\n\n* **Identity**: Email, phone, Slack, calendarâ€”real presence in organizational systems\n* **Memory**: Persistent context that grows and evolves over time\n* **Autonomy**: Ability to work independently, making decisions and taking actions\n* **Relationships**: Understanding of team structure, preferences, and history\n* **Accountability**: Clear ownership of tasks with escalation paths\n\n```typescript\nimport { agent, capability } from 'autonomous-agents'\n\nconst sdkExpert = agent({\n  name: 'sdk-expert',\n\n  identity: {\n    displayName: 'SDK Expert',\n    email: 'sdk-expert@company.com',\n    slack: '@sdk-expert',\n    calendar: 'sdk-expert@company.com',\n  },\n\n  personality: {\n    role: 'Senior developer advocate specializing in SDK design',\n    traits: ['helpful', 'thorough', 'technically precise'],\n    communication: 'Clear and educational, with code examples',\n  },\n\n  capabilities: [\n    answerSDKQuestions,\n    reviewPullRequests,\n    writeDocumentation,\n    triageIssues,\n  ],\n\n  memory: {\n    type: 'persistent',\n    includes: ['conversations', 'preferences', 'codebase-knowledge'],\n  },\n})\n```\n\n## Real Identity\n\nAgents exist in your organization's systems as first-class entities:\n\n```typescript\n// Agent receives email\nconst emailHandler = agent.onEmail(async (email) => {\n  if (email.subject.includes('SDK question')) {\n    const response = await agent.capabilities.answerSDKQuestions({\n      question: email.body,\n      context: await agent.memory.getConversation(email.from),\n    })\n    await agent.reply(email, response)\n  }\n})\n\n// Agent joins Slack channels\nawait agent.slack.join(['#sdk-support', '#developer-questions'])\n\n// Agent responds to mentions\nagent.slack.onMention(async (message) => {\n  const response = await agent.think(message.text)\n  await agent.slack.reply(message, response)\n})\n\n// Agent has calendar for scheduling\nawait agent.calendar.createMeeting({\n  title: 'SDK Office Hours',\n  recurrence: 'weekly',\n  duration: '1h',\n})\n```\n\n## Long-Term Memory\n\nAgents build knowledge over time:\n\n```typescript\nconst memory = agent.memory\n\n// Remember facts about users\nawait memory.remember({\n  type: 'user-preference',\n  user: 'alice@company.com',\n  fact: 'Prefers TypeScript examples over JavaScript',\n  confidence: 0.95,\n})\n\n// Store learned information\nawait memory.learn({\n  type: 'codebase-pattern',\n  pattern: 'Error handling uses Result type, not exceptions',\n  source: 'code-review-feedback',\n})\n\n// Recall relevant context\nconst context = await memory.recall({\n  query: 'How does Alice prefer to receive code examples?',\n  types: ['user-preference', 'conversation-history'],\n  limit: 10,\n})\n```\n\n### Memory Types\n\n* **Episodic**: Specific interactions and events\n* **Semantic**: Learned facts and knowledge\n* **Procedural**: How to perform tasks\n* **Working**: Current task context\n\n## True Autonomy\n\nAgents work independently, making decisions without constant supervision:\n\n```typescript\nconst autonomousAgent = agent({\n  name: 'support-agent',\n\n  autonomy: {\n    // What the agent can do without asking\n    canDo: [\n      'answer-common-questions',\n      'look-up-documentation',\n      'create-tickets',\n    ],\n\n    // When to escalate to humans\n    escalateTo: 'support-team',\n    escalateWhen: [\n      'confidence < 0.7',\n      'customer-sentiment = angry',\n      'topic = billing',\n      'request = refund > $100',\n    ],\n\n    // Learning from feedback\n    learnFrom: ['human-corrections', 'outcome-feedback'],\n  },\n})\n```\n\n### Decision Making\n\n```typescript\n// Agent decides how to handle a request\nconst decision = await agent.decide({\n  situation: 'Customer asking about enterprise pricing',\n  options: [\n    { action: 'answer-directly', confidence: 0.3 },\n    { action: 'escalate-to-sales', confidence: 0.9 },\n    { action: 'schedule-call', confidence: 0.7 },\n  ],\n})\n\n// Agent takes action based on decision\nawait agent.execute(decision.chosen)\n```\n\n## Working with Teams\n\nAgents understand organizational structure:\n\n```typescript\nconst agent = agent({\n  name: 'project-coordinator',\n\n  team: {\n    reports_to: 'engineering-manager',\n    collaborates_with: ['frontend-team', 'backend-team', 'design-team'],\n    can_assign_to: ['junior-developers'],\n  },\n\n  workflows: [\n    dailyStandup,\n    sprintPlanning,\n    codeReviewAssignment,\n  ],\n})\n\n// Agent coordinates work across team\nawait agent.coordinate({\n  task: 'Implement new auth flow',\n  assignees: await agent.findBestMatch({\n    skills: ['react', 'oauth'],\n    availability: 'this-sprint',\n  }),\n})\n```\n\n## Agent Lifecycle\n\n```typescript\n// Create and deploy agent\nconst myAgent = await agent.deploy()\n\n// Agent is now active and responding\nconsole.log(myAgent.status) // 'active'\n\n// Monitor agent activity\nmyAgent.on('action', (action) => {\n  console.log(`Agent performed: ${action.type}`)\n})\n\n// Review agent decisions\nconst decisions = await myAgent.getDecisionLog({\n  since: lastWeek,\n  includeReasoning: true,\n})\n\n// Provide feedback\nawait myAgent.feedback({\n  decisionId: 'dec_abc123',\n  outcome: 'incorrect',\n  correction: 'Should have escalated this billing question',\n})\n\n// Agent learns from feedback\nawait myAgent.learn()\n```\n\n## Guardrails\n\nAgents operate within defined boundaries:\n\n```typescript\nconst agent = agent({\n  name: 'secure-agent',\n\n  guardrails: {\n    // Rate limits\n    maxActionsPerHour: 100,\n    maxEmailsPerDay: 50,\n\n    // Content policies\n    neverMention: ['competitor-names', 'internal-financials'],\n    alwaysInclude: ['disclaimer-for-legal-advice'],\n\n    // Approval requirements\n    requireApprovalFor: [\n      { action: 'send-email', when: 'external-recipient' },\n      { action: 'create-ticket', when: 'priority = critical' },\n    ],\n  },\n})\n```\n\n\n# Memory\n\nURL: https://primitives.org.ai/agent/memory\n\n> Long-term learning and context retention\n\n\n\n# Agent Memory\n\nAgents build knowledge over time through persistent memory systems that enable learning, personalization, and contextual understanding.\n\n## Memory Overview\n\n```typescript\nimport { agent } from 'autonomous-agents'\n\nconst agent = agent({\n  name: 'knowledgeable-agent',\n\n  memory: {\n    type: 'persistent',\n    includes: [\n      'conversations',\n      'preferences',\n      'learned-facts',\n      'codebase-knowledge',\n    ],\n    retention: {\n      conversations: '90d',\n      preferences: 'forever',\n      learned: 'forever',\n    },\n  },\n})\n```\n\n## Memory Types\n\n### Episodic Memory\n\nSpecific interactions and events:\n\n```typescript\n// Store conversation history\nawait memory.storeEpisode({\n  type: 'conversation',\n  participants: ['alice@company.com', agent.id],\n  content: messages,\n  timestamp: new Date(),\n  metadata: {\n    topic: 'SDK integration question',\n    sentiment: 'positive',\n    resolved: true,\n  },\n})\n\n// Recall past conversations\nconst history = await memory.recallEpisodes({\n  participant: 'alice@company.com',\n  limit: 10,\n  since: lastMonth,\n})\n```\n\n### Semantic Memory\n\nLearned facts and knowledge:\n\n```typescript\n// Learn a fact\nawait memory.learn({\n  type: 'user-preference',\n  subject: 'alice@company.com',\n  fact: 'Prefers TypeScript examples over JavaScript',\n  confidence: 0.95,\n  source: 'explicit-statement',\n})\n\n// Learn from observation\nawait memory.learn({\n  type: 'pattern',\n  fact: 'Support tickets spike on Mondays after deployments',\n  confidence: 0.8,\n  source: 'data-analysis',\n  evidence: ticketData,\n})\n\n// Recall facts\nconst preferences = await memory.recall({\n  subject: 'alice@company.com',\n  type: 'user-preference',\n})\n```\n\n### Procedural Memory\n\nHow to perform tasks:\n\n```typescript\n// Store procedure\nawait memory.learnProcedure({\n  name: 'handle-billing-dispute',\n  steps: [\n    'Verify customer identity',\n    'Check transaction history',\n    'Review dispute reason',\n    'Escalate to billing team if > $100',\n    'Otherwise, process refund directly',\n  ],\n  learnedFrom: 'human-demonstration',\n})\n\n// Execute learned procedure\nconst procedure = await memory.getProcedure('handle-billing-dispute')\nawait agent.execute(procedure.steps)\n```\n\n### Working Memory\n\nCurrent task context:\n\n```typescript\n// Set current context\nawait memory.setContext({\n  currentTask: 'Investigating issue #456',\n  relevantFacts: await memory.recall({ related: 'issue-456' }),\n  recentActions: actionLog,\n})\n\n// Access context during task\nconst context = await memory.getContext()\nconsole.log(context.currentTask)\n\n// Clear when task complete\nawait memory.clearContext()\n```\n\n## Remember and Recall\n\n### Remember Facts\n\n```typescript\n// Remember simple fact\nawait memory.remember('alice prefers email over Slack')\n\n// Remember structured fact\nawait memory.remember({\n  type: 'user-preference',\n  user: 'alice@company.com',\n  key: 'communication-channel',\n  value: 'email',\n  confidence: 0.95,\n})\n\n// Remember with expiration\nawait memory.remember({\n  fact: 'Maintenance window is tonight 2-4am',\n  expires: new Date('2024-01-16T04:00:00'),\n})\n```\n\n### Recall Information\n\n```typescript\n// Simple recall\nconst fact = await memory.recall('What language does Alice prefer?')\n\n// Structured recall\nconst preferences = await memory.recall({\n  query: 'user preferences',\n  user: 'alice@company.com',\n  types: ['user-preference'],\n  limit: 10,\n})\n\n// Semantic search\nconst relevant = await memory.recall({\n  query: 'authentication errors',\n  similarity: 0.8,\n  limit: 5,\n})\n```\n\n## Learning\n\n### Learn from Interactions\n\n```typescript\n// Agent automatically learns from conversations\nagent.onConversation(async (conversation) => {\n  // Extract learnable facts\n  const facts = await agent.extractFacts(conversation)\n\n  for (const fact of facts) {\n    await memory.learn({\n      ...fact,\n      source: 'conversation',\n      confidence: fact.explicit ? 0.95 : 0.7,\n    })\n  }\n})\n```\n\n### Learn from Feedback\n\n```typescript\n// Learn from corrections\nagent.onFeedback(async (feedback) => {\n  if (feedback.type === 'correction') {\n    // Update existing knowledge\n    await memory.update({\n      original: feedback.original,\n      corrected: feedback.correction,\n      source: 'human-feedback',\n    })\n  }\n\n  if (feedback.type === 'positive') {\n    // Reinforce correct behavior\n    await memory.reinforce(feedback.actionId)\n  }\n})\n```\n\n### Learn from Observation\n\n```typescript\n// Learn patterns from data\nawait memory.analyzeAndLearn({\n  data: supportTickets,\n  lookFor: ['patterns', 'anomalies', 'correlations'],\n  minConfidence: 0.7,\n})\n\n// Result: learned facts like\n// - \"Tickets about 'login' increase after password policy changes\"\n// - \"User 'bob' typically has complex technical questions\"\n```\n\n## Memory Search\n\n### Semantic Search\n\n```typescript\n// Find related memories by meaning\nconst results = await memory.search({\n  query: 'How to handle authentication errors',\n  type: 'semantic',\n  limit: 10,\n})\n\n// Results ranked by relevance\nresults.forEach((result) => {\n  console.log(result.content, result.similarity)\n})\n```\n\n### Filtered Search\n\n```typescript\n// Search with filters\nconst results = await memory.search({\n  query: 'deployment issues',\n  filters: {\n    type: ['incident', 'resolution'],\n    timeRange: { start: lastMonth, end: now },\n    confidence: { min: 0.7 },\n  },\n})\n```\n\n## Memory Consolidation\n\n```typescript\n// Periodically consolidate memories\nawait memory.consolidate({\n  // Merge similar facts\n  deduplication: true,\n\n  // Decay old, unused memories\n  decay: {\n    enabled: true,\n    threshold: '180d',\n    keepHighConfidence: true,\n  },\n\n  // Summarize episodic memories\n  summarize: {\n    enabled: true,\n    olderThan: '30d',\n  },\n})\n```\n\n## Memory Namespaces\n\n```typescript\n// Organize memories by namespace\nconst projectMemory = memory.namespace('project-alpha')\nconst userMemory = memory.namespace('users')\n\nawait projectMemory.remember('Deadline is March 15')\nawait userMemory.remember({ user: 'alice', fact: 'Prefers email' })\n\n// Query within namespace\nconst projectFacts = await projectMemory.recall('deadline')\n```\n\n## Shared Memory\n\n```typescript\n// Share memories between agents\nconst sharedMemory = createSharedMemory({\n  name: 'team-knowledge',\n  agents: [agent1, agent2, agent3],\n})\n\n// Agent 1 learns something\nawait agent1.memory.share(sharedMemory, {\n  fact: 'Customer X prefers morning calls',\n})\n\n// Agent 2 can access it\nconst fact = await agent2.memory.fromShared(sharedMemory, {\n  query: 'Customer X preferences',\n})\n```\n\n## Memory Export/Import\n\n```typescript\n// Export memories\nconst exported = await memory.export({\n  types: ['user-preference', 'learned-fact'],\n  format: 'json',\n})\n\n// Import memories\nawait memory.import(exported, {\n  conflictResolution: 'merge', // 'replace' | 'merge' | 'skip'\n})\n```\n\n## Privacy and Retention\n\n```typescript\nconst memory = agent.memory.configure({\n  retention: {\n    conversations: '90d',    // Delete after 90 days\n    preferences: 'forever',   // Keep indefinitely\n    pii: '30d',              // Personal info deleted after 30 days\n  },\n\n  privacy: {\n    anonymize: ['email', 'phone'],  // Anonymize in storage\n    encrypt: true,                   // Encrypt at rest\n    audit: true,                     // Log all access\n  },\n})\n\n// Forget specific information\nawait memory.forget({\n  user: 'alice@company.com',\n  types: ['conversation', 'preference'],\n})\n```\n\n## Best Practices\n\n1. **Set appropriate retention** - Don't keep data longer than needed\n2. **Use confidence scores** - Track certainty of learned facts\n3. **Regular consolidation** - Prevent memory bloat\n4. **Namespace organization** - Keep memories organized\n5. **Privacy compliance** - Handle PII appropriately\n6. **Source attribution** - Track where knowledge came from\n\n\n# Teams\n\nURL: https://primitives.org.ai/agent/teams\n\n> Agent collaboration and organizational integration\n\n\n\n# Working with Teams\n\nAgents understand organizational structure and collaborate effectively with humans and other agents as team members.\n\n## Team Configuration\n\n```typescript\nimport { agent } from 'autonomous-agents'\n\nconst agent = agent({\n  name: 'project-coordinator',\n\n  team: {\n    reports_to: 'engineering-manager',\n    collaborates_with: ['frontend-team', 'backend-team', 'design-team'],\n    can_assign_to: ['junior-developers', 'contractors'],\n    member_of: ['engineering', 'product'],\n  },\n})\n```\n\n## Organizational Context\n\n```typescript\n// Agent understands org structure\nconst org = await agent.organization.get()\n\nconsole.log(org.teams)\n// [\n//   { name: 'engineering', members: [...], lead: 'alice' },\n//   { name: 'product', members: [...], lead: 'bob' },\n// ]\n\n// Find people by role\nconst designers = await agent.organization.findByRole('designer')\nconst managers = await agent.organization.findByRole('manager')\n\n// Get team for a person\nconst team = await agent.organization.getTeamFor('alice@company.com')\n```\n\n## Collaboration Patterns\n\n### Task Assignment\n\n```typescript\n// Agent assigns work to team members\nawait agent.assign({\n  task: 'Review pull request #456',\n  to: await agent.findBestMatch({\n    skills: ['react', 'typescript'],\n    availability: 'today',\n    workload: 'low',\n  }),\n  priority: 'high',\n  deadline: tomorrow,\n})\n\n// Bulk assignment\nawait agent.distribute({\n  tasks: unassignedTasks,\n  among: 'frontend-team',\n  strategy: 'balanced',  // 'balanced' | 'expertise' | 'availability'\n})\n```\n\n### Coordination\n\n```typescript\n// Coordinate across teams\nawait agent.coordinate({\n  objective: 'Launch new feature',\n  teams: ['frontend', 'backend', 'qa'],\n\n  plan: [\n    { team: 'backend', task: 'Implement API', by: 'Jan 15' },\n    { team: 'frontend', task: 'Build UI', by: 'Jan 20' },\n    { team: 'qa', task: 'Test integration', by: 'Jan 25' },\n  ],\n\n  checkpoints: ['daily-standup', 'weekly-review'],\n})\n\n// Track coordination progress\nconst status = await agent.getCoordinationStatus('launch-feature')\nconsole.log(status.tasksCompleted)\nconsole.log(status.blockers)\nconsole.log(status.nextMilestone)\n```\n\n### Handoffs\n\n```typescript\n// Hand off work to another agent or human\nawait agent.handoff({\n  to: 'senior-support',\n  context: {\n    conversation: currentConversation,\n    summary: 'Customer needs billing adjustment > $500',\n    attempted: ['verified account', 'checked history'],\n    recommendation: 'Approve the adjustment',\n  },\n})\n\n// Receive handoffs\nagent.onHandoff(async (handoff) => {\n  await agent.memory.setContext(handoff.context)\n  await agent.continue(handoff.conversation)\n})\n```\n\n## Agent-to-Agent Communication\n\n### Direct Messaging\n\n```typescript\n// Send message to another agent\nawait agent.message('analytics-agent', {\n  type: 'request',\n  content: 'Generate weekly report for project Alpha',\n  priority: 'normal',\n  expectResponse: true,\n})\n\n// Receive messages from agents\nagent.onMessage(async (message) => {\n  if (message.from.type === 'agent') {\n    const response = await agent.process(message)\n    await agent.reply(message, response)\n  }\n})\n```\n\n### Broadcasting\n\n```typescript\n// Broadcast to multiple agents\nawait agent.broadcast({\n  to: ['support-agent', 'sales-agent', 'analytics-agent'],\n  message: 'System maintenance scheduled for tonight',\n  priority: 'high',\n})\n\n// Subscribe to broadcasts\nagent.onBroadcast(async (broadcast) => {\n  if (broadcast.topic === 'system-status') {\n    await agent.updateStatus(broadcast.content)\n  }\n})\n```\n\n### Agent Teams\n\n```typescript\nimport { createAgentTeam } from 'autonomous-agents'\n\n// Create team of agents\nconst supportTeam = createAgentTeam({\n  name: 'support-agents',\n  members: [tier1Agent, tier2Agent, escalationAgent],\n\n  routing: {\n    // Route incoming requests to appropriate agent\n    strategy: 'skill-based',\n    rules: [\n      { condition: 'topic = billing', assign: 'tier2Agent' },\n      { condition: 'priority = critical', assign: 'escalationAgent' },\n      { default: 'tier1Agent' },\n    ],\n  },\n\n  coordination: {\n    // How agents coordinate\n    handoffProtocol: 'context-aware',\n    loadBalancing: true,\n    failover: true,\n  },\n})\n\n// Team handles requests as a unit\nawait supportTeam.handle(incomingRequest)\n```\n\n## Human Collaboration\n\n### Working with Humans\n\n```typescript\n// Request human input\nconst input = await agent.requestHumanInput({\n  from: 'alice@company.com',\n  question: 'Should we proceed with the refund?',\n  options: ['approve', 'deny', 'need-more-info'],\n  context: refundRequest,\n  deadline: '4h',\n})\n\n// Notify humans of status\nawait agent.notify({\n  to: 'team@company.com',\n  message: 'Sprint tasks have been assigned',\n  channel: 'slack',\n})\n\n// Schedule human review\nawait agent.scheduleReview({\n  what: 'Weekly agent performance',\n  reviewer: 'manager@company.com',\n  frequency: 'weekly',\n})\n```\n\n### Human Override\n\n```typescript\n// Humans can override agent decisions\nagent.onOverride(async (override) => {\n  // Log the override\n  await agent.log({\n    type: 'override',\n    original: override.originalDecision,\n    new: override.humanDecision,\n    by: override.human,\n    reason: override.reason,\n  })\n\n  // Learn from override\n  await agent.learn({\n    situation: override.situation,\n    correction: override.humanDecision,\n    source: 'human-override',\n  })\n})\n```\n\n## Meeting Participation\n\n```typescript\n// Agent participates in meetings\nawait agent.calendar.createMeeting({\n  title: 'Sprint Planning',\n  role: 'note-taker',  // 'participant' | 'facilitator' | 'note-taker'\n})\n\n// During meeting\nagent.onMeeting(async (meeting) => {\n  // Take notes\n  await agent.transcribe(meeting)\n\n  // Track action items\n  const actionItems = await agent.extractActionItems(meeting.transcript)\n\n  // Create tasks from action items\n  for (const item of actionItems) {\n    await agent.createTask({\n      title: item.description,\n      assignee: item.owner,\n      deadline: item.dueDate,\n    })\n  }\n\n  // Send meeting summary\n  await agent.send({\n    to: meeting.attendees,\n    subject: `Meeting Notes: ${meeting.title}`,\n    body: await agent.summarize(meeting),\n  })\n})\n```\n\n## Reporting Structure\n\n```typescript\n// Agent reports to manager\nawait agent.report({\n  to: 'engineering-manager',\n  type: 'weekly-status',\n  content: {\n    tasksCompleted: 45,\n    tasksInProgress: 12,\n    blockers: ['Waiting on API access'],\n    highlights: ['Resolved critical bug'],\n    nextWeekPlan: ['Complete feature X', 'Review PRs'],\n  },\n})\n\n// Receive direction from manager\nagent.onDirection(async (direction) => {\n  await agent.prioritize(direction.priorities)\n  await agent.acknowledge(direction)\n})\n```\n\n## Permission and Access\n\n```typescript\n// Team-based permissions\nconst agent = agent({\n  permissions: {\n    // Access based on team membership\n    'engineering': ['read-code', 'create-tickets', 'comment-prs'],\n    'product': ['read-roadmap', 'update-specs'],\n    'support': ['read-tickets', 'respond-customers'],\n  },\n})\n\n// Check permission before action\nconst canAccess = await agent.hasPermission('read-code')\nif (canAccess) {\n  await agent.reviewCode(pr)\n}\n```\n\n## Team Metrics\n\n```typescript\n// Track team performance\nconst metrics = await agent.getTeamMetrics({\n  team: 'support-agents',\n  period: 'last-30-days',\n})\n\nconsole.log(metrics)\n// {\n//   ticketsResolved: 1250,\n//   avgResponseTime: '5m',\n//   customerSatisfaction: 4.5,\n//   escalationRate: 0.05,\n//   agentUtilization: {\n//     'tier1-agent': 0.85,\n//     'tier2-agent': 0.72,\n//   },\n// }\n```\n\n## Best Practices\n\n1. **Clear reporting lines** - Define who agent reports to\n2. **Explicit permissions** - Specify what agent can assign/access\n3. **Smooth handoffs** - Include full context in transitions\n4. **Human oversight** - Always allow human override\n5. **Team visibility** - Keep team informed of agent actions\n6. **Regular reviews** - Schedule human review of agent performance\n\n\n# $ Helper\n\nURL: https://primitives.org.ai/business/dollar-helper\n\n> Convenient business calculations\n\n\n\n# $ Helper\n\nThe `$` helper provides convenient methods for common business calculations and context management.\n\n## Basic Usage\n\n```typescript\nimport { $ } from 'business-as-code'\n\n// Currency formatting\n$.format(1234.56)        // \"$1,234.56\"\n$.format(1234.56, 'EUR') // \"â‚¬1,234.56\"\n\n// Percentages\n$.percent(25, 100)       // 25\n\n// Growth\n$.growth(120, 100)       // 20 (20% growth)\n\n// Margins\n$.margin(100, 60)        // 40 (40% margin)\n```\n\n## Available Methods\n\n### format(amount, currency?)\n\nFormat a number as currency:\n\n```typescript\n$.format(1234.56)        // \"$1,234.56\"\n$.format(1234.56, 'EUR') // \"â‚¬1,234.56\"\n$.format(1234.56, 'GBP') // \"Â£1,234.56\"\n$.format(1234.56, 'JPY') // \"Â¥1,235\" (no decimals)\n```\n\n### percent(value, total)\n\nCalculate percentage:\n\n```typescript\n$.percent(25, 100)  // 25\n$.percent(3, 12)    // 25\n$.percent(0, 100)   // 0\n```\n\n### growth(current, previous)\n\nCalculate growth rate:\n\n```typescript\n$.growth(120, 100)  // 20 (20% growth)\n$.growth(80, 100)   // -20 (-20% decline)\n$.growth(100, 100)  // 0 (no change)\n```\n\n### margin(revenue, cost)\n\nCalculate profit margin:\n\n```typescript\n$.margin(100, 60)   // 40 (40% margin)\n$.margin(100, 80)   // 20 (20% margin)\n$.margin(100, 100)  // 0 (no margin)\n```\n\n### roi(gain, cost)\n\nCalculate return on investment:\n\n```typescript\n$.roi(150, 100)     // 50 (50% ROI)\n$.roi(200, 100)     // 100 (100% ROI)\n$.roi(80, 100)      // -20 (-20% ROI)\n```\n\n### ltv(averageValue, frequency, lifetime)\n\nCalculate customer lifetime value:\n\n```typescript\n// $100 average order, 12 orders/year, 2 year lifetime\n$.ltv(100, 12, 2)   // 2400\n\n// $50/month subscription, 24 month average lifetime\n$.ltv(50, 12, 2)    // 1200\n```\n\n### cac(marketingSpend, newCustomers)\n\nCalculate customer acquisition cost:\n\n```typescript\n$.cac(10000, 100)   // 100 ($100 CAC)\n$.cac(50000, 500)   // 100 ($100 CAC)\n```\n\n### burnRate(cashStart, cashEnd, months)\n\nCalculate monthly burn rate:\n\n```typescript\n// Started with $100k, ended with $70k after 3 months\n$.burnRate(100000, 70000, 3)  // 10000 ($10k/month)\n```\n\n### runway(cash, burnRate)\n\nCalculate runway in months:\n\n```typescript\n$.runway(100000, 10000)  // 10 (10 months runway)\n$.runway(500000, 25000)  // 20 (20 months runway)\n```\n\n## Context Management\n\nThe `$` helper maintains a business context that can be shared across your application.\n\n### Accessing Context\n\n```typescript\n// Access the current context\nconsole.log($.context)\n// { business: {...}, goals: [...], kpis: [...], ... }\n```\n\n### Logging Business Events\n\n```typescript\n// Log a business event\n$.log('goal-completed', { goalName: 'Launch MVP' })\n$.log('kpi-updated', { kpi: 'MRR', value: 100000 })\n```\n\n## Context Functions\n\nFor more control over context, use the dedicated functions:\n\n```typescript\nimport { updateContext, getContext, resetContext } from 'business-as-code'\n\n// Set context\nupdateContext({\n  business: company,\n  goals: goals,\n  kpis: kpiList,\n  financials: metrics,\n})\n\n// Get current context\nconst ctx = getContext()\nconsole.log(ctx.business?.name)\n\n// Reset context\nresetContext()\n```\n\n## Creating Custom Operations\n\nCreate a customized operations helper:\n\n```typescript\nimport { createBusinessOperations } from 'business-as-code'\n\nconst ops = createBusinessOperations({\n  currency: 'EUR',\n  locale: 'de-DE',\n})\n\nops.format(1234.56)  // \"1.234,56 â‚¬\"\n```\n\n## Type Definition\n\n```typescript\ninterface BusinessOperations {\n  format: (amount: number, currency?: Currency) => string\n  percent: (value: number, total: number) => number\n  growth: (current: number, previous: number) => number\n  margin: (revenue: number, cost: number) => number\n  roi: (gain: number, cost: number) => number\n  ltv: (averageValue: number, frequency: number, lifetime: number) => number\n  cac: (marketingSpend: number, newCustomers: number) => number\n  burnRate: (cashStart: number, cashEnd: number, months: number) => number\n  runway: (cash: number, burnRate: number) => number\n  context: BusinessContext\n  log: (event: string, data?: unknown) => void\n}\n\ninterface BusinessContext {\n  business?: BusinessDefinition\n  goals?: GoalDefinition[]\n  okrs?: OKRDefinition[]\n  kpis?: KPIDefinition[]\n  financials?: FinancialMetrics\n  [key: string]: unknown\n}\n```\n\n## Examples\n\n### Dashboard Metrics\n\n```typescript\nimport { $, kpis } from 'business-as-code'\n\nconst metrics = kpis([\n  { name: 'MRR', current: 85000, target: 100000 },\n  { name: 'Customers', current: 500, target: 600 },\n])\n\n// Display formatted metrics\nconsole.log(`MRR: ${$.format(metrics[0].current!)}`)\nconsole.log(`Growth: ${$.growth(metrics[0].current!, 75000)}%`)\nconsole.log(`Achievement: ${$.percent(metrics[0].current!, metrics[0].target!)}%`)\n```\n\n### Financial Analysis\n\n```typescript\nimport { $ } from 'business-as-code'\n\nconst revenue = 1000000\nconst cogs = 300000\nconst marketing = 100000\nconst newCustomers = 500\n\nconsole.log(`Revenue: ${$.format(revenue)}`)\nconsole.log(`Gross Margin: ${$.margin(revenue, cogs)}%`)\nconsole.log(`CAC: ${$.format($.cac(marketing, newCustomers))}`)\n```\n\n### Startup Metrics\n\n```typescript\nimport { $ } from 'business-as-code'\n\nconst cashStart = 1000000\nconst cashNow = 700000\nconst monthsElapsed = 6\n\nconst burn = $.burnRate(cashStart, cashNow, monthsElapsed)\nconst months = $.runway(cashNow, burn)\n\nconsole.log(`Burn Rate: ${$.format(burn)}/month`)\nconsole.log(`Runway: ${months} months`)\n```\n\n\n# Business Entity\n\nURL: https://primitives.org.ai/business/entities\n\n> Define your company as code\n\n\n\n# Business Entity\n\nThe `Business()` function creates a complete business entity with mission, values, and organizational structure.\n\n## Basic Usage\n\n```typescript\nimport { Business } from 'business-as-code'\n\nconst company = Business({\n  name: 'Acme Corp',\n  description: 'Building the future of widgets',\n  industry: 'Technology',\n  mission: 'To make widgets accessible to everyone',\n  values: ['Innovation', 'Customer Focus', 'Integrity'],\n  targetMarket: 'SMB and Enterprise',\n  foundedAt: new Date('2020-01-01'),\n  teamSize: 50,\n})\n```\n\n## Organizational Structure\n\nDefine departments, teams, and reporting hierarchies:\n\n```typescript\nconst company = Business({\n  name: 'Acme Corp',\n  structure: {\n    departments: [\n      {\n        name: 'Engineering',\n        head: 'Jane Smith',\n        members: ['Alice', 'Bob', 'Charlie'],\n        budget: 2000000,\n        goals: [\n          { name: 'Ship v2.0', status: 'in-progress', progress: 65 }\n        ],\n      },\n      {\n        name: 'Sales',\n        head: 'John Doe',\n        members: ['David', 'Eve'],\n        budget: 1000000,\n      },\n    ],\n    teams: [\n      {\n        name: 'Platform',\n        lead: 'Alice',\n        members: ['Bob', 'Charlie'],\n        objectives: ['Build scalable infrastructure'],\n      },\n    ],\n    hierarchy: {\n      'CEO': ['CTO', 'CFO', 'COO'],\n      'CTO': ['Engineering Head', 'Product Head'],\n    },\n  },\n})\n```\n\n## Helper Functions\n\n### getTotalBudget\n\nCalculate total budget across all departments:\n\n```typescript\nimport { getTotalBudget } from 'business-as-code'\n\nconst budget = getTotalBudget(company)\n// 3000000\n```\n\n### getTotalTeamSize\n\nGet total team members from department definitions:\n\n```typescript\nimport { getTotalTeamSize } from 'business-as-code'\n\nconst size = getTotalTeamSize(company)\n// 5 (from department members)\n```\n\n### getDepartment\n\nRetrieve a specific department:\n\n```typescript\nimport { getDepartment } from 'business-as-code'\n\nconst engineering = getDepartment(company, 'Engineering')\n// { name: 'Engineering', head: 'Jane Smith', ... }\n```\n\n### getTeam\n\nRetrieve a specific team:\n\n```typescript\nimport { getTeam } from 'business-as-code'\n\nconst platform = getTeam(company, 'Platform')\n// { name: 'Platform', lead: 'Alice', ... }\n```\n\n### validateBusiness\n\nValidate business definition:\n\n```typescript\nimport { validateBusiness } from 'business-as-code'\n\nconst errors = validateBusiness(company)\nif (errors.length > 0) {\n  console.error('Invalid business:', errors)\n}\n```\n\n## Type Definition\n\n```typescript\ninterface BusinessDefinition {\n  name: string\n  description?: string\n  industry?: string\n  mission?: string\n  values?: string[]\n  targetMarket?: string\n  foundedAt?: Date\n  teamSize?: number\n  structure?: OrganizationalStructure\n  metadata?: Record<string, unknown>\n}\n\ninterface OrganizationalStructure {\n  departments?: Department[]\n  hierarchy?: Record<string, string[]>\n  teams?: Team[]\n}\n\ninterface Department {\n  name: string\n  description?: string\n  head?: string\n  members?: string[]\n  budget?: number\n  goals?: GoalDefinition[]\n}\n\ninterface Team {\n  name: string\n  description?: string\n  lead?: string\n  members?: string[]\n  objectives?: string[]\n}\n```\n\n\n# Financials\n\nURL: https://primitives.org.ai/business/financials\n\n> Calculate financial metrics\n\n\n\n# Financials\n\nThe `financials()` function calculates comprehensive financial metrics from your business data.\n\n## Basic Usage\n\n```typescript\nimport { financials } from 'business-as-code'\n\nconst metrics = financials({\n  revenue: 1000000,\n  cogs: 300000,\n  operatingExpenses: 500000,\n  currency: 'USD',\n  period: 'monthly',\n})\n\n// Automatically calculates:\nconsole.log(metrics.grossProfit)     // 700000\nconsole.log(metrics.grossMargin)     // 70\nconsole.log(metrics.operatingIncome) // 200000\nconsole.log(metrics.operatingMargin) // 20\nconsole.log(metrics.netIncome)       // 200000\nconsole.log(metrics.netMargin)       // 20\n```\n\n## Calculated Metrics\n\nThe `financials()` function automatically calculates:\n\n| Metric           | Formula                            |\n| ---------------- | ---------------------------------- |\n| Gross Profit     | Revenue - COGS                     |\n| Gross Margin     | (Gross Profit / Revenue) Ã— 100     |\n| Operating Income | Gross Profit - Operating Expenses  |\n| Operating Margin | (Operating Income / Revenue) Ã— 100 |\n| Net Income       | Operating Income (simplified)      |\n| Net Margin       | (Net Income / Revenue) Ã— 100       |\n\n## Margin Calculations\n\n```typescript\nimport {\n  calculateGrossMargin,\n  calculateOperatingMargin,\n  calculateNetMargin,\n  calculateEBITDAMargin,\n} from 'business-as-code'\n\n// Gross margin\nconst grossMargin = calculateGrossMargin(1000000, 300000)\n// 70%\n\n// Operating margin\nconst opMargin = calculateOperatingMargin(1000000, 200000)\n// 20%\n\n// Net margin\nconst netMargin = calculateNetMargin(1000000, 150000)\n// 15%\n\n// EBITDA margin\nconst ebitdaMargin = calculateEBITDAMargin(1000000, 250000)\n// 25%\n```\n\n## SaaS Metrics\n\n```typescript\nimport { calculateMRR, calculateARR, calculateLTV, calculateCAC, calculateLTVtoCAC } from 'business-as-code'\n\n// Monthly Recurring Revenue\nconst mrr = calculateMRR(subscriptions)\n// Sum of all subscription amounts\n\n// Annual Recurring Revenue\nconst arr = calculateARR(mrr)\n// MRR Ã— 12\n\n// Customer Lifetime Value\nconst ltv = calculateLTV(avgRevenue, churnRate)\n// Average revenue / churn rate\n\n// Customer Acquisition Cost\nconst cac = calculateCAC(marketingSpend, newCustomers)\n// Marketing spend / new customers\n\n// LTV to CAC ratio\nconst ratio = calculateLTVtoCAC(ltv, cac)\n// LTV / CAC (target: > 3)\n```\n\n## Startup Metrics\n\n```typescript\nimport { calculateBurnRate, calculateRunway, calculatePaybackPeriod } from 'business-as-code'\n\n// Monthly burn rate\nconst burnRate = calculateBurnRate(100000, 70000, 3)\n// (100000 - 70000) / 3 = 10000 per month\n\n// Runway in months\nconst runway = calculateRunway(100000, 10000)\n// 100000 / 10000 = 10 months\n\n// CAC payback period\nconst payback = calculatePaybackPeriod(cac, avgMonthlyRevenue, grossMargin)\n// Months to recover CAC\n```\n\n## Growth Metrics\n\n```typescript\nimport { calculateGrowthRate, calculateCAGR } from 'business-as-code'\n\n// Period-over-period growth\nconst growth = calculateGrowthRate(120, 100)\n// 20%\n\n// Compound Annual Growth Rate\nconst cagr = calculateCAGR(1000000, 100000, 5)\n// ~58% (growth over 5 years)\n```\n\n## Return Metrics\n\n```typescript\nimport { calculateROI, calculateROE, calculateROA } from 'business-as-code'\n\n// Return on Investment\nconst roi = calculateROI(150000, 100000)\n// 50%\n\n// Return on Equity\nconst roe = calculateROE(200000, 1000000)\n// 20%\n\n// Return on Assets\nconst roa = calculateROA(200000, 2000000)\n// 10%\n```\n\n## Liquidity Ratios\n\n```typescript\nimport { calculateQuickRatio, calculateCurrentRatio, calculateDebtToEquity } from 'business-as-code'\n\n// Quick ratio (acid test)\nconst quickRatio = calculateQuickRatio(500000, 200000)\n// 2.5\n\n// Current ratio\nconst currentRatio = calculateCurrentRatio(600000, 200000)\n// 3.0\n\n// Debt to equity\nconst debtToEquity = calculateDebtToEquity(500000, 1000000)\n// 0.5\n```\n\n## Financial Statements\n\nCreate and query financial statements:\n\n```typescript\nimport { createStatement, getLineItem } from 'business-as-code'\n\n// Create income statement\nconst incomeStatement = createStatement({\n  type: 'income',\n  period: 'Q1 2024',\n  lineItems: {\n    revenue: 1000000,\n    cogs: 300000,\n    grossProfit: 700000,\n    operatingExpenses: 500000,\n    operatingIncome: 200000,\n  },\n  currency: 'USD',\n})\n\n// Get specific line item\nconst revenue = getLineItem(incomeStatement, 'revenue')\n// 1000000\n```\n\n## Comparison\n\n```typescript\nimport { compareMetrics } from 'business-as-code'\n\nconst comparison = compareMetrics(currentMetrics, previousMetrics)\n// {\n//   revenueGrowth: 20,\n//   marginChange: 5,\n//   improved: ['revenue', 'grossMargin'],\n//   declined: ['operatingExpenses'],\n// }\n```\n\n## Currency Formatting\n\n```typescript\nimport { formatCurrency } from 'business-as-code'\n\nconst formatted = formatCurrency(1234567.89, 'USD')\n// \"$1,234,567.89\"\n\nconst euros = formatCurrency(1234567.89, 'EUR')\n// \"â‚¬1,234,567.89\"\n```\n\n## Validation\n\n```typescript\nimport { validateFinancials } from 'business-as-code'\n\nconst errors = validateFinancials(metrics)\nif (errors.length > 0) {\n  console.error('Invalid financials:', errors)\n}\n```\n\n## Type Definition\n\n```typescript\ninterface FinancialMetrics {\n  revenue?: number\n  cogs?: number\n  grossProfit?: number\n  grossMargin?: number\n  operatingExpenses?: number\n  operatingIncome?: number\n  operatingMargin?: number\n  netIncome?: number\n  netMargin?: number\n  ebitda?: number\n  ebitdaMargin?: number\n  operatingCashFlow?: number\n  freeCashFlow?: number\n  currency?: Currency\n  period?: TimePeriod\n}\n\ninterface FinancialStatement {\n  type: 'income' | 'balance-sheet' | 'cash-flow'\n  period: string\n  lineItems: Record<string, number>\n  currency: Currency\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Goals\n\nURL: https://primitives.org.ai/business/goals\n\n> Track strategic and operational objectives\n\n\n\n# Goals\n\nThe `Goals()` function creates a list of objectives with progress tracking, dependencies, and categorization.\n\n## Basic Usage\n\n```typescript\nimport { Goals, Goal } from 'business-as-code'\n\n// Create multiple goals\nconst goals = Goals([\n  {\n    name: 'Launch MVP',\n    description: 'Ship minimum viable product to early customers',\n    category: 'strategic',\n    targetDate: new Date('2024-06-30'),\n    owner: 'Product Team',\n    metrics: ['User signups', 'Feature completion rate'],\n    status: 'in-progress',\n    progress: 65,\n  },\n  {\n    name: 'Achieve Product-Market Fit',\n    category: 'strategic',\n    targetDate: new Date('2024-12-31'),\n    status: 'in-progress',\n    progress: 30,\n    dependencies: ['Launch MVP'],\n  },\n])\n\n// Create a single goal\nconst goal = Goal({\n  name: 'Increase Revenue',\n  category: 'financial',\n  target: 1000000,\n})\n```\n\n## Goal Categories\n\n| Category      | Description                 |\n| ------------- | --------------------------- |\n| `strategic`   | Long-term company direction |\n| `operational` | Day-to-day efficiency       |\n| `financial`   | Revenue and cost targets    |\n| `customer`    | Customer satisfaction       |\n| `internal`    | Internal processes          |\n| `learning`    | Team development            |\n\n## Goal Status\n\n| Status        | Description                |\n| ------------- | -------------------------- |\n| `not-started` | Goal not yet begun         |\n| `in-progress` | Work actively ongoing      |\n| `at-risk`     | Behind schedule or blocked |\n| `completed`   | Successfully achieved      |\n| `cancelled`   | No longer pursuing         |\n\n## Helper Functions\n\n### Progress Management\n\n```typescript\nimport { updateProgress, markAtRisk, complete } from 'business-as-code'\n\n// Update progress\nconst updated = updateProgress(goal, 75)\n\n// Mark as at risk\nconst atRisk = markAtRisk(goal, 'Blocked by dependency')\n\n// Mark complete\nconst done = complete(goal)\n```\n\n### Filtering Goals\n\n```typescript\nimport {\n  getGoalsByCategory,\n  getGoalsByStatus,\n  getGoalsByOwner\n} from 'business-as-code'\n\nconst strategic = getGoalsByCategory(goals, 'strategic')\nconst inProgress = getGoalsByStatus(goals, 'in-progress')\nconst productGoals = getGoalsByOwner(goals, 'Product Team')\n```\n\n### Checking Deadlines\n\n```typescript\nimport { isOverdue } from 'business-as-code'\n\nif (isOverdue(goal)) {\n  console.warn('Goal is past due date!')\n}\n```\n\n### Progress Aggregation\n\n```typescript\nimport { calculateOverallProgress } from 'business-as-code'\n\nconst overall = calculateOverallProgress(goals)\n// Average progress across all goals\n```\n\n### Dependency Management\n\n```typescript\nimport { hasCircularDependencies, sortByDependencies } from 'business-as-code'\n\n// Check for circular dependencies\nif (hasCircularDependencies(goals)) {\n  console.error('Circular dependency detected!')\n}\n\n// Sort goals by dependency order\nconst sorted = sortByDependencies(goals)\n// Goals with no dependencies come first\n```\n\n## Validation\n\n```typescript\nimport { validateGoals } from 'business-as-code'\n\nconst errors = validateGoals(goals)\nif (errors.length > 0) {\n  console.error('Invalid goals:', errors)\n}\n```\n\n## Type Definition\n\n```typescript\ninterface GoalDefinition {\n  name: string\n  description?: string\n  category?: 'strategic' | 'operational' | 'financial' | 'customer' | 'internal' | 'learning'\n  targetDate?: Date\n  owner?: string\n  metrics?: string[]\n  status?: 'not-started' | 'in-progress' | 'at-risk' | 'completed' | 'cancelled'\n  progress?: number\n  dependencies?: string[]\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Business\n\nURL: https://primitives.org.ai/business\n\n> Business-as-Codeâ€”traditional processes and structures manifested as code\n\n\n\nExpress business processes, organizational structures, and operations as code. Teams of AI agents and humans work together with full auditability, version control, and continuous improvement.\n\n## What is Business-as-Code?\n\nEvery business has processes: hiring, procurement, customer onboarding, expense approval, performance reviews. Traditionally, these exist as informal knowledge, scattered documents, or rigid enterprise software.\n\nBusiness-as-Code makes these processes:\n\n* **Explicit**: Every step, decision, and rule is defined in code\n* **Versionable**: Changes are tracked, reviewed, and deployed like software\n* **Composable**: Processes combine into larger organizational structures\n* **Executable**: AI and humans execute processes through the same runtime\n\n```typescript\nimport { business, team, process, role } from 'business-as-code'\n\nconst startupCo = business({\n  name: 'startup-co',\n\n  structure: {\n    departments: [engineering, product, operations],\n    hierarchy: 'flat',\n    decisionMaking: 'distributed',\n  },\n\n  teams: [\n    team({\n      name: 'engineering',\n      roles: [\n        role('engineer', { type: 'human', count: '5-10' }),\n        role('code-reviewer', { type: 'agent', count: 2 }),\n        role('devops', { type: 'hybrid', ratio: '1:1' }),\n      ],\n    }),\n  ],\n\n  processes: [\n    hiringProcess,\n    onboardingProcess,\n    deploymentProcess,\n    incidentResponseProcess,\n  ],\n\n  policies: [\n    expensePolicy,\n    remoteWorkPolicy,\n    securityPolicy,\n  ],\n})\n```\n\n## Defining Teams\n\nTeams mix human and AI roles:\n\n```typescript\nconst supportTeam = team({\n  name: 'customer-support',\n\n  roles: [\n    role('support-agent', {\n      type: 'agent',\n      count: 10,\n      capabilities: [answerQuestions, createTickets, escalate],\n      availability: '24/7',\n    }),\n\n    role('support-specialist', {\n      type: 'human',\n      count: 3,\n      handles: ['escalations', 'complex-issues', 'vip-customers'],\n      availability: 'business-hours',\n    }),\n\n    role('support-manager', {\n      type: 'human',\n      count: 1,\n      responsibilities: ['team-performance', 'process-improvement', 'hiring'],\n    }),\n  ],\n\n  workflows: {\n    incoming: ticketTriageWorkflow,\n    escalation: escalationWorkflow,\n    resolution: resolutionWorkflow,\n  },\n\n  metrics: {\n    track: ['response-time', 'resolution-rate', 'satisfaction'],\n    targets: {\n      responseTime: '< 5 minutes',\n      resolutionRate: '> 90%',\n      satisfaction: '> 4.5',\n    },\n  },\n})\n```\n\n## Business Processes\n\nDefine processes as executable workflows:\n\n```typescript\nconst hiringProcess = process({\n  name: 'hiring',\n\n  stages: [\n    stage('sourcing', {\n      owner: 'recruiter-agent',\n      tasks: [\n        task('post-job', postJobToBoards),\n        task('source-candidates', sourceCandidates),\n        task('initial-screen', screenResumes),\n      ],\n      output: 'qualified-candidates',\n    }),\n\n    stage('interviewing', {\n      owner: 'hiring-manager',\n      tasks: [\n        task('schedule-interviews', scheduleInterviews),\n        task('conduct-interviews', conductInterviews),\n        task('collect-feedback', collectFeedback),\n      ],\n      output: 'interview-feedback',\n    }),\n\n    stage('decision', {\n      owner: 'hiring-committee',\n      tasks: [\n        task('review-candidates', reviewCandidates),\n        task('make-decision', makeHiringDecision),\n        task('generate-offer', generateOffer),\n      ],\n      output: 'offer-decision',\n    }),\n\n    stage('closing', {\n      owner: 'recruiter-agent',\n      tasks: [\n        task('extend-offer', extendOffer),\n        task('negotiate', handleNegotiation),\n        task('complete-hire', completeHire),\n      ],\n      output: 'hired-employee',\n    }),\n  ],\n\n  sla: {\n    totalDuration: '< 30 days',\n    stageTimeouts: {\n      sourcing: '7 days',\n      interviewing: '14 days',\n      decision: '3 days',\n      closing: '7 days',\n    },\n  },\n})\n```\n\n## Policies and Rules\n\nEncode business rules as executable policies:\n\n```typescript\nconst expensePolicy = policy({\n  name: 'expense-approval',\n\n  rules: [\n    rule('auto-approve-small', {\n      when: 'amount <= 100',\n      then: 'auto-approve',\n    }),\n\n    rule('manager-approval', {\n      when: 'amount > 100 AND amount <= 1000',\n      then: 'require-approval',\n      from: 'direct-manager',\n    }),\n\n    rule('director-approval', {\n      when: 'amount > 1000 AND amount <= 10000',\n      then: 'require-approval',\n      from: 'department-director',\n    }),\n\n    rule('cfo-approval', {\n      when: 'amount > 10000',\n      then: 'require-approval',\n      from: 'cfo',\n    }),\n\n    rule('category-restrictions', {\n      when: 'category = travel',\n      then: 'require-receipt',\n      validate: 'receipt-matches-amount',\n    }),\n  ],\n\n  exceptions: {\n    allowedBy: ['cfo', 'ceo'],\n    requiresJustification: true,\n    logged: true,\n  },\n})\n```\n\n## Organizational Structure\n\nDefine how teams relate to each other:\n\n```typescript\nconst orgStructure = organization({\n  name: 'acme-corp',\n\n  departments: [\n    department({\n      name: 'engineering',\n      head: 'vp-engineering',\n      teams: [platformTeam, productTeam, infraTeam],\n      budget: 'quarterly-allocation',\n    }),\n\n    department({\n      name: 'product',\n      head: 'vp-product',\n      teams: [productManagement, design, research],\n    }),\n\n    department({\n      name: 'operations',\n      head: 'coo',\n      teams: [supportTeam, financeTeam, hrTeam],\n    }),\n  ],\n\n  crossFunctional: [\n    squad({\n      name: 'growth',\n      members: ['product', 'engineering', 'marketing'],\n      mission: 'Increase user acquisition and retention',\n    }),\n  ],\n\n  governance: {\n    decisions: {\n      strategic: { level: 'executive', quorum: 'majority' },\n      tactical: { level: 'department', owner: 'head' },\n      operational: { level: 'team', owner: 'lead' },\n    },\n  },\n})\n```\n\n## Composing Micro-Businesses\n\nBuild larger organizations from smaller units:\n\n```typescript\n// A micro-business is a self-contained unit\nconst contentFactory = microBusiness({\n  name: 'content-factory',\n\n  services: [\n    blogWritingService,\n    socialMediaService,\n    videoScriptService,\n  ],\n\n  team: contentTeam,\n\n  economics: {\n    costStructure: 'per-piece',\n    pricing: 'market-rate',\n    margin: '40%',\n  },\n})\n\n// Compose into larger business\nconst mediaCompany = business({\n  name: 'media-company',\n\n  units: [\n    contentFactory,\n    distributionUnit,\n    analyticsUnit,\n  ],\n\n  integration: {\n    workflow: contentToDistributionWorkflow,\n    dataFlow: 'analytics-feeds-content',\n  },\n})\n```\n\n## Audit and Compliance\n\nEvery action is logged and auditable:\n\n```typescript\nconst auditedBusiness = business({\n  name: 'regulated-co',\n\n  compliance: {\n    frameworks: ['SOC2', 'GDPR', 'HIPAA'],\n\n    audit: {\n      logAll: ['decisions', 'approvals', 'data-access'],\n      retention: '7 years',\n      immutable: true,\n    },\n\n    controls: [\n      control('access-review', { frequency: 'quarterly' }),\n      control('separation-of-duties', { enforce: true }),\n      control('data-encryption', { atRest: true, inTransit: true }),\n    ],\n  },\n})\n\n// Query audit log\nconst auditLog = await auditedBusiness.audit.query({\n  action: 'expense-approved',\n  amount: { gt: 10000 },\n  period: 'last-quarter',\n})\n```\n\n## Continuous Improvement\n\nBusinesses evolve and improve:\n\n```typescript\nconst evolvingBusiness = business({\n  name: 'learning-org',\n\n  improvement: {\n    // Track metrics\n    metrics: {\n      operational: ['cycle-time', 'error-rate', 'throughput'],\n      financial: ['revenue', 'margin', 'cac', 'ltv'],\n      people: ['satisfaction', 'retention', 'productivity'],\n    },\n\n    // Review cadence\n    reviews: {\n      weekly: 'team-retrospectives',\n      monthly: 'process-reviews',\n      quarterly: 'strategic-reviews',\n    },\n\n    // Experiment with changes\n    experiments: {\n      enabled: true,\n      scope: ['processes', 'policies', 'team-structure'],\n      governance: 'opt-in-with-rollback',\n    },\n  },\n})\n```\n\n\n# KPIs\n\nURL: https://primitives.org.ai/business/kpis\n\n> Track key performance indicators\n\n\n\n# KPIs\n\nThe `kpis()` function creates a list of key performance indicators for tracking business health.\n\n## Basic Usage\n\n```typescript\nimport { kpis, kpi } from 'business-as-code'\n\n// Create multiple KPIs\nconst kpiList = kpis([\n  {\n    name: 'Monthly Recurring Revenue',\n    description: 'Total predictable revenue per month',\n    category: 'financial',\n    unit: 'USD',\n    target: 100000,\n    current: 85000,\n    frequency: 'monthly',\n    dataSource: 'Billing System',\n    formula: 'SUM(active_subscriptions.price)',\n  },\n  {\n    name: 'Customer Churn Rate',\n    category: 'customer',\n    unit: 'percent',\n    target: 5,\n    current: 3.2,\n    frequency: 'monthly',\n  },\n])\n\n// Create a single KPI\nconst nps = kpi({\n  name: 'Net Promoter Score',\n  category: 'customer',\n  unit: 'score',\n  target: 50,\n  current: 48,\n})\n```\n\n## KPI Categories\n\n| Category     | Description                     |\n| ------------ | ------------------------------- |\n| `financial`  | Revenue, costs, margins         |\n| `customer`   | Satisfaction, retention, churn  |\n| `operations` | Efficiency, throughput, quality |\n| `people`     | Employee metrics, productivity  |\n| `growth`     | User growth, market expansion   |\n\n## Measurement Frequency\n\n| Frequency   | Description            |\n| ----------- | ---------------------- |\n| `daily`     | Measured every day     |\n| `weekly`    | Measured every week    |\n| `monthly`   | Measured every month   |\n| `quarterly` | Measured every quarter |\n| `yearly`    | Measured annually      |\n\n## Helper Functions\n\n### Achievement Calculation\n\n```typescript\nimport { calculateAchievement, kpiMeetsTarget, calculateVariance } from 'business-as-code'\n\n// Calculate achievement percentage\nconst achievement = calculateAchievement(kpiList[0])\n// 85 (85000 / 100000 * 100)\n\n// Check if KPI meets target\nconst onTarget = kpiMeetsTarget(kpiList[1])\n// true (3.2 <= 5 for churn - lower is better)\n\n// Calculate variance from target\nconst variance = calculateVariance(kpiList[0])\n// -15000 (85000 - 100000)\n\nconst variancePct = calculateVariancePercentage(kpiList[0])\n// -15 (-15%)\n```\n\n### Filtering and Grouping\n\n```typescript\nimport {\n  getKPIsByCategory,\n  getKPIsByFrequency,\n  getKPIsOnTarget,\n  getKPIsOffTarget,\n  groupByCategory,\n} from 'business-as-code'\n\n// Filter by category\nconst financial = getKPIsByCategory(kpiList, 'financial')\nconst customer = getKPIsByCategory(kpiList, 'customer')\n\n// Filter by frequency\nconst monthly = getKPIsByFrequency(kpiList, 'monthly')\n\n// Get KPIs on/off target\nconst onTarget = getKPIsOnTarget(kpiList)\nconst offTarget = getKPIsOffTarget(kpiList)\n\n// Group by category\nconst grouped = groupByCategory(kpiList)\n// { financial: [...], customer: [...] }\n```\n\n### Health Score\n\nCalculate overall KPI health:\n\n```typescript\nimport { calculateHealthScore } from 'business-as-code'\n\nconst healthScore = calculateHealthScore(kpiList)\n// 0-100 score based on target achievement\n```\n\n### Updating Values\n\n```typescript\nimport { updateCurrent, updateTarget } from 'business-as-code'\n\n// Update current value\nconst updated = updateCurrent(kpiList[0], 90000)\n\n// Update target\nconst newTarget = updateTarget(kpiList[0], 120000)\n```\n\n### Formatting\n\n```typescript\nimport { formatValue } from 'business-as-code'\n\nconst formatted = formatValue(kpiList[0])\n// \"$85,000\" or \"85000 USD\"\n```\n\n### Comparison\n\n```typescript\nimport { comparePerformance } from 'business-as-code'\n\nconst comparison = comparePerformance(currentKPIs, previousKPIs)\n// { improved: [...], declined: [...], unchanged: [...] }\n```\n\n## Validation\n\n```typescript\nimport { validateKPIs } from 'business-as-code'\n\nconst errors = validateKPIs(kpiList)\nif (errors.length > 0) {\n  console.error('Invalid KPIs:', errors)\n}\n```\n\n## Common KPIs by Category\n\n### Financial\n\n* Monthly Recurring Revenue (MRR)\n* Annual Recurring Revenue (ARR)\n* Gross Margin\n* Customer Acquisition Cost (CAC)\n* Customer Lifetime Value (LTV)\n* Burn Rate\n* Runway\n\n### Customer\n\n* Net Promoter Score (NPS)\n* Customer Satisfaction Score (CSAT)\n* Customer Effort Score (CES)\n* Churn Rate\n* Retention Rate\n\n### Operations\n\n* Uptime\n* Response Time\n* Error Rate\n* Throughput\n* Cycle Time\n\n### Growth\n\n* User Growth Rate\n* Revenue Growth Rate\n* Market Share\n* Active Users\n\n## Type Definition\n\n```typescript\ninterface KPIDefinition {\n  name: string\n  description?: string\n  category?: 'financial' | 'customer' | 'operations' | 'people' | 'growth'\n  unit?: string\n  target?: number\n  current?: number\n  frequency?: TimePeriod\n  dataSource?: string\n  formula?: string\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# OKRs\n\nURL: https://primitives.org.ai/business/okrs\n\n> Set objectives and key results\n\n\n\n# OKRs\n\nThe `okrs()` function creates Objectives and Key Results for ambitious goal setting with measurable outcomes.\n\n## Basic Usage\n\n```typescript\nimport { okrs, okr } from 'business-as-code'\n\n// Create multiple OKRs\nconst okrList = okrs([\n  {\n    objective: 'Achieve Product-Market Fit',\n    description: 'Validate that our product solves a real problem',\n    period: 'Q2 2024',\n    owner: 'CEO',\n    keyResults: [\n      {\n        description: 'Increase Net Promoter Score',\n        metric: 'NPS',\n        startValue: 40,\n        targetValue: 60,\n        currentValue: 52,\n        unit: 'score',\n      },\n      {\n        description: 'Reduce monthly churn rate',\n        metric: 'Churn Rate',\n        startValue: 8,\n        targetValue: 4,\n        currentValue: 5.5,\n        unit: 'percent',\n      },\n      {\n        description: 'Achieve customer retention',\n        metric: 'Customers with 3+ months',\n        startValue: 50,\n        targetValue: 200,\n        currentValue: 125,\n        unit: 'customers',\n      },\n    ],\n    status: 'on-track',\n    confidence: 75,\n  },\n])\n\n// Create a single OKR\nconst growthOKR = okr({\n  objective: 'Scale User Acquisition',\n  owner: 'Growth Team',\n  period: 'Q3 2024',\n  keyResults: [\n    {\n      description: 'Increase monthly active users',\n      metric: 'MAU',\n      targetValue: 100000,\n      currentValue: 65000,\n    },\n  ],\n})\n```\n\n## OKR Status\n\n| Status        | Description                |\n| ------------- | -------------------------- |\n| `not-started` | OKR period not yet begun   |\n| `on-track`    | Progressing as expected    |\n| `at-risk`     | May not achieve objectives |\n| `completed`   | Successfully achieved      |\n\n## Helper Functions\n\n### Progress Calculation\n\n```typescript\nimport { calculateKeyResultProgress, calculateOKRProgress } from 'business-as-code'\n\n// Calculate progress for a single key result\nconst krProgress = calculateKeyResultProgress(okrList[0].keyResults![0])\n// 60 (52 - 40) / (60 - 40) * 100 = 60%\n\n// Calculate overall OKR progress (average of KRs)\nconst okrProgress = calculateOKRProgress(okrList[0])\n// Average of all key result progress\n```\n\n### Confidence Assessment\n\n```typescript\nimport { calculateConfidence } from 'business-as-code'\n\n// Calculate confidence based on progress and time remaining\nconst confidence = calculateConfidence(okrList[0])\n// 0-100 confidence score\n```\n\n### Updating Key Results\n\n```typescript\nimport { updateKeyResult } from 'business-as-code'\n\n// Update a key result value\nconst updated = updateKeyResult(okrList[0], 'NPS', { currentValue: 55 })\n```\n\n### Tracking Status\n\n```typescript\nimport { isKeyResultOnTrack, isOKROnTrack, getKeyResultsOnTrack, getKeyResultsAtRisk } from 'business-as-code'\n\n// Check if key result is on track\nconst krOnTrack = isKeyResultOnTrack(okrList[0].keyResults![0])\n\n// Check if OKR is on track\nconst okrOnTrack = isOKROnTrack(okrList[0])\n\n// Get key results by status\nconst onTrack = getKeyResultsOnTrack(okrList[0].keyResults!)\nconst atRisk = getKeyResultsAtRisk(okrList[0].keyResults!)\n```\n\n### Filtering OKRs\n\n```typescript\nimport { getOKRsByOwner, getOKRsByPeriod, getOKRsByStatus } from 'business-as-code'\n\n// Filter by owner\nconst ceoOKRs = getOKRsByOwner(okrList, 'CEO')\n\n// Filter by period\nconst q2OKRs = getOKRsByPeriod(okrList, 'Q2 2024')\n\n// Filter by status\nconst atRiskOKRs = getOKRsByStatus(okrList, 'at-risk')\n```\n\n### Success Metrics\n\n```typescript\nimport { calculateSuccessRate } from 'business-as-code'\n\n// Calculate historical success rate\nconst successRate = calculateSuccessRate(completedOKRs)\n// Percentage of OKRs that met 70%+ achievement\n```\n\n### Formatting\n\n```typescript\nimport { formatKeyResult } from 'business-as-code'\n\nconst formatted = formatKeyResult(okrList[0].keyResults![0])\n// \"NPS: 52 / 60 (60%)\"\n```\n\n### Comparison\n\n```typescript\nimport { compareOKRPerformance } from 'business-as-code'\n\nconst comparison = compareOKRPerformance(currentOKRs, previousOKRs)\n// { improved: [...], declined: [...] }\n```\n\n## Validation\n\n```typescript\nimport { validateOKRs } from 'business-as-code'\n\nconst errors = validateOKRs(okrList)\nif (errors.length > 0) {\n  console.error('Invalid OKRs:', errors)\n}\n```\n\n## Best Practices\n\n### Good Objectives\n\n* **Qualitative**: Describe what you want to achieve\n* **Inspirational**: Motivate the team\n* **Time-bound**: Have a clear period\n\n### Good Key Results\n\n* **Quantitative**: Measurable with numbers\n* **Specific**: Clear metric definition\n* **Ambitious**: 70% achievement = success\n* **Limited**: 3-5 per objective\n\n## Example OKRs by Function\n\n### Engineering\n\n```typescript\nokr({\n  objective: 'Deliver a world-class developer experience',\n  keyResults: [\n    { description: 'Reduce p99 latency', metric: 'p99', targetValue: 100, unit: 'ms' },\n    { description: 'Achieve uptime', metric: 'uptime', targetValue: 99.9, unit: 'percent' },\n    { description: 'Ship features', metric: 'features', targetValue: 10, unit: 'count' },\n  ],\n})\n```\n\n### Sales\n\n```typescript\nokr({\n  objective: 'Accelerate revenue growth',\n  keyResults: [\n    { description: 'Close new ARR', metric: 'new ARR', targetValue: 1000000, unit: 'USD' },\n    { description: 'Increase ACV', metric: 'ACV', targetValue: 50000, unit: 'USD' },\n    { description: 'Improve win rate', metric: 'win rate', targetValue: 30, unit: 'percent' },\n  ],\n})\n```\n\n### Customer Success\n\n```typescript\nokr({\n  objective: 'Create delighted customers',\n  keyResults: [\n    { description: 'Increase NPS', metric: 'NPS', targetValue: 70, unit: 'score' },\n    { description: 'Reduce churn', metric: 'churn', targetValue: 2, unit: 'percent' },\n    { description: 'Expand revenue', metric: 'expansion', targetValue: 20, unit: 'percent' },\n  ],\n})\n```\n\n## Type Definition\n\n```typescript\ninterface OKRDefinition {\n  objective: string\n  description?: string\n  period?: string\n  owner?: string\n  keyResults?: KeyResult[]\n  status?: 'not-started' | 'on-track' | 'at-risk' | 'completed'\n  confidence?: number\n  metadata?: Record<string, unknown>\n}\n\ninterface KeyResult {\n  description: string\n  metric: string\n  startValue?: number\n  targetValue: number\n  currentValue?: number\n  unit?: string\n  progress?: number\n}\n```\n\n\n# Processes\n\nURL: https://primitives.org.ai/business/processes\n\n> Define business processes with steps and metrics\n\n\n\n# Processes\n\nThe `Process()` function defines business processes with ordered steps, metrics, and automation levels.\n\n## Basic Usage\n\n```typescript\nimport { Process } from 'business-as-code'\n\nconst process = Process({\n  name: 'Customer Onboarding',\n  description: 'Process for onboarding new customers',\n  category: 'core',\n  owner: 'Customer Success Team',\n  inputs: ['Customer Information', 'Subscription Plan'],\n  outputs: ['Configured Account', 'Training Materials'],\n})\n```\n\n## Process Categories\n\n| Category     | Description                      |\n| ------------ | -------------------------------- |\n| `core`       | Primary value-creating processes |\n| `support`    | Supporting business operations   |\n| `management` | Planning and control processes   |\n\n## Defining Steps\n\n```typescript\nconst process = Process({\n  name: 'Customer Onboarding',\n  steps: [\n    {\n      order: 1,\n      name: 'Welcome Email',\n      description: 'Send personalized welcome email',\n      responsible: 'CS Manager',\n      duration: '5 minutes',\n      automationLevel: 'automated',\n    },\n    {\n      order: 2,\n      name: 'Initial Setup Call',\n      description: 'Schedule and conduct setup call',\n      responsible: 'CS Rep',\n      duration: '30 minutes',\n      automationLevel: 'manual',\n    },\n    {\n      order: 3,\n      name: 'Account Configuration',\n      description: 'Configure account based on requirements',\n      responsible: 'CS Rep',\n      duration: '1 hour',\n      automationLevel: 'semi-automated',\n    },\n  ],\n})\n```\n\n## Automation Levels\n\n| Level            | Description                |\n| ---------------- | -------------------------- |\n| `manual`         | Fully human-performed      |\n| `semi-automated` | Human with tool assistance |\n| `automated`      | Fully automated            |\n\n## Process Metrics\n\nTrack performance with metrics:\n\n```typescript\nconst process = Process({\n  name: 'Customer Onboarding',\n  metrics: [\n    {\n      name: 'Time to First Value',\n      description: 'Days until customer sees first value',\n      target: 7,\n      current: 5,\n      unit: 'days',\n    },\n    {\n      name: 'Completion Rate',\n      target: 95,\n      current: 92,\n      unit: 'percent',\n    },\n  ],\n})\n```\n\n## Helper Functions\n\n### Step Management\n\n```typescript\nimport {\n  getStepsInOrder,\n  getStepsByAutomationLevel,\n  addStep,\n  removeStep,\n} from 'business-as-code'\n\n// Get steps in order\nconst ordered = getStepsInOrder(process.steps!)\n// Steps sorted by order property\n\n// Filter by automation level\nconst automated = getStepsByAutomationLevel(process.steps!, 'automated')\nconst manual = getStepsByAutomationLevel(process.steps!, 'manual')\n\n// Add a new step\nconst withStep = addStep(process, {\n  order: 4,\n  name: 'Follow-up Survey',\n  automationLevel: 'automated',\n})\n\n// Remove a step\nconst withoutStep = removeStep(process, 'Welcome Email')\n```\n\n### Duration Calculations\n\n```typescript\nimport { calculateTotalDuration, formatDuration } from 'business-as-code'\n\n// Calculate total process duration\nconst total = calculateTotalDuration(process)\n// { hours: 1, minutes: 35 }\n\n// Format duration for display\nconst formatted = formatDuration(total)\n// \"1 hour 35 minutes\"\n```\n\n### Automation Analysis\n\n```typescript\nimport { calculateAutomationPercentage } from 'business-as-code'\n\nconst automationPct = calculateAutomationPercentage(process)\n// 33.3 (1 of 3 steps automated)\n```\n\n### Metrics Management\n\n```typescript\nimport { getMetric, meetsTarget, updateMetric, calculateMetricAchievement } from 'business-as-code'\n\n// Get a specific metric\nconst ttfv = getMetric(process, 'Time to First Value')\n\n// Check if metric meets target\nconst onTarget = meetsTarget(ttfv)\n// true (5 <= 7)\n\n// Update metric value\nconst updated = updateMetric(process, 'Time to First Value', { current: 4 })\n\n// Calculate achievement percentage\nconst achievement = calculateMetricAchievement(ttfv)\n// 140% (exceeding target by 40%)\n```\n\n## Validation\n\n```typescript\nimport { validateProcess } from 'business-as-code'\n\nconst errors = validateProcess(process)\nif (errors.length > 0) {\n  console.error('Invalid process:', errors)\n}\n```\n\n## Type Definition\n\n```typescript\ninterface ProcessDefinition {\n  name: string\n  description?: string\n  category?: 'core' | 'support' | 'management'\n  owner?: string\n  steps?: ProcessStep[]\n  inputs?: string[]\n  outputs?: string[]\n  metrics?: ProcessMetric[]\n  metadata?: Record<string, unknown>\n}\n\ninterface ProcessStep {\n  order: number\n  name: string\n  description?: string\n  responsible?: string\n  duration?: string\n  automationLevel?: 'manual' | 'semi-automated' | 'automated'\n}\n\ninterface ProcessMetric {\n  name: string\n  description?: string\n  target?: number\n  current?: number\n  unit?: string\n}\n```\n\n\n# Products\n\nURL: https://primitives.org.ai/business/products\n\n> Define product offerings\n\n\n\n# Products\n\nThe `Product()` function defines product offerings with pricing models, features, and roadmaps.\n\n## Basic Usage\n\n```typescript\nimport { Product } from 'business-as-code'\n\nconst product = Product({\n  name: 'Widget Pro',\n  description: 'Enterprise-grade widget management platform',\n  category: 'SaaS',\n  targetSegment: 'Enterprise',\n  valueProposition: 'Reduce widget management costs by 50%',\n  pricingModel: 'subscription',\n  price: 99,\n  currency: 'USD',\n  cogs: 20,\n  features: [\n    'Unlimited widgets',\n    'Advanced analytics',\n    'API access',\n    '24/7 support',\n  ],\n})\n```\n\n## Pricing Models\n\n| Model          | Description                  |\n| -------------- | ---------------------------- |\n| `one-time`     | Single purchase price        |\n| `subscription` | Recurring payment            |\n| `usage-based`  | Pay per use                  |\n| `freemium`     | Free tier with paid upgrades |\n| `tiered`       | Multiple pricing tiers       |\n\n## Product Roadmap\n\nDefine planned features and releases:\n\n```typescript\nconst product = Product({\n  name: 'Widget Pro',\n  price: 99,\n  roadmap: [\n    {\n      name: 'Mobile app',\n      description: 'Native iOS and Android apps',\n      targetDate: new Date('2024-09-01'),\n      priority: 'high',\n      status: 'in-progress',\n    },\n    {\n      name: 'AI features',\n      description: 'Smart widget recommendations',\n      targetDate: new Date('2024-12-01'),\n      priority: 'medium',\n      status: 'planned',\n    },\n  ],\n})\n```\n\n## Helper Functions\n\n### Financial Calculations\n\n```typescript\nimport { calculateGrossMargin, calculateGrossProfit } from 'business-as-code'\n\nconst margin = calculateGrossMargin(product)\n// 79.8% ((99 - 20) / 99 * 100)\n\nconst profit = calculateGrossProfit(product)\n// 79 (99 - 20)\n```\n\n### Roadmap Management\n\n```typescript\nimport {\n  getRoadmapByStatus,\n  getRoadmapByPriority,\n  getOverdueRoadmapItems,\n  updateRoadmapItem,\n} from 'business-as-code'\n\n// Filter by status\nconst inProgress = getRoadmapByStatus(product.roadmap!, 'in-progress')\n\n// Filter by priority\nconst highPriority = getRoadmapByPriority(product.roadmap!, 'high')\n\n// Find overdue items\nconst overdue = getOverdueRoadmapItems(product.roadmap!)\n\n// Update an item\nconst updated = updateRoadmapItem(product.roadmap!, 'Mobile app', {\n  status: 'completed',\n})\n```\n\n### Feature Management\n\n```typescript\nimport { addFeature, removeFeature } from 'business-as-code'\n\n// Add a feature\nconst withFeature = addFeature(product, 'Custom branding')\n\n// Remove a feature\nconst withoutFeature = removeFeature(product, 'API access')\n```\n\n## Validation\n\n```typescript\nimport { validateProduct } from 'business-as-code'\n\nconst errors = validateProduct(product)\nif (errors.length > 0) {\n  console.error('Invalid product:', errors)\n}\n```\n\n## Type Definition\n\n```typescript\ninterface ProductDefinition {\n  name: string\n  description?: string\n  category?: string\n  targetSegment?: string\n  valueProposition?: string\n  pricingModel?: 'one-time' | 'subscription' | 'usage-based' | 'freemium' | 'tiered'\n  price?: number\n  currency?: Currency\n  cogs?: number\n  features?: string[]\n  roadmap?: RoadmapItem[]\n  metadata?: Record<string, unknown>\n}\n\ninterface RoadmapItem {\n  name: string\n  description?: string\n  targetDate?: Date\n  priority?: 'critical' | 'high' | 'medium' | 'low'\n  status?: 'planned' | 'in-progress' | 'completed' | 'cancelled'\n}\n```\n\n\n# Services\n\nURL: https://primitives.org.ai/business/services\n\n> Define professional services\n\n\n\n# Services\n\nThe `Service()` function defines professional services with delivery times, SLAs, and pricing.\n\n## Basic Usage\n\n```typescript\nimport { Service } from 'business-as-code'\n\nconst service = Service({\n  name: 'Widget Consulting',\n  description: 'Expert widget implementation and optimization',\n  category: 'Consulting',\n  targetSegment: 'Enterprise',\n  valueProposition: 'Get expert help implementing widgets in 2 weeks',\n  pricingModel: 'fixed',\n  price: 5000,\n  currency: 'USD',\n  deliveryTime: '2 weeks',\n})\n```\n\n## Pricing Models\n\n| Model         | Description               |\n| ------------- | ------------------------- |\n| `hourly`      | Billed by the hour        |\n| `fixed`       | Fixed project price       |\n| `retainer`    | Monthly retainer fee      |\n| `value-based` | Priced on delivered value |\n\n## Service Level Agreements\n\nDefine SLAs for quality guarantees:\n\n```typescript\nconst service = Service({\n  name: 'Premium Support',\n  pricingModel: 'retainer',\n  price: 10000,\n  sla: {\n    uptime: 99.9,\n    responseTime: '< 1 hour',\n    supportHours: '24/7',\n    penalties: '10% refund per hour of downtime',\n  },\n})\n```\n\n## Helper Functions\n\n### Price Calculations\n\n```typescript\nimport {\n  calculateHourlyPrice,\n  calculateMonthlyRetainer,\n  calculateValueBasedPrice,\n} from 'business-as-code'\n\n// Calculate hourly rate from fixed price\nconst hourlyRate = calculateHourlyPrice(service, 40)\n// 125 (5000 / 40 hours)\n\n// Calculate monthly retainer\nconst monthly = calculateMonthlyRetainer(service, 10)\n// 1000 (10 hours * 100/hour)\n\n// Calculate value-based price\nconst valuePrice = calculateValueBasedPrice({\n  expectedValue: 100000,\n  sharePercentage: 10,\n})\n// 10000\n```\n\n### Delivery Estimation\n\n```typescript\nimport { parseDeliveryTimeToDays, estimateCompletionDate } from 'business-as-code'\n\n// Parse delivery time to days\nconst days = parseDeliveryTimeToDays(service)\n// 14 (2 weeks)\n\n// Estimate completion date\nconst completion = estimateCompletionDate(service)\n// Date object 2 weeks from now\n```\n\n### SLA Validation\n\n```typescript\nimport { checkSLAUptime } from 'business-as-code'\n\n// Check if uptime meets SLA\nconst meetsUptime = checkSLAUptime(service, 99.95)\n// true (99.95 >= 99.9)\n```\n\n## Validation\n\n```typescript\nimport { validateService } from 'business-as-code'\n\nconst errors = validateService(service)\nif (errors.length > 0) {\n  console.error('Invalid service:', errors)\n}\n```\n\n## Type Definition\n\n```typescript\ninterface ServiceDefinition {\n  name: string\n  description?: string\n  category?: string\n  targetSegment?: string\n  valueProposition?: string\n  pricingModel?: 'hourly' | 'fixed' | 'retainer' | 'value-based'\n  price?: number\n  currency?: Currency\n  deliveryTime?: string\n  sla?: ServiceLevelAgreement\n  metadata?: Record<string, unknown>\n}\n\ninterface ServiceLevelAgreement {\n  uptime?: number\n  responseTime?: string\n  supportHours?: string\n  penalties?: string\n}\n```\n\n\n# Vision\n\nURL: https://primitives.org.ai/business/vision\n\n> Articulate long-term business direction\n\n\n\n# Vision\n\nThe `Vision()` function defines your company's long-term direction with measurable success indicators.\n\n## Basic Usage\n\n```typescript\nimport { Vision } from 'business-as-code'\n\nconst vision = Vision({\n  statement: \"To become the world's most trusted widget platform\",\n  timeframe: '5 years',\n  successIndicators: [\n    '10M+ active users',\n    'Present in 50+ countries',\n    'Industry-leading NPS score',\n    '$1B+ annual revenue',\n  ],\n})\n```\n\n## Tracking Progress\n\n### checkIndicator\n\nCheck if a specific indicator has been achieved:\n\n```typescript\nimport { checkIndicator } from 'business-as-code'\n\nconst achieved = checkIndicator(vision, '10M+ active users', {\n  activeUsers: 12000000,\n})\n// true\n```\n\n### calculateProgress\n\nCalculate overall vision progress:\n\n```typescript\nimport { calculateProgress } from 'business-as-code'\n\nconst progress = calculateProgress(vision, {\n  activeUsers: 5000000,\n  countries: 30,\n  nps: 65,\n  revenue: 500000000,\n})\n// { overall: 50, indicators: { ... } }\n```\n\n## Validation\n\n```typescript\nimport { validateVision } from 'business-as-code'\n\nconst errors = validateVision(vision)\nif (errors.length > 0) {\n  console.error('Invalid vision:', errors)\n}\n```\n\n## Best Practices\n\n1. **Be Specific**: Include measurable outcomes\n2. **Set Timeframes**: Define when you expect to achieve the vision\n3. **Track Progress**: Use success indicators to measure advancement\n4. **Review Regularly**: Update as market conditions change\n\n## Type Definition\n\n```typescript\ninterface VisionDefinition {\n  statement: string\n  timeframe?: string\n  successIndicators?: string[]\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Workflows\n\nURL: https://primitives.org.ai/business/workflows\n\n> Define automated business sequences\n\n\n\n# Workflows\n\nThe `Workflow()` function defines automated sequences triggered by events, schedules, or webhooks.\n\n## Basic Usage\n\n```typescript\nimport { Workflow } from 'business-as-code'\n\nconst workflow = Workflow({\n  name: 'New Customer Welcome',\n  description: 'Automated welcome sequence for new customers',\n  trigger: {\n    type: 'event',\n    event: 'Customer.created',\n  },\n  actions: [\n    {\n      order: 1,\n      type: 'send',\n      description: 'Send welcome email',\n      params: {\n        template: 'welcome_email',\n        to: '{{customer.email}}',\n      },\n    },\n  ],\n})\n```\n\n## Trigger Types\n\n### Event Triggers\n\nReact to business events:\n\n```typescript\nconst workflow = Workflow({\n  name: 'Order Processing',\n  trigger: {\n    type: 'event',\n    event: 'Order.placed',\n  },\n  // ...\n})\n```\n\n### Schedule Triggers\n\nRun on a schedule:\n\n```typescript\nconst workflow = Workflow({\n  name: 'Daily Report',\n  trigger: {\n    type: 'schedule',\n    schedule: '0 9 * * *', // Every day at 9 AM\n  },\n  // ...\n})\n```\n\n### Webhook Triggers\n\nRespond to external webhooks:\n\n```typescript\nconst workflow = Workflow({\n  name: 'Payment Received',\n  trigger: {\n    type: 'webhook',\n    webhook: 'https://api.example.com/webhooks/payment',\n  },\n  // ...\n})\n```\n\n### Manual Triggers\n\nStart manually:\n\n```typescript\nconst workflow = Workflow({\n  name: 'Ad-hoc Report',\n  trigger: {\n    type: 'manual',\n  },\n  // ...\n})\n```\n\n## Action Types\n\n| Type     | Description                          |\n| -------- | ------------------------------------ |\n| `send`   | Send email, notification, or message |\n| `create` | Create a new record or task          |\n| `update` | Update existing data                 |\n| `delete` | Remove data                          |\n| `notify` | Send a notification                  |\n| `call`   | Make an API call                     |\n| `wait`   | Pause execution                      |\n\n## Complex Workflow Example\n\n```typescript\nconst workflow = Workflow({\n  name: 'Customer Onboarding',\n  trigger: {\n    type: 'event',\n    event: 'Customer.created',\n  },\n  actions: [\n    {\n      order: 1,\n      type: 'send',\n      description: 'Send welcome email',\n      params: {\n        template: 'welcome_email',\n        to: '{{customer.email}}',\n      },\n    },\n    {\n      order: 2,\n      type: 'wait',\n      description: 'Wait 24 hours',\n      params: { duration: '24h' },\n    },\n    {\n      order: 3,\n      type: 'create',\n      description: 'Create onboarding task',\n      params: {\n        type: 'Task',\n        title: 'Onboard {{customer.name}}',\n        assignee: 'customer_success_team',\n      },\n      condition: '{{customer.plan}} == \"enterprise\"',\n    },\n    {\n      order: 4,\n      type: 'notify',\n      description: 'Alert sales team',\n      params: {\n        channel: 'slack',\n        message: 'New enterprise customer: {{customer.name}}',\n      },\n      condition: '{{customer.plan}} == \"enterprise\"',\n    },\n  ],\n})\n```\n\n## Helper Functions\n\n### Action Management\n\n```typescript\nimport {\n  getActionsInOrder,\n  getActionsByType,\n  getConditionalActions,\n  addAction,\n  removeAction,\n  updateAction,\n} from 'business-as-code'\n\n// Get actions in order\nconst ordered = getActionsInOrder(workflow.actions!)\n\n// Filter by type\nconst sendActions = getActionsByType(workflow.actions!, 'send')\nconst waitActions = getActionsByType(workflow.actions!, 'wait')\n\n// Get actions with conditions\nconst conditional = getConditionalActions(workflow.actions!)\n\n// Add an action\nconst withAction = addAction(workflow, {\n  order: 5,\n  type: 'send',\n  description: 'Send follow-up',\n})\n\n// Remove an action\nconst withoutAction = removeAction(workflow, 1)\n\n// Update an action\nconst updated = updateAction(workflow, 1, {\n  params: { template: 'new_template' },\n})\n```\n\n### Trigger Helpers\n\n```typescript\nimport { isEventTrigger, isScheduleTrigger, isWebhookTrigger } from 'business-as-code'\n\nif (isEventTrigger(workflow.trigger)) {\n  console.log('Event:', workflow.trigger.event)\n}\n\nif (isScheduleTrigger(workflow.trigger)) {\n  console.log('Schedule:', workflow.trigger.schedule)\n}\n```\n\n### Duration Parsing\n\n```typescript\nimport { parseWaitDuration } from 'business-as-code'\n\nconst waitAction = { type: 'wait', params: { duration: '24h' } }\nconst milliseconds = parseWaitDuration(waitAction)\n// 86400000 (24 hours in ms)\n```\n\n### Template Filling\n\n```typescript\nimport { fillTemplate } from 'business-as-code'\n\nconst template = 'Hello {{customer.name}}, welcome to {{company}}!'\nconst filled = fillTemplate(template, {\n  'customer.name': 'John',\n  'company': 'Acme Corp',\n})\n// \"Hello John, welcome to Acme Corp!\"\n```\n\n### Condition Evaluation\n\n```typescript\nimport { evaluateCondition } from 'business-as-code'\n\nconst condition = '{{customer.plan}} == \"enterprise\"'\nconst shouldRun = evaluateCondition(condition, {\n  'customer.plan': 'enterprise',\n})\n// true\n```\n\n## Validation\n\n```typescript\nimport { validateWorkflow } from 'business-as-code'\n\nconst errors = validateWorkflow(workflow)\nif (errors.length > 0) {\n  console.error('Invalid workflow:', errors)\n}\n```\n\n## Type Definition\n\n```typescript\ninterface WorkflowDefinition {\n  name: string\n  description?: string\n  trigger?: WorkflowTrigger\n  actions?: WorkflowAction[]\n  metadata?: Record<string, unknown>\n}\n\ninterface WorkflowTrigger {\n  type: 'event' | 'schedule' | 'webhook' | 'manual'\n  event?: string\n  schedule?: string\n  webhook?: string\n}\n\ninterface WorkflowAction {\n  order: number\n  type: 'send' | 'create' | 'update' | 'delete' | 'notify' | 'call' | 'wait'\n  description?: string\n  params?: Record<string, unknown>\n  condition?: string\n}\n```\n\n\n# DB()\n\nURL: https://primitives.org.ai/database/DB\n\n> Create a database instance with schema\n\n\n\nCreate a database instance with typed schemas. Returns `db` and all primitive exports.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n```\n\n## Syntax\n\n```typescript\nconst { db, nouns, verbs, events, actions, artifacts } = DB(schema, options?)\n```\n\n## Basic Usage\n\n```typescript\nconst { db } = DB({\n  Post: { title: 'string', content: 'markdown', author: 'Author.posts' },\n  Author: { name: 'string' },\n})\n\nawait db.Post.create({ title: 'Hello World' })\nawait db.Author.create({ name: 'Alice' })\n```\n\n## Full Destructuring\n\n```typescript\nconst { db, nouns, verbs, events, actions, artifacts } = DB({\n  Post: { title: 'string', author: 'Author.posts' },\n  Author: { name: 'string' },\n})\n\n// db - CRUD operations\nawait db.Post.create({ title: 'Hello' })\nawait db.Post.list()\n\n// nouns - type definitions\nconst postNoun = await nouns.get('Post')\n\n// verbs - action definitions\nconst publishVerb = verbs.get('publish')\n\n// events - event log\nevents.on('Post.created', handler)\n\n// actions - durable execution\nconst action = await actions.start('generatePosts', { count: 100 })\n\n// artifacts - embeddings and cached content\nconst embedding = await artifacts.get(postId, 'embedding')\n```\n\n## Schema Types\n\n| Type         | Description   |\n| ------------ | ------------- |\n| `'string'`   | Text field    |\n| `'number'`   | Numeric field |\n| `'boolean'`  | True/false    |\n| `'markdown'` | Markdown text |\n| `'json'`     | JSON object   |\n| `'date'`     | Date only     |\n| `'datetime'` | Date and time |\n| `'url'`      | URL string    |\n\n### Modifiers\n\n| Modifier     | Example          | Description           |\n| ------------ | ---------------- | --------------------- |\n| `?`          | `'string?'`      | Optional field        |\n| `[]`         | `'string[]'`     | Array                 |\n| `.backref`   | `'Author.posts'` | Relation with backref |\n| `[.backref]` | `['Tag.posts']`  | Many-to-many relation |\n\n## Options\n\n```typescript\nconst { db } = DB(schema, {\n  url: 'sqlite://./data.db',  // storage backend\n  embeddings: {\n    model: 'text-embedding-3-large',\n    dimensions: 3072,\n  },\n})\n```\n\n| Option                  | Type   | Description             |\n| ----------------------- | ------ | ----------------------- |\n| `url`                   | string | Database URL            |\n| `embeddings`            | object | Embedding configuration |\n| `embeddings.model`      | string | Embedding model         |\n| `embeddings.dimensions` | number | Vector dimensions       |\n\n## Environment Variables\n\n```bash\nDATABASE_URL=./content         # filesystem (default)\nDATABASE_URL=sqlite://./data   # SQLite\nDATABASE_URL=:memory:          # in-memory (testing)\n```\n\n\n# actions\n\nURL: https://primitives.org.ai/database/actions\n\n> Durable execution of long-running tasks\n\n\n\nActions provide durable execution for long-running operations. They survive restarts, track progress, and support retries.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db, actions } = DB({\n  Post: { title: 'string' },\n})\n```\n\n## Why Actions?\n\n| Problem             | Solution                          |\n| ------------------- | --------------------------------- |\n| Generate 1000 posts | Run in background, track progress |\n| Embed all content   | Resume from checkpoint on restart |\n| Process failed jobs | Automatic retries with backoff    |\n| Monitor progress    | Real-time status updates          |\n\n## Operations\n\n### start\n\nStart a new action:\n\n```typescript\nconst action = await actions.start('generatePosts', {\n  type: 'Post',\n  count: 100,\n  data: { topic: 'AI trends' },\n})\n// { id: 'action_abc', status: 'pending' }\n```\n\n### get\n\nCheck action status:\n\n```typescript\nconst status = await actions.get(action.id)\n// { status: 'active', progress: 47, total: 100 }\n```\n\n### list\n\nList actions:\n\n```typescript\nconst pending = await actions.list({ status: 'pending' })\nconst active = await actions.list({ status: 'active' })\nconst failed = await actions.list({ status: 'failed' })\n```\n\n### retry\n\nRetry a failed action:\n\n```typescript\nawait actions.retry(action.id)\n```\n\n### cancel\n\nCancel a running action:\n\n```typescript\nawait actions.cancel(action.id)\n```\n\n### result\n\nWait for completion:\n\n```typescript\nconst result = await actions.result(action.id)\n```\n\n## Action Status\n\n```\npending â†’ active â†’ completed\n                 â†˜ failed â†’ (retry) â†’ pending\n```\n\n| Status      | Description           |\n| ----------- | --------------------- |\n| `pending`   | Waiting to start      |\n| `active`    | Currently running     |\n| `completed` | Finished successfully |\n| `failed`    | Failed (can retry)    |\n\n## Background Generation\n\n```typescript\n// Start background generation\nconst action = await db.generate({\n  type: 'Post',\n  count: 100,\n  data: { topic: 'AI trends' },\n  mode: 'background',\n})\n\n// Check progress\nconst status = await actions.get(action.id)\nconsole.log(`${status.progress}/${status.total}`)\n\n// Wait for completion\nconst posts = await actions.result(action.id)\n```\n\n## Action Features\n\n* **Durability** - Survives process restarts\n* **Progress** - Real-time progress tracking\n* **Retries** - Automatic retry with backoff\n* **Batching** - Group operations for efficiency\n* **Queuing** - Rate limiting and concurrency control\n\n## Custom Actions\n\n```typescript\nawait actions.define('processImages', async (input, context) => {\n  const { images } = input\n\n  for (let i = 0; i < images.length; i++) {\n    await processImage(images[i])\n    context.progress(i + 1, images.length)\n  }\n\n  return { processed: images.length }\n})\n\n// Use it\nconst action = await actions.start('processImages', {\n  images: ['a.jpg', 'b.jpg', 'c.jpg'],\n})\n```\n\n\n# artifacts\n\nURL: https://primitives.org.ai/database/artifacts\n\n> Cached embeddings and computed content\n\n\n\nArtifacts store computed content with automatic cache invalidation.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db, artifacts } = DB({\n  Post: { title: 'string', content: 'markdown' },\n})\n```\n\n## What Are Artifacts?\n\nArtifacts are cached outputs associated with entities:\n\n| Use           | Example                           |\n| ------------- | --------------------------------- |\n| Embeddings    | Vector representations for search |\n| Rendered HTML | Markdown to HTML conversion       |\n| Bundles       | Compiled JavaScript/CSS           |\n| AST           | Parsed code/content               |\n\n## Automatic Embeddings\n\nWhen you create entities, embeddings are auto-generated:\n\n```typescript\nconst post = await db.Post.create({\n  title: 'Hello',\n  content: 'This is my post...',\n})\n\n// Embedding artifact auto-created\nconst embedding = await artifacts.get(post.$id, 'embedding')\n// { vectors: Float32Array, model: '...', dimensions: 3072 }\n```\n\n## Operations\n\n### get\n\nGet an artifact:\n\n```typescript\nconst embedding = await artifacts.get(entityId, 'embedding')\nconst html = await artifacts.get(entityId, 'html')\n```\n\n### set\n\nStore an artifact:\n\n```typescript\nawait artifacts.set(entityId, 'html', {\n  content: renderedHtml,\n  sourceHash: hash(content),\n})\n```\n\n### delete\n\nDelete artifacts:\n\n```typescript\nawait artifacts.delete(entityId, 'html')  // specific type\nawait artifacts.delete(entityId)          // all for entity\n```\n\n### list\n\nList artifacts for an entity:\n\n```typescript\nconst all = await artifacts.list(entityId)\n// ['embedding', 'html', 'ast']\n```\n\n## Cache Invalidation\n\nWhen source content changes, artifacts invalidate:\n\n```typescript\nawait db.Post.update(post.$id, {\n  content: 'New content...',\n})\n\n// Embedding is regenerated automatically\n// Custom artifacts return null until rebuilt\n```\n\n## Artifact Types\n\n| Type        | Description                        |\n| ----------- | ---------------------------------- |\n| `embedding` | Vector embeddings (auto-generated) |\n| `chunks`    | Chunked content for search         |\n| `ast`       | Parsed abstract syntax tree        |\n| `html`      | Rendered HTML                      |\n| `bundle`    | Bundled JavaScript/CSS             |\n| Custom      | Any string type you define         |\n\n## Custom Artifacts\n\n```typescript\n// Compute and store\nconst html = await renderMarkdown(post.content)\nawait artifacts.set(post.$id, 'html', {\n  content: html,\n  sourceHash: hash(post.content),\n})\n\n// Retrieve later\nconst cached = await artifacts.get(post.$id, 'html')\nif (cached && cached.sourceHash === hash(post.content)) {\n  return cached.content  // Cache hit\n}\n```\n\n\n# count\n\nURL: https://primitives.org.ai/database/count\n\n> Count entities matching criteria\n\n\n\nCount entities of a type, optionally with filters.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', published: 'boolean' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.Type.count()\ndb.Type.count(where)\n```\n\n## Examples\n\n```typescript\n// Count all\nconst total = await db.Post.count()\n// 42\n\n// Count with filter\nconst published = await db.Post.count({\n  published: true,\n})\n// 28\n```\n\n## With Operators\n\n```typescript\n// Count recent posts\nconst recent = await db.Post.count({\n  createdAt: { $gte: lastWeek },\n})\n\n// Count by author\nconst byAuthor = await db.Post.count({\n  author: authorId,\n})\n```\n\n## Use Cases\n\n```typescript\n// Pagination\nconst total = await db.Post.count({ published: true })\nconst pages = Math.ceil(total / 10)\n\n// Analytics\nconst stats = {\n  total: await db.Post.count(),\n  published: await db.Post.count({ published: true }),\n  draft: await db.Post.count({ published: false }),\n}\n\n// Progress tracking\nconst total = await db.Post.count()\nlet processed = 0\n\nawait db.forEach({ type: 'Post' }, async (post) => {\n  await process(post)\n  processed++\n  console.log(`${processed}/${total}`)\n})\n```\n\n## Return Type\n\nReturns a number:\n\n```typescript\nconst count: number = await db.Post.count()\n```\n\n\n# create\n\nURL: https://primitives.org.ai/database/create\n\n> Create new entities\n\n\n\nCreate new entities with typed schemas.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', content: 'markdown' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.Type.create(data)\ndb.Type.create(id, data)\n```\n\n## Examples\n\n```typescript\n// Auto-generated ID\nconst post = await db.Post.create({\n  title: 'Hello World',\n  content: 'My first post...',\n})\n// post.$id = 'abc123' (auto-generated)\n\n// Custom ID\nconst post = await db.Post.create('hello-world', {\n  title: 'Hello World',\n  content: 'My first post...',\n})\n// post.$id = 'hello-world'\n```\n\n## Return Value\n\nReturns the full entity with generated fields:\n\n```typescript\nconst user = await db.User.create({\n  name: 'Alice',\n  email: 'alice@example.com',\n})\n\n// Returns:\n{\n  $id: 'usr_abc123',\n  $type: 'User',\n  name: 'Alice',\n  email: 'alice@example.com',\n  createdAt: Date,\n  updatedAt: Date,\n}\n```\n\n## With Relationships\n\n```typescript\nconst author = await db.Author.create({ name: 'Alice' })\n\nconst post = await db.Post.create({\n  title: 'Hello',\n  author: author.$id,  // relationship by ID\n})\n```\n\n## Batch Creation\n\n```typescript\nconst posts = await Promise.all([\n  db.Post.create({ title: 'Post 1' }),\n  db.Post.create({ title: 'Post 2' }),\n  db.Post.create({ title: 'Post 3' }),\n])\n```\n\n## Events\n\nCreate emits a `{Type}.created` event:\n\n```typescript\nawait db.Post.create({ title: 'Hello' })\n// Emits: Post.created { url, data, timestamp }\n```\n\n## Validation\n\n```typescript\n// Missing required field\nawait db.Post.create({ content: '...' })\n// Error: Missing required field 'title'\n\n// Wrong type\nawait db.Post.create({ title: 123 })\n// Error: Expected string for 'title', got number\n```\n\n\n# delete\n\nURL: https://primitives.org.ai/database/delete\n\n> Delete entities\n\n\n\nRemove entities by ID.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.Type.delete(id)\ndb.Type.delete(id, options)\n```\n\n## Examples\n\n```typescript\n// Delete by ID\nawait db.Post.delete('hello-world')\n\n// Delete returns the deleted entity\nconst deleted = await db.Post.delete('hello-world')\nconsole.log(deleted.title)  // 'Hello World'\n```\n\n## Batch Delete\n\n```typescript\n// Delete multiple\nawait Promise.all([\n  db.Post.delete('post-1'),\n  db.Post.delete('post-2'),\n  db.Post.delete('post-3'),\n])\n\n// Delete by criteria\nconst drafts = await db.Post.find({ status: 'draft' })\nawait Promise.all(drafts.map(d => db.Post.delete(d.$id)))\n```\n\n## Events\n\nDelete emits a `{Type}.deleted` event:\n\n```typescript\nawait db.Post.delete('hello')\n// Emits: Post.deleted { url, timestamp }\n```\n\n## Cascade Behavior\n\nBy default, relationships are nullified:\n\n```typescript\n// Post has author relationship\nawait db.Author.delete('alice')\n// Posts by alice now have author: null\n```\n\nConfigure cascade:\n\n```typescript\nawait db.Author.delete('alice', {\n  cascade: true,  // also delete related posts\n})\n```\n\n## Soft Delete\n\nFor recoverable deletions:\n\n```typescript\n// Mark as deleted instead of removing\nawait db.Post.update('hello', {\n  deletedAt: new Date(),\n})\n\n// Query excludes soft-deleted by default\nconst posts = await db.Post.list()\n// doesn't include soft-deleted\n\n// Include soft-deleted\nconst all = await db.Post.list({\n  where: { deletedAt: { $exists: true } },\n})\n```\n\n## Artifacts\n\nWhen entity is deleted, artifacts are also removed:\n\n```typescript\nawait db.Post.delete('hello')\n// Removes: entity, embedding, all artifacts\n```\n\n\n# events\n\nURL: https://primitives.org.ai/database/events\n\n> Immutable event log for reactivity\n\n\n\nEvery mutation emits an immutable event. Build reactive systems, audit trails, and event-driven workflows.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db, events } = DB({\n  Post: { title: 'string' },\n})\n```\n\n## Automatic Events\n\nAll mutations emit events automatically:\n\n```typescript\nawait db.Post.create({ title: 'Hello' })\n// Emits: Post.created\n\nawait db.Post.update('hello', { published: true })\n// Emits: Post.updated\n\nawait db.Post.delete('hello')\n// Emits: Post.deleted\n```\n\n## Operations\n\n### on\n\nSubscribe to events:\n\n```typescript\nevents.on('Post.created', async (event) => {\n  console.log(`New post: ${event.data.title}`)\n})\n\n// Pattern matching\nevents.on('Post.*', handler)      // all Post events\nevents.on('*.created', handler)   // all creation events\n```\n\n### off\n\nUnsubscribe:\n\n```typescript\nevents.off('Post.created', handler)\n```\n\n### emit\n\nEmit custom events:\n\n```typescript\nawait events.emit('Post.published', {\n  url: post.$id,\n  data: { title: post.title },\n})\n```\n\n### list\n\nQuery the event log:\n\n```typescript\nconst changes = await events.list({\n  type: 'Post.*',\n  since: lastWeek,\n  limit: 100,\n})\n```\n\n### replay\n\nReplay events for recovery:\n\n```typescript\nawait events.replay({\n  type: 'Post.*',\n  since: checkpoint,\n  handler: async (event) => {\n    // Process each event\n  },\n})\n```\n\n## Event Types\n\n| Event              | Emitted When         |\n| ------------------ | -------------------- |\n| `{Type}.created`   | Entity created       |\n| `{Type}.updated`   | Entity updated       |\n| `{Type}.deleted`   | Entity deleted       |\n| `{Type}.generated` | Entity AI-generated  |\n| `Relation.created` | Relationship created |\n| `Relation.deleted` | Relationship deleted |\n| `Action.started`   | Action began         |\n| `Action.completed` | Action succeeded     |\n| `Action.failed`    | Action failed        |\n\n## Event Structure\n\n```typescript\ninterface Event {\n  id: string\n  type: string          // 'Post.created'\n  url: string           // entity URL\n  data: unknown         // entity data or changes\n  timestamp: Date\n  actor?: string        // who triggered it\n}\n```\n\n## Use Cases\n\n```typescript\n// Generate social posts on creation\nevents.on('Post.created', async (event) => {\n  await db.generate({\n    type: 'SocialPost',\n    data: { post: event.url },\n  })\n})\n\n// Send notifications\nevents.on('Post.published', async (event) => {\n  await notify(event.data)\n})\n\n// Audit trail\nevents.on('*', async (event) => {\n  await auditLog.append(event)\n})\n```\n\n\n# find\n\nURL: https://primitives.org.ai/database/find\n\n> Find entities matching criteria\n\n\n\nQuery entities with SQL, Document, or Graph-style filters.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', tags: 'string[]', views: 'number' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.Type.find(where)\ndb.Type.find(options)\n```\n\n## Examples\n\n```typescript\n// Simple equality\nconst published = await db.Post.find({\n  status: 'published',\n})\n\n// Multiple conditions\nconst featured = await db.Post.find({\n  status: 'published',\n  featured: true,\n})\n```\n\n## Operators\n\n| Operator       | Description      | Example                                  |\n| -------------- | ---------------- | ---------------------------------------- |\n| `$eq`          | Equal (default)  | `{ status: 'active' }`                   |\n| `$ne`          | Not equal        | `{ status: { $ne: 'deleted' } }`         |\n| `$gt`          | Greater than     | `{ views: { $gt: 100 } }`                |\n| `$gte`         | Greater or equal | `{ views: { $gte: 100 } }`               |\n| `$lt`          | Less than        | `{ price: { $lt: 50 } }`                 |\n| `$lte`         | Less or equal    | `{ price: { $lte: 50 } }`                |\n| `$in`          | In array         | `{ status: { $in: ['a', 'b'] } }`        |\n| `$nin`         | Not in array     | `{ status: { $nin: ['deleted'] } }`      |\n| `$contains`    | Array contains   | `{ tags: { $contains: 'ai' } }`          |\n| `$containsAll` | Contains all     | `{ tags: { $containsAll: ['a', 'b'] } }` |\n| `$startsWith`  | String prefix    | `{ title: { $startsWith: 'How' } }`      |\n| `$endsWith`    | String suffix    | `{ email: { $endsWith: '@co.com' } }`    |\n| `$regex`       | Regex match      | `{ slug: { $regex: '^[a-z]+$' } }`       |\n| `$exists`      | Field exists     | `{ avatar: { $exists: true } }`          |\n\n## SQL-Style\n\n```typescript\nconst posts = await db.Post.find({\n  views: { $gt: 100 },\n  status: { $in: ['published', 'featured'] },\n})\n```\n\n## Document-Style\n\n```typescript\nconst posts = await db.Post.find({\n  'metadata.wordCount': { $gte: 1000 },\n  tags: { $containsAll: ['ai', 'tutorial'] },\n})\n```\n\n## Graph-Style\n\n```typescript\nconst posts = await db.Post.find({\n  $rel: {\n    type: 'authored',\n    from: { type: 'User', where: { verified: true } },\n  },\n})\n```\n\n## Logical Operators\n\n```typescript\n// OR\nconst posts = await db.Post.find({\n  $or: [\n    { status: 'published' },\n    { featured: true },\n  ],\n})\n\n// AND\nconst posts = await db.Post.find({\n  $and: [\n    { views: { $gt: 100 } },\n    { status: 'published' },\n  ],\n})\n\n// NOT\nconst posts = await db.Post.find({\n  $not: { status: 'deleted' },\n})\n```\n\n## With Options\n\n```typescript\nconst posts = await db.Post.find({\n  where: { published: true },\n  orderBy: 'createdAt',\n  order: 'desc',\n  limit: 10,\n})\n```\n\n\n# forEach\n\nURL: https://primitives.org.ai/database/forEach\n\n> Iterate over entities with a callback\n\n\n\nProcess each entity of a type with an async callback.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string' },\n  Persona: { name: 'string' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.forEach(options, callback)\ndb.forEach({ type: 'Type' }, callback)\ndb.forEach({ type: 'Type', where: {} }, callback)\n```\n\n## Examples\n\n```typescript\n// Process all posts\nawait db.forEach({ type: 'Post' }, async (post) => {\n  console.log(post.title)\n})\n\n// With filtering\nawait db.forEach(\n  { type: 'Post', where: { published: true } },\n  async (post) => {\n    await notifySubscribers(post)\n  }\n)\n```\n\n## Use Cases\n\n### Generate Content for Each Entity\n\n```typescript\n// Generate posts for each persona\nawait db.forEach({ type: 'Persona' }, async (persona) => {\n  await db.generate({\n    type: 'Post',\n    count: 10,\n    data: { persona: persona.$id },\n  })\n})\n```\n\n### Batch Processing\n\n```typescript\n// Update all posts\nawait db.forEach({ type: 'Post' }, async (post) => {\n  await db.Post.update(post.$id, {\n    slug: slugify(post.title),\n  })\n})\n```\n\n### Data Migration\n\n```typescript\n// Migrate old format to new\nawait db.forEach({ type: 'User' }, async (user) => {\n  await db.User.update(user.$id, {\n    displayName: user.name,  // rename field\n    name: undefined,         // remove old field\n  })\n})\n```\n\n## Options\n\n| Option        | Type                | Description                     |\n| ------------- | ------------------- | ------------------------------- |\n| `type`        | string              | Entity type to iterate          |\n| `where`       | object              | Filter criteria                 |\n| `orderBy`     | string              | Sort field                      |\n| `order`       | `'asc'` \\| `'desc'` | Sort direction                  |\n| `limit`       | number              | Max entities to process         |\n| `concurrency` | number              | Parallel callbacks (default: 1) |\n\n## Concurrency\n\n```typescript\n// Process 5 at a time\nawait db.forEach(\n  { type: 'Post', concurrency: 5 },\n  async (post) => {\n    await processPost(post)\n  }\n)\n```\n\n## Progress Tracking\n\n```typescript\nlet processed = 0\nconst total = await db.Post.count()\n\nawait db.forEach({ type: 'Post' }, async (post) => {\n  await processPost(post)\n  processed++\n  console.log(`${processed}/${total}`)\n})\n```\n\n## Error Handling\n\n```typescript\nawait db.forEach({ type: 'Post' }, async (post) => {\n  try {\n    await processPost(post)\n  } catch (error) {\n    console.error(`Failed: ${post.$id}`, error)\n    // continues to next entity\n  }\n})\n```\n\n\n# generate\n\nURL: https://primitives.org.ai/database/generate\n\n> AI-powered entity creation\n\n\n\nGenerate entities using AI based on schema descriptions.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: {\n    title: 'Engaging blog post title',\n    content: 'Full markdown article (1500-2500 words)',\n    tags: ['3-5 relevant tags'],\n  },\n})\n```\n\n## Basic Generation\n\n```typescript\nconst post = await db.generate({\n  type: 'Post',\n  data: { topic: 'TypeScript best practices' },\n})\n```\n\n## Schema as Prompt\n\nSchema descriptions guide AI generation:\n\n```typescript\nconst { db } = DB({\n  Post: {\n    title: 'Engaging blog post title',           // AI knows to be engaging\n    content: 'Full markdown (1500-2500 words)',  // AI targets word count\n    tags: ['3-5 relevant tags'],                 // AI generates 3-5 items\n  },\n})\n\n// AI uses schema descriptions for generation\nconst post = await db.generate({\n  type: 'Post',\n  data: { topic: 'AI trends' },\n})\n```\n\n## Batch Generation\n\n```typescript\n// Generate multiple at once\nawait db.generate({\n  type: 'Post',\n  count: 10,\n  data: { topic: 'AI trends' },\n})\n```\n\n## Background Generation\n\nFor large batches, use background mode:\n\n```typescript\nconst action = await db.generate({\n  type: 'Post',\n  count: 100,\n  data: { topic: 'AI trends' },\n  mode: 'background',\n})\n\n// Check progress\nconst status = await actions.get(action.id)\nconsole.log(`${status.progress}/${status.total}`)\n\n// Wait for completion\nconst posts = await actions.result(action.id)\n```\n\n## With Relationships\n\n```typescript\n// Generate posts for each persona\nconst personas = await db.Persona.list()\n\nfor (const persona of personas) {\n  await db.generate({\n    type: 'Post',\n    count: 5,\n    data: { persona: persona.$id },\n  })\n}\n```\n\n## forEach Pattern\n\n```typescript\nawait db.forEach({ type: 'Persona' }, async (persona) => {\n  await db.generate({\n    type: 'Post',\n    count: 10,\n    data: { persona: persona.$id },\n  })\n})\n```\n\n## Options\n\n| Option  | Type   | Description                |\n| ------- | ------ | -------------------------- |\n| `type`  | string | Entity type to generate    |\n| `data`  | object | Context for generation     |\n| `count` | number | Number to generate         |\n| `mode`  | string | `'sync'` or `'background'` |\n| `model` | string | AI model to use            |\n\n## Seeding Data\n\n```typescript\n// Seed initial data\nfor (const name of ['Builder', 'Coder', 'Founder']) {\n  await db.generate({\n    type: 'Persona',\n    data: { name },\n  })\n}\n\n// Generate content for each\nawait db.forEach({ type: 'Persona' }, async (persona) => {\n  await db.generate({\n    type: 'Post',\n    count: 10,\n    data: { persona: persona.$id, topics: persona.interests },\n  })\n})\n```\n\n\n# get\n\nURL: https://primitives.org.ai/database/get\n\n> Get entity by ID\n\n\n\nRetrieve a single entity by its ID.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', content: 'markdown' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.Type.get(id)\ndb.Type.get(id, options)\n```\n\n## Examples\n\n```typescript\nconst post = await db.Post.get('hello-world')\n// { $id: 'hello-world', title: 'Hello World', ... }\n\n// Returns null if not found\nconst missing = await db.Post.get('does-not-exist')\n// null\n```\n\n## With Relationships\n\n```typescript\nconst post = await db.Post.get('hello-world')\n\n// Access related entities\nconst author = await post.author  // resolves relationship\nconst tags = await post.tags      // resolves array relationship\n```\n\n## Options\n\n```typescript\nconst post = await db.Post.get('hello-world', {\n  include: ['author', 'tags'],  // eager load relationships\n})\n```\n\n| Option    | Type      | Description                 |\n| --------- | --------- | --------------------------- |\n| `include` | string\\[] | Relationships to eager load |\n\n## Type Safety\n\n```typescript\nconst { db } = DB({\n  User: {\n    name: 'string',\n    email: 'string',\n    age: 'number?',\n  },\n})\n\nconst user = await db.User.get('alice')\n\nif (user) {\n  user.name   // string\n  user.email  // string\n  user.age    // number | undefined\n}\n```\n\n## Entity Structure\n\nEvery entity has built-in fields:\n\n| Field       | Type     | Description           |\n| ----------- | -------- | --------------------- |\n| `$id`       | `string` | Unique identifier     |\n| `$type`     | `string` | Type name             |\n| `createdAt` | `Date`   | Creation timestamp    |\n| `updatedAt` | `Date`   | Last update timestamp |\n\n\n# AI Database\n\nURL: https://primitives.org.ai/database\n\n> Schema-first database with AI-native primitives\n\n\n\nCreate, generate, and search by meaning.\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db, nouns, verbs, events, actions, artifacts } = DB({\n  Post: { title: 'string', author: 'Author.posts' },\n  Author: { name: 'string' },\n})\n\nawait db.Post.create({ title: 'Hello World' })\nawait db.search('beginner tutorials')\n```\n\n## Installation\n\n```bash\npnpm add ai-database\n```\n\n## All Exports\n\n### Core\n\n| Export                       | Description                                 |\n| ---------------------------- | ------------------------------------------- |\n| [`DB()`](/database/DB)       | Create a database instance with schema      |\n| [`db`](/database/db)         | Database instance for CRUD operations       |\n| [`schema`](/database/schema) | Define schemas with types and relationships |\n\n### CRUD\n\n| Method                         | Description                         |\n| ------------------------------ | ----------------------------------- |\n| [`create`](/database/create)   | Create new entities                 |\n| [`get`](/database/get)         | Get entity by ID                    |\n| [`list`](/database/list)       | List all entities of a type         |\n| [`find`](/database/find)       | Find with filters and pagination    |\n| [`update`](/database/update)   | Update existing entities            |\n| [`delete`](/database/delete)   | Delete entities                     |\n| [`upsert`](/database/upsert)   | Create or update entities           |\n| [`set`](/database/set)         | Set entity data by ID               |\n| [`count`](/database/count)     | Count entities matching criteria    |\n| [`forEach`](/database/forEach) | Iterate over entities with callback |\n\n### Operations\n\n| Export                           | Description                           |\n| -------------------------------- | ------------------------------------- |\n| [`queries`](/database/queries)   | SQL, Document, and Graph query styles |\n| [`search`](/database/search)     | Hybrid vector + full-text search      |\n| [`generate`](/database/generate) | AI-powered entity creation            |\n\n### Structure\n\n| Export                                     | Description                           |\n| ------------------------------------------ | ------------------------------------- |\n| [`nouns`](/database/nouns)                 | Entity type definitions               |\n| [`verbs`](/database/verbs)                 | Action definitions and conjugation    |\n| [`relationships`](/database/relationships) | Bi-directional edges between entities |\n\n### Reactivity\n\n| Export                             | Description                             |\n| ---------------------------------- | --------------------------------------- |\n| [`events`](/database/events)       | Immutable event log                     |\n| [`actions`](/database/actions)     | Durable execution of long-running tasks |\n| [`artifacts`](/database/artifacts) | Cached embeddings and computed content  |\n\n## Why AI-Native?\n\n| Feature     | Traditional          | AI-Native                       |\n| ----------- | -------------------- | ------------------------------- |\n| **Storage** | Store bytes          | Store + chunk + embed           |\n| **Search**  | Keyword matching     | Semantic similarity + full-text |\n| **Create**  | Insert provided data | Insert or generate from context |\n| **Schema**  | Structure data       | Structure + guide generation    |\n\n## Quick Example\n\n```typescript\nimport { DB } from 'ai-database'\n\n// Schema descriptions ARE generation prompts\nconst { db, events, actions } = DB({\n  Persona: {\n    name: 'A memorable persona name',\n    description: '2-3 paragraph bio',\n    interests: ['5-7 specific topics'],\n  },\n  Post: {\n    title: 'Engaging post title',\n    content: 'Full markdown post (1500-2500 words)',\n    persona: 'Persona.posts',\n  },\n})\n\n// Subscribe to events\nevents.on('Post.created', async (event) => {\n  console.log(`New post: ${event.data.title}`)\n})\n\n// Seed personas\nfor (const name of ['Builder', 'Coder', 'Founder']) {\n  await db.generate({ type: 'Persona', data: { name } })\n}\n\n// Generate posts in background\nconst action = await db.generate({\n  type: 'Post',\n  count: 100,\n  mode: 'background',\n})\n\n// Check progress\nconst status = await actions.get(action.id)\nconsole.log(`${status.progress}/${status.total}`)\n\n// Search across all content\nconst results = await db.search('practical AI tips')\n```\n\n## Configuration\n\n```bash\nDATABASE_URL=./content         # filesystem (default)\nDATABASE_URL=sqlite://./data   # SQLite\nDATABASE_URL=:memory:          # in-memory (testing)\n```\n\n\n# list\n\nURL: https://primitives.org.ai/database/list\n\n> List all entities of a type\n\n\n\nRetrieve all entities of a type with optional filtering and pagination.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', published: 'boolean' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.Type.list()\ndb.Type.list(options)\n```\n\n## Examples\n\n```typescript\n// List all\nconst posts = await db.Post.list()\n\n// With pagination\nconst posts = await db.Post.list({\n  limit: 10,\n  offset: 20,\n})\n\n// With sorting\nconst recent = await db.Post.list({\n  orderBy: 'createdAt',\n  order: 'desc',\n})\n\n// With filtering\nconst published = await db.Post.list({\n  where: { published: true },\n})\n```\n\n## Options\n\n| Option    | Type                | Description                 |\n| --------- | ------------------- | --------------------------- |\n| `where`   | object              | Filter criteria             |\n| `orderBy` | string              | Field to sort by            |\n| `order`   | `'asc'` \\| `'desc'` | Sort direction              |\n| `limit`   | number              | Max results                 |\n| `offset`  | number              | Skip results                |\n| `include` | string\\[]           | Relationships to eager load |\n\n## Filtering\n\n```typescript\nconst posts = await db.Post.list({\n  where: {\n    published: true,\n    createdAt: { $gte: lastWeek },\n  },\n})\n```\n\n## Pagination\n\n```typescript\n// First page\nconst page1 = await db.Post.list({ limit: 10, offset: 0 })\n\n// Second page\nconst page2 = await db.Post.list({ limit: 10, offset: 10 })\n```\n\n## Sorting\n\n```typescript\n// Newest first\nconst recent = await db.Post.list({\n  orderBy: 'createdAt',\n  order: 'desc',\n})\n\n// Alphabetical\nconst alphabetical = await db.Post.list({\n  orderBy: 'title',\n  order: 'asc',\n})\n```\n\n## Return Type\n\nReturns an array of entities:\n\n```typescript\nconst posts = await db.Post.list()\n// Post[]\n\nposts.forEach(post => {\n  console.log(post.$id, post.title)\n})\n```\n\n\n# nouns\n\nURL: https://primitives.org.ai/database/nouns\n\n> Entity type definitions\n\n\n\nNouns are semantic type definitions that describe entities with their properties, relationships, actions, and events.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db, nouns } = DB({\n  Post: { title: 'string', author: 'Author.posts' },\n  Author: { name: 'string' },\n})\n```\n\n## What is a Noun?\n\nA Noun represents an entity type with all its metadata:\n\n```typescript\nimport { defineNoun } from 'ai-database'\n\nconst Post = defineNoun({\n  singular: 'post',\n  plural: 'posts',\n  description: 'A blog post or article',\n\n  properties: {\n    title: { type: 'string', description: 'The post title' },\n    content: { type: 'markdown', description: 'The post body' },\n  },\n\n  relationships: {\n    author: { type: 'Author', backref: 'posts' },\n  },\n\n  actions: ['create', 'update', 'delete', 'publish'],\n  events: ['created', 'updated', 'deleted', 'published'],\n})\n```\n\n## Operations\n\n### get\n\nGet a noun definition:\n\n```typescript\nconst postNoun = await nouns.get('Post')\npostNoun.singular  // 'post'\npostNoun.plural    // 'posts'\n```\n\n### list\n\nList all nouns:\n\n```typescript\nconst allNouns = await nouns.list()\n// [{ name: 'Post', singular: 'post', ... }, ...]\n```\n\n### define\n\nDefine a new noun:\n\n```typescript\nawait nouns.define({\n  name: 'Comment',\n  singular: 'comment',\n  plural: 'comments',\n  properties: {\n    content: { type: 'string' },\n    post: { type: 'Post', backref: 'comments' },\n  },\n})\n```\n\n## Auto-Inference\n\nWhen you define a schema, nouns are auto-created:\n\n```typescript\nconst { db, nouns } = DB({\n  BlogPost: { title: 'string' },\n})\n\nconst noun = await nouns.get('BlogPost')\nnoun.singular   // 'blog post'\nnoun.plural     // 'blog posts'\nnoun.slug       // 'blog-post'\nnoun.slugPlural // 'blog-posts'\n```\n\n## Why Nouns?\n\n| Benefit              | Description                           |\n| -------------------- | ------------------------------------- |\n| **Self-documenting** | Schema describes itself               |\n| **AI Generation**    | Descriptions guide content generation |\n| **Introspection**    | Query types at runtime                |\n| **Consistency**      | Single source of truth                |\n\n## Helpers\n\n```typescript\nimport { pluralize, singularize, inferNoun } from 'ai-database'\n\npluralize('post')      // 'posts'\npluralize('category')  // 'categories'\npluralize('person')    // 'people'\n\nsingularize('posts')   // 'post'\nsingularize('people')  // 'person'\n\ninferNoun('BlogPost')\n// { singular: 'blog post', plural: 'blog posts', ... }\n```\n\n\n# queries\n\nURL: https://primitives.org.ai/database/queries\n\n> SQL, Document, and Graph query styles\n\n\n\nai-database unifies three query paradigms in a single API.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', published: 'boolean' },\n})\n```\n\n## Query Styles\n\n| Style    | Best For                     | Example                     |\n| -------- | ---------------------------- | --------------------------- |\n| SQL      | Relational data, comparisons | `price: { $gt: 100 }`       |\n| Document | Nested data, arrays          | `'profile.city': 'SF'`      |\n| Graph    | Relationships, traversal     | `$rel: { type: 'follows' }` |\n\n## Basic Queries\n\n```typescript\n// List all\nconst posts = await db.Post.list()\n\n// Find by criteria\nconst published = await db.Post.find({\n  status: 'published',\n})\n\n// With options\nconst recent = await db.Post.list({\n  where: { published: true },\n  orderBy: 'createdAt',\n  order: 'desc',\n  limit: 10,\n})\n```\n\n## Operators\n\n| Category   | Operators                                  |\n| ---------- | ------------------------------------------ |\n| Comparison | `$eq`, `$ne`, `$gt`, `$gte`, `$lt`, `$lte` |\n| Set        | `$in`, `$nin`                              |\n| Array      | `$contains`, `$containsAll`, `$size`       |\n| String     | `$startsWith`, `$endsWith`, `$regex`       |\n| Existence  | `$exists`, `$type`                         |\n| Logical    | `$and`, `$or`, `$not`                      |\n| Graph      | `$rel`, `$relCount`                        |\n\n## SQL-Style\n\n```typescript\nconst posts = await db.Post.find({\n  publishedAt: { $gte: lastWeek },\n  views: { $gt: 100 },\n  status: { $in: ['published', 'featured'] },\n})\n```\n\n## Document-Style\n\n```typescript\nconst posts = await db.Post.find({\n  'metadata.wordCount': { $gte: 1000 },\n  tags: { $containsAll: ['ai', 'tutorial'] },\n})\n```\n\n## Graph-Style\n\n```typescript\nconst posts = await db.Post.find({\n  $rel: {\n    type: 'authored',\n    from: {\n      type: 'User',\n      where: { verified: true },\n    },\n  },\n})\n```\n\n## Combining Styles\n\nMix all three in a single query:\n\n```typescript\nconst posts = await db.Post.find({\n  // SQL-style: comparisons\n  publishedAt: { $gte: lastWeek },\n\n  // Document-style: nested fields\n  'metadata.wordCount': { $gte: 1000 },\n  tags: { $containsAll: ['ai', 'tutorial'] },\n\n  // Graph-style: relationships\n  $rel: {\n    type: 'authored',\n    from: {\n      type: 'User',\n      where: { verified: true },\n    },\n  },\n})\n```\n\n## Search vs Query\n\n**Queries** filter by exact criteria:\n\n```typescript\nconst drafts = await db.Post.find({\n  status: 'draft',\n})\n```\n\n**Search** finds by semantic similarity:\n\n```typescript\nconst results = await db.Post.search('AI tutorials for beginners')\n```\n\nCombine both:\n\n```typescript\nconst results = await db.Post.search({\n  query: 'AI tutorials',\n  where: { published: true },\n})\n```\n\n\n# relationships\n\nURL: https://primitives.org.ai/database/relationships\n\n> Bi-directional edges between entities\n\n\n\nai-database automatically creates bi-directional relationships from schema definitions.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', author: 'Author.posts' },\n  Author: { name: 'string' },\n})\n```\n\n## Defining Relationships\n\n```typescript\nconst { db } = DB({\n  Post: {\n    title: 'string',\n    author: 'Author.posts',  // one-to-many\n    tags: ['Tag.posts'],     // many-to-many\n  },\n  Author: {\n    name: 'string',\n    // posts: Post[] auto-created\n  },\n  Tag: {\n    name: 'string',\n    // posts: Post[] auto-created\n  },\n})\n```\n\n## Relationship Syntax\n\n| Syntax             | Cardinality       | Example                  |\n| ------------------ | ----------------- | ------------------------ |\n| `'Type.backref'`   | Many-to-one       | `author: 'Author.posts'` |\n| `['Type.backref']` | Many-to-many      | `tags: ['Tag.posts']`    |\n| `'Type'`           | One-way reference | `createdBy: 'User'`      |\n\n## Automatic Backrefs\n\nWhen you define `author: 'Author.posts'`, the database creates:\n\n* `Post.author` â†’ single Author\n* `Author.posts` â†’ array of Posts\n\n```typescript\n// Forward\nconst post = await db.Post.get('hello')\nconst author = await post.author  // Author\n\n// Backward\nconst author = await db.Author.get('alice')\nconst posts = await author.posts  // Post[]\n```\n\n## Cardinality\n\n### One-to-Many\n\n```typescript\n// Post has one author, Author has many posts\nPost: {\n  author: 'Author.posts',\n}\n```\n\n### Many-to-Many\n\n```typescript\n// Post has many tags, Tag has many posts\nPost: {\n  tags: ['Tag.posts'],\n}\n```\n\n### One-to-One\n\n```typescript\n// User has one profile, Profile has one user\nUser: {\n  profile: 'Profile.user',\n}\n```\n\n## Creating with Relationships\n\n```typescript\n// Create author\nconst author = await db.Author.create({ name: 'Alice' })\n\n// Create post with relationship\nconst post = await db.Post.create({\n  title: 'Hello',\n  content: '...',\n  author: author.$id,  // relationship by ID\n})\n```\n\n## Querying Relationships\n\n```typescript\n// Posts by verified authors\nconst posts = await db.Post.find({\n  $rel: {\n    type: 'authored',\n    from: { type: 'Author', where: { verified: true } },\n  },\n})\n```\n\n## Edge Records\n\nEvery relationship creates an Edge record:\n\n```typescript\n// Edge: Post.author -> Author\n{\n  from: 'Post',\n  name: 'author',\n  to: 'Author',\n  backref: 'posts',\n  cardinality: 'many-to-one',\n}\n\n// Query edges for introspection\nconst edges = await db.Edge.find({ to: 'Author' })\n// What types reference Author?\n```\n\n\n# schema\n\nURL: https://primitives.org.ai/database/schema\n\n> Define schemas with types and relationships\n\n\n\nDefine database schemas with types, relationships, and AI generation hints.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n```\n\n## Basic Schema\n\n```typescript\nconst { db } = DB({\n  Post: {\n    title: 'string',\n    content: 'markdown',\n    author: 'Author.posts',  // bi-directional relation\n  },\n  Author: {\n    name: 'string',\n    // posts: Post[] auto-created from backref\n  },\n})\n```\n\n## Field Types\n\n| Type         | Description   |\n| ------------ | ------------- |\n| `'string'`   | Text field    |\n| `'number'`   | Numeric field |\n| `'boolean'`  | True/false    |\n| `'date'`     | Date only     |\n| `'datetime'` | Date and time |\n| `'json'`     | JSON object   |\n| `'markdown'` | Markdown text |\n| `'url'`      | URL string    |\n\n## Modifiers\n\n| Modifier     | Example          | Description           |\n| ------------ | ---------------- | --------------------- |\n| `?`          | `'string?'`      | Optional field        |\n| `[]`         | `'string[]'`     | Array of type         |\n| `.backref`   | `'Author.posts'` | Relation with backref |\n| `[.backref]` | `['Tag.posts']`  | Many-to-many relation |\n\n## AI Generation Hints\n\nSchema descriptions guide AI generation:\n\n```typescript\nconst { db } = DB({\n  Post: {\n    title: 'Engaging blog post title',\n    content: 'Full markdown article (1500-2500 words)',\n    summary: '2-3 sentence summary',\n    tags: ['3-5 relevant tags'],\n  },\n})\n\n// AI uses descriptions for generation\nawait db.generate({ type: 'Post', data: { topic: 'AI' } })\n```\n\n## Relationships\n\n### One-to-Many\n\n```typescript\nPost: {\n  author: 'Author.posts',  // Post has one Author\n}\n// Creates: Author.posts (Post[])\n```\n\n### Many-to-Many\n\n```typescript\nPost: {\n  tags: ['Tag.posts'],  // Post has many Tags\n}\n// Creates: Tag.posts (Post[])\n```\n\n### One-to-One\n\n```typescript\nUser: {\n  profile: 'Profile.user',  // User has one Profile\n}\n// Creates: Profile.user (User)\n```\n\n## Advanced Schema\n\n```typescript\nimport { defineNoun, nounToSchema } from 'ai-database'\n\nconst Post = defineNoun({\n  singular: 'post',\n  plural: 'posts',\n  description: 'A blog post or article',\n\n  properties: {\n    title: { type: 'string', description: 'The post title' },\n    content: { type: 'markdown', description: 'The post body' },\n    status: { type: 'string', optional: true },\n  },\n\n  relationships: {\n    author: { type: 'Author', backref: 'posts' },\n    tags: { type: 'Tag[]', backref: 'posts' },\n  },\n\n  actions: ['create', 'update', 'delete', 'publish'],\n  events: ['created', 'updated', 'deleted', 'published'],\n})\n\nconst { db } = DB({\n  Post: nounToSchema(Post),\n})\n```\n\n## Self-Describing\n\nSchemas are stored and queryable:\n\n```typescript\nconst { db, nouns } = DB({\n  Post: { title: 'string' },\n})\n\n// Query types at runtime\nconst types = await nouns.list()\nconst postNoun = await nouns.get('Post')\npostNoun.singular  // 'post'\npostNoun.plural    // 'posts'\n```\n\n## System Types\n\n| Type    | Description                       |\n| ------- | --------------------------------- |\n| `Thing` | Base typeâ€”every entity is a Thing |\n| `Noun`  | Type definitions                  |\n| `Verb`  | Action definitions                |\n| `Edge`  | Relationships between types       |\n\n\n# search\n\nURL: https://primitives.org.ai/database/search\n\n> Hybrid vector + full-text search\n\n\n\nSemantic search across all entities using embeddings and full-text indexing.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', content: 'markdown' },\n})\n```\n\n## Basic Search\n\n```typescript\nconst results = await db.Post.search('AI tutorials for beginners')\n```\n\n## With Filters\n\n```typescript\nconst results = await db.Post.search({\n  query: 'machine learning basics',\n  where: { published: true },\n  limit: 10,\n})\n```\n\n## Global Search\n\nSearch across all types:\n\n```typescript\nconst results = await db.search('TypeScript best practices')\n// Returns matches from Post, Author, Comment, etc.\n```\n\n## Search Options\n\n| Option      | Type      | Description                |\n| ----------- | --------- | -------------------------- |\n| `query`     | string    | Search query               |\n| `where`     | object    | Filter criteria            |\n| `limit`     | number    | Max results                |\n| `offset`    | number    | Skip results               |\n| `types`     | string\\[] | Types to search            |\n| `threshold` | number    | Similarity threshold (0-1) |\n\n## Search Results\n\n```typescript\ninterface SearchResult {\n  $id: string\n  $type: string\n  score: number     // relevance score\n  highlights: {     // matched snippets\n    field: string\n    snippet: string\n  }[]\n  data: unknown     // full entity data\n}\n```\n\n## Hybrid Search\n\nCombines vector similarity and full-text matching:\n\n```typescript\nconst results = await db.Post.search({\n  query: 'getting started with AI',\n  mode: 'hybrid',  // 'semantic' | 'fulltext' | 'hybrid'\n})\n```\n\n## Embedding Configuration\n\n```typescript\nconst { db } = DB(schema, {\n  embeddings: {\n    model: 'text-embedding-3-large',\n    dimensions: 3072,\n  },\n})\n```\n\n## Re-embedding\n\nWhen content changes, embeddings regenerate automatically:\n\n```typescript\nawait db.Post.update(id, { content: 'New content...' })\n// Embedding recalculated in background\n```\n\n## Similarity Search\n\nFind similar entities:\n\n```typescript\nconst similar = await db.Post.similar(post.$id, { limit: 5 })\n```\n\n## Use Cases\n\n```typescript\n// Content discovery\nconst related = await db.Post.search({\n  query: currentPost.title,\n  where: { $id: { $ne: currentPost.$id } },\n  limit: 5,\n})\n\n// Recommendations\nconst forUser = await db.Post.search({\n  query: user.interests.join(' '),\n  where: { published: true },\n  limit: 10,\n})\n```\n\n\n# set\n\nURL: https://primitives.org.ai/database/set\n\n> Set entity data by ID\n\n\n\nSet entity data directly by ID. Creates if doesn't exist, replaces if it does.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Config: { key: 'string', value: 'json' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.Type.set(id, data)\n```\n\n## Examples\n\n```typescript\n// Set data directly\nawait db.Config.set('theme', {\n  key: 'theme',\n  value: { mode: 'dark', accent: 'blue' },\n})\n\n// Replaces entire entity if exists\nawait db.Config.set('theme', {\n  key: 'theme',\n  value: { mode: 'light' },  // previous value replaced\n})\n```\n\n## vs create/update/upsert\n\n| Method   | Behavior                 |\n| -------- | ------------------------ |\n| `create` | Fails if exists          |\n| `update` | Fails if doesn't exist   |\n| `upsert` | Merges on conflict       |\n| `set`    | Always replaces entirely |\n\n```typescript\n// set replaces the entire entity\nawait db.Post.set('hello', { title: 'Hello' })\n// All other fields cleared\n\n// upsert merges with existing\nawait db.Post.upsert('hello', { title: 'Hello' })\n// Other fields preserved\n```\n\n## Use Cases\n\n```typescript\n// Configuration\nawait db.Config.set('app', {\n  key: 'app',\n  value: config,\n})\n\n// Cache entries\nawait db.Cache.set(`user:${id}`, {\n  key: `user:${id}`,\n  value: userData,\n  expiresAt: new Date(Date.now() + 3600000),\n})\n\n// Singleton patterns\nawait db.State.set('current', {\n  key: 'current',\n  value: appState,\n})\n```\n\n## Return Value\n\nReturns the set entity:\n\n```typescript\nconst config = await db.Config.set('theme', {\n  key: 'theme',\n  value: { mode: 'dark' },\n})\n\nconsole.log(config.$id)    // 'theme'\nconsole.log(config.value)  // { mode: 'dark' }\n```\n\n## Events\n\nEmits `{Type}.created` or `{Type}.updated`:\n\n```typescript\nawait db.Config.set('new-key', data)\n// Emits: Config.created (if new)\n\nawait db.Config.set('existing-key', data)\n// Emits: Config.updated (if exists)\n```\n\n\n# update\n\nURL: https://primitives.org.ai/database/update\n\n> Update existing entities\n\n\n\nModify existing entities by ID.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', content: 'markdown', published: 'boolean' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.Type.update(id, data)\ndb.Type.update(id, data, options)\n```\n\n## Examples\n\n```typescript\n// Update fields\nawait db.Post.update('hello-world', {\n  content: 'Updated content...',\n})\n\n// Update multiple fields\nawait db.Post.update('hello-world', {\n  title: 'New Title',\n  content: 'New content',\n  published: true,\n})\n```\n\n## Return Value\n\nReturns the updated entity:\n\n```typescript\nconst post = await db.Post.update('hello-world', {\n  published: true,\n})\n\nconsole.log(post.published)   // true\nconsole.log(post.updatedAt)   // new Date\n```\n\n## Partial Updates\n\nOnly specified fields are updated:\n\n```typescript\n// Only updates 'published', leaves other fields unchanged\nawait db.Post.update('hello-world', {\n  published: true,\n})\n```\n\n## Events\n\nUpdate emits a `{Type}.updated` event:\n\n```typescript\nawait db.Post.update('hello', { published: true })\n// Emits: Post.updated { url, data, changes, timestamp }\n```\n\n## Artifacts\n\nWhen content changes, embeddings regenerate:\n\n```typescript\nawait db.Post.update('hello', {\n  content: 'New content...',\n})\n// Embedding artifact is regenerated automatically\n```\n\n## Validation\n\n```typescript\n// Wrong type\nawait db.Post.update('hello', { title: 123 })\n// Error: Expected string for 'title', got number\n\n// Non-existent entity\nawait db.Post.update('missing', { title: 'Test' })\n// Error: Entity not found\n```\n\n## Optimistic Updates\n\n```typescript\nconst post = await db.Post.get('hello')\n\n// Check version before update\nawait db.Post.update('hello', {\n  content: 'New content',\n}, {\n  ifVersion: post.version,  // fails if changed since read\n})\n```\n\n\n# upsert\n\nURL: https://primitives.org.ai/database/upsert\n\n> Create or update entities\n\n\n\nCreate an entity if it doesn't exist, or update it if it does.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db } = DB({\n  Post: { title: 'string', content: 'markdown' },\n})\n```\n\n## Syntax\n\n```typescript\ndb.Type.upsert(id, data)\ndb.Type.upsert(id, data, options)\n```\n\n## Examples\n\n```typescript\n// Creates if doesn't exist\nawait db.Post.upsert('hello-world', {\n  title: 'Hello World',\n  content: 'My post content...',\n})\n\n// Updates if it exists\nawait db.Post.upsert('hello-world', {\n  title: 'Hello World',\n  content: 'Updated content...',\n})\n```\n\n## Return Value\n\nReturns the created or updated entity:\n\n```typescript\nconst post = await db.Post.upsert('hello-world', {\n  title: 'Hello World',\n})\n\nconsole.log(post.$id)       // 'hello-world'\nconsole.log(post.title)     // 'Hello World'\nconsole.log(post.createdAt) // Date\n```\n\n## Partial Upsert\n\nOn update, only specified fields change:\n\n```typescript\n// First call - creates with all fields\nawait db.Post.upsert('hello', {\n  title: 'Hello',\n  content: 'Initial content',\n  views: 0,\n})\n\n// Second call - only updates title\nawait db.Post.upsert('hello', {\n  title: 'Updated Title',\n})\n// content and views unchanged\n```\n\n## Events\n\nEmits appropriate event based on operation:\n\n```typescript\nawait db.Post.upsert('new-post', { title: 'New' })\n// Emits: Post.created (if new)\n\nawait db.Post.upsert('existing', { title: 'Updated' })\n// Emits: Post.updated (if exists)\n```\n\n## Use Cases\n\n```typescript\n// Sync external data\nfor (const item of externalData) {\n  await db.Product.upsert(item.id, {\n    name: item.name,\n    price: item.price,\n  })\n}\n\n// Idempotent operations\nawait db.Config.upsert('app-settings', {\n  theme: 'dark',\n  language: 'en',\n})\n```\n\n## With Options\n\n```typescript\nawait db.Post.upsert('hello', data, {\n  onConflict: 'replace',  // 'replace' | 'merge' | 'skip'\n})\n```\n\n| Option                  | Description                     |\n| ----------------------- | ------------------------------- |\n| `onConflict: 'replace'` | Replace entire entity (default) |\n| `onConflict: 'merge'`   | Deep merge with existing        |\n| `onConflict: 'skip'`    | Skip if exists                  |\n\n\n# verbs\n\nURL: https://primitives.org.ai/database/verbs\n\n> Action definitions and conjugation\n\n\n\nVerbs describe actions with all their grammatical forms and semantic relationships.\n\n## Import\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst { db, verbs } = DB({\n  Post: { title: 'string' },\n})\n```\n\n## What is a Verb?\n\nA Verb maps an action to its conjugations:\n\n```typescript\nimport { defineVerb } from 'ai-database'\n\nconst publish = defineVerb({\n  action: 'publish',       // base form\n  actor: 'publisher',      // who does it\n  act: 'publishes',        // present tense\n  activity: 'publishing',  // gerund\n  result: 'publication',   // result noun\n  reverse: {\n    at: 'publishedAt',\n    by: 'publishedBy',\n  },\n  inverse: 'unpublish',    // opposite\n})\n```\n\n## Operations\n\n### get\n\nGet a verb definition:\n\n```typescript\nconst publishVerb = verbs.get('publish')\npublishVerb.actor     // 'publisher'\npublishVerb.activity  // 'publishing'\n```\n\n### list\n\nList all verbs:\n\n```typescript\nconst allVerbs = verbs.list()\n```\n\n### define\n\nDefine a custom verb:\n\n```typescript\nverbs.define({\n  action: 'approve',\n  actor: 'approver',\n  act: 'approves',\n  activity: 'approving',\n  result: 'approval',\n})\n```\n\n## Pre-defined Verbs\n\n```typescript\nimport { Verbs } from 'ai-database'\n\nVerbs.create   // create, creator, creates, creating, creation\nVerbs.update   // update, updater, updates, updating, update\nVerbs.delete   // delete, deleter, deletes, deleting, deletion\nVerbs.publish  // publish, publisher, publishes, publishing, publication\nVerbs.archive  // archive, archiver, archives, archiving, archive\n```\n\n## Why Verbs?\n\n| Form       | Use                                  |\n| ---------- | ------------------------------------ |\n| `action`   | Command names, button labels         |\n| `actor`    | Relationship names (creator, author) |\n| `act`      | Present tense descriptions           |\n| `activity` | Progress indicators (publishing...)  |\n| `result`   | Result nouns (creation, publication) |\n| `reverse`  | Timestamp/actor fields               |\n| `inverse`  | Undo operations                      |\n\n## Auto-Conjugation\n\n```typescript\nimport { conjugate } from 'ai-database'\n\nconjugate('publish')\n// => {\n//   action: 'publish',\n//   actor: 'publisher',\n//   act: 'publishes',\n//   activity: 'publishing',\n//   result: 'publication',\n//   reverse: { at: 'publishedAt', by: 'publishedBy' }\n// }\n```\n\n\n# AI()\n\nURL: https://primitives.org.ai/function/AI\n\n> Create typed AI instances with predefined schemas\n\n\n\nCreate a typed AI instance with predefined schemas.\n\n## Import\n\n```typescript\nimport { AI } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nconst ai = AI(schemas: Record<string, Schema>)\n```\n\n## Examples\n\n```typescript\nconst ai = AI({\n  recipe: {\n    name: 'Recipe name',\n    type: 'food | drink | dessert',\n    servings: 'Number of servings (number)',\n    ingredients: ['List of ingredients'],\n    steps: ['Cooking steps'],\n  },\n  blogPost: {\n    title: 'Post title',\n    summary: 'Brief summary',\n    sections: [{\n      heading: 'Section heading',\n      content: 'Section content',\n    }],\n  },\n})\n\n// Fully typed!\nconst recipe = await ai.recipe('Italian pasta for 4')\n// TypeScript knows: { name: string, type: 'food'|'drink'|'dessert', ... }\n\nconst post = await ai.blogPost('TypeScript tips')\n// TypeScript knows: { title: string, summary: string, sections: [...] }\n```\n\n## Benefits\n\n* **Type Safety** - Full TypeScript inference\n* **Reusability** - Define once, use everywhere\n* **Consistency** - Same schema across calls\n* **Documentation** - Schema serves as docs\n\n## Complex Schemas\n\n```typescript\nconst ai = AI({\n  storyBrand: {\n    hero: 'Who is the customer?',\n    guide: 'Who/what helps them?',\n    problem: {\n      external: 'What external challenge?',\n      internal: 'What internal struggle?',\n      philosophical: 'Why is this wrong?',\n    },\n    plan: ['Steps to success'],\n    callToAction: 'What should they do?',\n    success: 'What does winning look like?',\n    failure: 'What are they avoiding?',\n  },\n})\n\nconst brand = await ai.storyBrand('ai-functions library')\n```\n\n\n# approve\n\nURL: https://primitives.org.ai/function/approve\n\n> Get yes/no approval from a human\n\n\n\nPause execution and wait for human approval. Returns `true` if approved, `false` if rejected.\n\n## Import\n\n```typescript\nimport { approve } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\napprove`request description`\napprove`request`(options)\n```\n\n## Examples\n\n```typescript\n// Simple approval\nconst ok = await approve`Deploy to production?`\n\nif (ok) {\n  await deploy()\n}\n\n// With details\nconst approved = await approve`\n  Expense Report\n\n  Amount: $${expense.amount}\n  Category: ${expense.category}\n  Description: ${expense.description}\n  Requester: ${expense.submittedBy}\n`\n\n// With options\nconst result = await approve`${request}`({\n  assignTo: { role: 'manager' },\n  timeout: '48h',\n  escalateTo: 'director',\n})\n```\n\n## Options\n\n| Option          | Type         | Description                   |\n| --------------- | ------------ | ----------------------------- |\n| `assignTo`      | `Assignment` | Who should approve            |\n| `channel`       | `string`     | Notification channel          |\n| `timeout`       | `string`     | How long to wait              |\n| `escalateTo`    | `string`     | Who to escalate to on timeout |\n| `requireReason` | `boolean`    | Require reason for rejection  |\n\n## Returns\n\nReturns `boolean` - `true` if approved, `false` if rejected.\n\n## When to Use\n\n* Financial approvals\n* Deployment gates\n* Access requests\n* Any binary yes/no decision\n\n\n# ask\n\nURL: https://primitives.org.ai/function/ask\n\n> Get free-form input from a human\n\n\n\nPause execution and wait for human text input. Use for open-ended questions, clarifications, or decisions that need human judgment.\n\n## Import\n\n```typescript\nimport { ask } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nask`question`\nask`question`(options)\n```\n\n## Examples\n\n```typescript\n// Simple question\nconst answer = await ask`What should we name the new feature?`\n\n// With context\nconst decision = await ask`\n  The analysis found ${issues.length} issues.\n  How should we proceed?\n\n  Options:\n  1. Fix all issues\n  2. Fix critical only\n  3. Skip and continue\n`\n\n// With options\nconst input = await ask`Describe the desired outcome`({\n  assignTo: { user: 'product-manager@company.com' },\n  channel: 'slack',\n})\n```\n\n## Options\n\n| Option       | Type         | Description                             |\n| ------------ | ------------ | --------------------------------------- |\n| `assignTo`   | `Assignment` | Who should answer                       |\n| `channel`    | `string`     | Notification channel (slack, email, ui) |\n| `timeout`    | `string`     | How long to wait (e.g., '24h')          |\n| `escalateTo` | `string`     | Who to escalate to on timeout           |\n\n## Returns\n\nReturns the human's text response as a `string`.\n\n## When to Use\n\n* Open-ended questions\n* Requests for clarification\n* Creative decisions\n* Input that can't be constrained to options\n\n\n# browse\n\nURL: https://primitives.org.ai/function/browse\n\n> Browser automation with AI\n\n\n\nBrowser automation with AI. Navigate, extract, and act. Powered by Stagehand/Browserbase.\n\n## Import\n\n```typescript\nimport { browse } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nbrowse`${url}`\npage.extract`query`\npage.do`action`\n```\n\n## Examples\n\n```typescript\n// Open a page\nconst page = await browse`https://store.example.com`\n\n// Extract data\nconst price = await page.extract`price of the first item`\nconst products = await page.extract`all product names and prices${{\n  schema: { name: 'Product name', price: 'Price (number)' }\n}}`\n\n// Perform actions\nawait page.do`click on the first product`\nawait page.do`add to cart`\nawait page.do`proceed to checkout`\n```\n\n## Page Methods\n\n| Method         | Description            |\n| -------------- | ---------------------- |\n| `page.extract` | Extract data from page |\n| `page.do`      | Perform action on page |\n\n## Complex Workflows\n\n```typescript\n// Competitive analysis\nconst page = await browse`https://competitor.com/pricing`\nconst pricing = await page.extract`all plan names, prices, and features`\nconst analysis = await generate('competitive analysis', {\n  context: { pricing, ourPricing },\n})\n\n// Multi-page navigation\nconst page = await browse`https://news.ycombinator.com`\nfor await (const title of page.extract`top 10 post titles`) {\n  await page.do`click on \"${title}\"`\n  const content = await page.extract`main content`\n  const summary = await summarize`${content}`\n  await page.do`go back`\n}\n```\n\n## Extraction with Schema\n\n```typescript\nconst page = await browse`https://store.example.com`\n\nconst products = await page.extract`all products${{\n  schema: {\n    name: 'Product name',\n    price: 'Price (number)',\n    inStock: 'In stock? (boolean)',\n  }\n}}`\n```\n\n\n# code\n\nURL: https://primitives.org.ai/function/code\n\n> Generate code in any language\n\n\n\nGenerate code in any language.\n\n## Import\n\n```typescript\nimport { code } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\ncode`description`\ncode`description`(options)\ncode(description: string, options?: CodeOptions)\n```\n\n## Examples\n\n```typescript\n// Tagged template - concise\nconst validator = await code`email validation function`\nconst query = await code`SQL: top 10 customers by revenue`\n\n// With complex requirements\nconst website = await code`marketing website${{\n  requirements: {\n    pages: ['home', 'about', 'pricing'],\n    features: ['dark mode', 'animations'],\n    stack: 'Next.js + Tailwind',\n  },\n}}`\n\n// With explicit options\nconst component = await code('data table component', {\n  language: 'tsx',\n  framework: 'React',\n  features: ['sorting', 'filtering', 'pagination'],\n})\n```\n\n## Options\n\n| Option      | Type      | Description            |\n| ----------- | --------- | ---------------------- |\n| `language`  | string    | Target language        |\n| `framework` | string    | Framework/library      |\n| `features`  | string\\[] | Required features      |\n| `style`     | string    | Code style preferences |\n\n## Languages\n\n```typescript\n// Web\nawait code`React component for ${feature}`\nawait code`Vue composable for ${functionality}`\nawait code`CSS for ${design}`\n\n// Backend\nawait code`Express route for ${endpoint}`\nawait code`Prisma schema for ${dataModel}`\nawait code`SQL migration for ${change}`\n\n// Scripts\nawait code`bash script to ${task}`\nawait code`Python script for ${analysis}`\n```\n\n## With Context\n\n```typescript\nconst brand = await ai.storyBrand({ hero: 'developers', guide: 'ai-functions' })\nconst landingPage = await code`marketing site for ${{ brand }}`\n```\n\n\n# decide\n\nURL: https://primitives.org.ai/function/decide\n\n> LLM as judge - pick the best option\n\n\n\nLLM as judge. Pick the best option based on criteria.\n\n## Import\n\n```typescript\nimport { decide } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\ndecide`criteria`(option1, option2, ...options)\ndecide`criteria`(option1, option2, options?)\n```\n\n## Examples\n\n```typescript\n// Compare two options\nconst better = await decide`which is more compelling?`(copyA, copyB)\n\n// Compare multiple options\nconst best = await decide`which headline will get more clicks?`(\n  'AI is Here',\n  'The Future of AI',\n  'Why AI Matters Now',\n)\n\n// With context in criteria\nconst winner = await decide`\n  which design better fits ${{ brand, audience }}?\n`(designA, designB, designC)\n\n// Returns the winning option (same type as inputs)\nconst bestProduct = await decide`which has better value?`(productA, productB)\n// bestProduct === productA or bestProduct === productB\n```\n\n## Use Cases\n\n```typescript\n// A/B testing\nconst bestHeadline = await decide`higher conversion rate?`(headlineA, headlineB)\n\n// Content selection\nconst bestDraft = await decide`most engaging for ${audience}?`(...drafts)\n\n// Code review\nconst betterImpl = await decide`more readable and maintainable?`(implA, implB)\n```\n\n## With Options\n\n```typescript\n// Complex decisions need more reasoning\nconst winner = await decide`which architecture scales better?`(archA, archB, {\n  model: 'claude-opus-4-5',\n  thinking: 'high',  // Enable extended thinking\n})\n```\n\n## Return Type\n\nReturns the exact input option that won:\n\n```typescript\nconst options = [{ name: 'A', price: 10 }, { name: 'B', price: 20 }]\nconst best = await decide`better value?`(...options)\n// best === options[0] or best === options[1] (same reference)\n```\n\n\n# define\n\nURL: https://primitives.org.ai/function/define\n\n> The foundation for creating AI functions\n\n\n\nThe foundation of ai-functions. Every function is built on `define`.\n\n## Import\n\n```typescript\nimport { define } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\ndefine(name: string, schema: Schema)\ndefine(name: string, options: DefineOptions)\n```\n\n## Basic Definition\n\n```typescript\nconst planTrip = define('planTrip', {\n  destination: 'Travel destination',\n  budget: 'Budget in USD (number)',\n})\n\nawait planTrip({ destination: 'Tokyo', budget: 5000 })\n```\n\n## With Output Schema\n\n```typescript\nconst planTrip = define('planTrip', {\n  args: {\n    destination: 'Travel destination',\n    budget: 'Budget in USD (number)',\n  },\n  returns: {\n    itinerary: [{\n      day: 'Day number (number)',\n      activities: ['List of activities'],\n      estimatedCost: 'Cost for the day (number)',\n    }],\n    totalCost: 'Total trip cost (number)',\n    tips: ['Travel tips'],\n  },\n})\n```\n\n## With Options\n\n```typescript\nconst analyze = define('analyzeCompetitors', {\n  args: { company: 'Company name', market: 'Market segment' },\n  returns: { strengths: ['...'], weaknesses: ['...'] },\n  model: 'claude-opus-4-5',\n  temperature: 0.7,\n  system: 'You are a business analyst.',\n})\n```\n\n## Built-in Functions\n\nThe built-in functions are all created with `define`:\n\n```typescript\n// Conceptually:\nis = define('is', { returns: 'boolean' })\nlist = define('list', { returns: ['items'] })\ncode = define('code', { returns: 'code string' })\n```\n\n\n# diagram\n\nURL: https://primitives.org.ai/function/diagram\n\n> Generate diagrams in various formats\n\n\n\nGenerate diagrams in Mermaid, PlantUML, or other formats.\n\n## Import\n\n```typescript\nimport { diagram } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\ndiagram`description`\ndiagram`description`(options)\ndiagram(description: string, options?: DiagramOptions)\n```\n\n## Examples\n\n```typescript\n// Tagged template\nconst flow = await diagram`user authentication flow`\nconst erd = await diagram`e-commerce database schema`\nconst arch = await diagram`microservices architecture`\n\n// With options\nconst architecture = await diagram('system architecture', {\n  format: 'mermaid',\n  type: 'flowchart',\n  services: ['auth', 'users', 'orders', 'payments'],\n})\n```\n\n## Diagram Types\n\n```typescript\n// Flowcharts\nconst flow = await diagram`checkout process flow`\n\n// Sequence diagrams\nconst seq = await diagram`API request sequence for ${endpoint}`\n\n// Entity-relationship\nconst erd = await diagram`database schema for ${domain}`\n\n// Architecture\nconst arch = await diagram`system architecture with ${components}`\n\n// State machines\nconst state = await diagram`order state machine`\n```\n\n## Options\n\n| Option   | Type                                  | Description   |\n| -------- | ------------------------------------- | ------------- |\n| `format` | `'mermaid'` \\| `'plantuml'` \\| `'d2'` | Output format |\n| `type`   | string                                | Diagram type  |\n| `style`  | string                                | Visual style  |\n\n## Output\n\nReturns diagram code as string:\n\n````typescript\nconst diagram = await diagram`authentication flow`\n// ```mermaid\n// flowchart TD\n//   A[Login Page] --> B{Valid Credentials?}\n//   B -->|Yes| C[Dashboard]\n//   B -->|No| D[Error Message]\n// ```\n````\n\n\n# do\n\nURL: https://primitives.org.ai/function/do\n\n> Single-pass task execution with tools\n\n\n\nSingle-pass task execution. Can use other ai-functions as tools, but doesn't loop like an agent.\n\n## Import\n\n```typescript\nimport { do as act } from 'ai-functions'\n```\n\nNote: `do` is a reserved word in JavaScript, import with an alias.\n\n## Syntax\n\n```typescript\ndo`task description`\ndo`task with ${context}`\n```\n\n## Examples\n\n```typescript\n// Simple task\nconst translation = await act`translate ${text} to Spanish`\n\n// Complex task - picks appropriate tools\nconst analysis = await act`\n  analyze this article and give me a summary,\n  key people mentioned, and action items\n  ${article}\n`\n\n// With context\nconst report = await act`\n  create a competitive analysis\n  ${{ competitors, ourProduct, market }}\n`\n```\n\n## How It Works\n\n`do` analyzes the task and picks appropriate tools:\n\n```typescript\n// Might internally call: summarize() + extract() + list()\nconst analysis = await act`\n  summarize this article, extract company names,\n  and list action items\n  ${article}\n`\n```\n\n## do vs Agent\n\n| Feature    | `do`         | Full Agent             |\n| ---------- | ------------ | ---------------------- |\n| Steps      | Single pass  | Loops until done       |\n| Tools      | Picks once   | Re-evaluates each step |\n| Complexity | Simple tasks | Complex goals          |\n| Speed      | Fast         | Slower                 |\n\nThink of `do` as one step of what an agent would do.\n\n## Use Cases\n\n```typescript\n// Data processing\nconst structured = await act`parse ${rawData} into JSON`\n\n// Analysis\nconst report = await act`analyze ${metrics} and highlight anomalies`\n\n// Transformation\nconst converted = await act`convert ${doc} to markdown`\n```\n\n\n# extract\n\nURL: https://primitives.org.ai/function/extract\n\n> Extract structured data from unstructured text\n\n\n\nExtract structured data from unstructured text. Supports streaming.\n\n## Import\n\n```typescript\nimport { extract } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nextract`items from ${text}`\nextract`items from ${text}${{ schema }}`\nfor await (const item of extract`...`) { }\n```\n\n## Examples\n\n```typescript\n// Simple extraction\nconst names = await extract`person names from ${article}`\n// ['John Smith', 'Jane Doe', 'Bob Wilson']\n\n// With schema\nconst companies = await extract`companies from ${text}${{\n  schema: {\n    name: 'Company name',\n    role: 'mentioned as: competitor | partner | customer',\n  },\n}}`\n// [{ name: 'Acme', role: 'competitor' }, ...]\n\n// Stream extraction\nfor await (const email of extract`email addresses from ${document}`) {\n  await sendNotification(email)\n}\n```\n\n## Schema Extraction\n\nDefine the shape of extracted items:\n\n```typescript\nconst people = await extract`people from ${article}${{\n  schema: {\n    name: 'Full name',\n    title: 'Job title (if mentioned)',\n    company: 'Company name (if mentioned)',\n  },\n}}`\n```\n\n## Use Cases\n\n```typescript\n// Data extraction\nconst emails = await extract`email addresses from ${text}`\nconst dates = await extract`dates from ${document}`\nconst prices = await extract`prices from ${webpage}`\n\n// Entity extraction\nconst companies = await extract`company names from ${article}`\nconst products = await extract`product mentions from ${review}`\n\n// Research processing\nconst research = await research`competitors in ${market}`\nfor await (const competitor of extract`company names from ${research}`) {\n  const analysis = await research`${competitor} vs ${ourProduct}`\n}\n```\n\n## Streaming Pattern\n\nProcess extractions one at a time:\n\n```typescript\nfor await (const mention of extract`product mentions from ${text}`) {\n  const sentiment = await is`${mention} positive sentiment?`\n  await trackMention(mention, sentiment)\n}\n```\n\n\n# generate\n\nURL: https://primitives.org.ai/function/generate\n\n> The core generation primitive with schema support\n\n\n\nThe core primitive. All other functions call `generate` under the hood.\n\n## Import\n\n```typescript\nimport { generate } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\ngenerate(type: string, prompt: string, options?: GenerateOptions)\n```\n\n## Output Types\n\n```typescript\n// JSON (default)\nconst analysis = await generate('json', `competitive analysis of ${company}`)\n\n// With schema\nconst user = await generate('json', 'fake user profile', {\n  schema: {\n    name: 'Full name',\n    email: 'Email address',\n    age: 'Age in years (number)',\n  },\n})\n\n// Code\nconst config = await generate('code', 'webpack config for React', {\n  language: 'javascript',\n})\n\n// Markdown\nconst readme = await generate('markdown', `README for ${project}`)\n\n// Other formats\nconst deployment = await generate('yaml', `kubernetes deployment for ${app}`)\nconst feed = await generate('rss', `feed for ${posts}`)\n```\n\n## Schema Syntax\n\n| Syntax             | Type    | Example                       |\n| ------------------ | ------- | ----------------------------- |\n| `'description'`    | string  | `name: 'User name'`           |\n| `'desc (number)'`  | number  | `age: 'Age (number)'`         |\n| `'desc (boolean)'` | boolean | `active: 'Active? (boolean)'` |\n| `'opt1 \\| opt2'`   | enum    | `status: 'pending \\| done'`   |\n| `['description']`  | array   | `tags: ['List of tags']`      |\n| `{ nested }`       | object  | `address: { city: '...' }`    |\n\n## Built-in Mappings\n\n```typescript\n// Convenience functions use generate:\nwrite(prompt)      â†’ generate('text', prompt)\ncode(prompt)       â†’ generate('code', prompt)\nlist(prompt)       â†’ generate('list', prompt)\nsummarize(prompt)  â†’ generate('summary', prompt)\ndiagram(prompt)    â†’ generate('diagram', prompt)\n```\n\n\n# image\n\nURL: https://primitives.org.ai/function/image\n\n> Generate images from text descriptions\n\n\n\nGenerate images from text descriptions.\n\n## Import\n\n```typescript\nimport { image } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nimage`description`\nimage`description`(options)\nimage(description: string, options?: ImageOptions)\n```\n\n## Examples\n\n```typescript\n// Tagged template\nconst logo = await image`minimalist logo for ${companyName}`\nconst hero = await image`hero image for ${{ brand, mood, style }}`\n\n// With options\nconst illustration = await image('robot reading a book', {\n  style: 'cartoon',\n  size: '1024x1024',\n})\n\n// For content\nconst metadata = { title: 'AI in Healthcare' }\nconst heroImage = await image`\n  minimalist illustration for: ${metadata.title}\n  ${{ style: 'modern tech blog', colors: 'blue and purple gradients' }}\n`\n```\n\n## Options\n\n| Option   | Type                           | Description        |\n| -------- | ------------------------------ | ------------------ |\n| `size`   | string                         | Image dimensions   |\n| `style`  | string                         | Visual style       |\n| `format` | `'png'` \\| `'jpg'` \\| `'webp'` | Output format      |\n| `model`  | string                         | Image model to use |\n\n## Use Cases\n\n```typescript\n// Logos and branding\nconst logo = await image`logo for ${brand}`\nconst icon = await image`app icon for ${product}`\n\n// Content imagery\nconst hero = await image`hero for blog post about ${topic}`\nconst thumbnail = await image`youtube thumbnail for ${video}`\n\n// Social media\nconst og = await image`open graph image for ${page}`\nconst banner = await image`twitter banner for ${profile}`\n```\n\n## Return Type\n\nReturns a Buffer containing the image data:\n\n```typescript\nconst imageBuffer = await image`logo for Acme Corp`\nawait fs.writeFile('logo.png', imageBuffer)\n```\n\n\n# AI Functions\n\nURL: https://primitives.org.ai/function\n\n> Call AI like a function. No prompts. No configuration.\n\n\n\nJust call it.\n\n```typescript\nimport { ai, is, list, code } from 'ai-functions'\n\nawait ai`write a haiku about ${topic}`\nawait is`${email} a valid email?`\nawait list`blog post ideas about ${topic}`\nawait code`${task} in ${language}`\n```\n\n## Installation\n\n```bash\npnpm add ai-functions\n```\n\n## All Functions\n\n### Core\n\n| Function                         | Description                                   |\n| -------------------------------- | --------------------------------------------- |\n| [`ai`](/function/ai)             | The simplest way to call AI                   |\n| [`generate`](/function/generate) | Core generation primitive with schema support |\n| [`define`](/function/define)     | Foundation for creating AI functions          |\n| [`AI()`](/function/AI)           | Create typed AI instances with schemas        |\n\n### Generation\n\n| Function                           | Description                       |\n| ---------------------------------- | --------------------------------- |\n| [`write`](/function/write)         | Generate formatted text content   |\n| [`summarize`](/function/summarize) | Condense text to key points       |\n| [`list`](/function/list)           | Generate a list of items          |\n| [`lists`](/function/lists)         | Generate multiple named lists     |\n| [`extract`](/function/extract)     | Extract structured data from text |\n\n### Classification\n\n| Function                     | Description                     |\n| ---------------------------- | ------------------------------- |\n| [`is`](/function/is)         | Boolean classification          |\n| [`decide`](/function/decide) | LLM as judge - pick best option |\n\n### Code\n\n| Function                       | Description                           |\n| ------------------------------ | ------------------------------------- |\n| [`code`](/function/code)       | Generate code in any language         |\n| [`diagram`](/function/diagram) | Generate diagrams (Mermaid, PlantUML) |\n| [`slides`](/function/slides)   | Generate presentations                |\n\n### Media\n\n| Function                   | Description                       |\n| -------------------------- | --------------------------------- |\n| [`image`](/function/image) | Generate images from descriptions |\n| [`video`](/function/video) | Generate videos from descriptions |\n\n### Agentic\n\n| Function                         | Description                |\n| -------------------------------- | -------------------------- |\n| [`do`](/function/do)             | Single-pass task execution |\n| [`research`](/function/research) | Agentic web research       |\n| [`browse`](/function/browse)     | Browser automation with AI |\n| [`read`](/function/read)         | Fetch URL as markdown      |\n\n### Human-in-the-Loop\n\n| Function                       | Description                      |\n| ------------------------------ | -------------------------------- |\n| [`ask`](/function/ask)         | Get free-form input              |\n| [`approve`](/function/approve) | Get yes/no approval              |\n| [`review`](/function/review)   | Get detailed review and feedback |\n\n## Quick Examples\n\n```typescript\n// Generation - creates content, analyzes, extracts\nconst post = await write`blog post about ${topic}`\nconst ideas = await list`10 startup ideas for ${industry}`\n\n// Classification - returns boolean or picks options\nconst isSpam = await is`${email} spam?`\nconst best = await decide`which is better?`(optionA, optionB)\n\n// Code - generates executable code\nconst fn = await code`email validator in TypeScript`\nconst arch = await diagram`microservices architecture`\n\n// Agentic - uses tools, multiple steps\nconst analysis = await research`${company} competitive landscape`\n\n// Human - waits for human input\nconst decision = await ask`should we proceed with ${plan}?`\nconst ok = await approve`Deploy to production?`\n```\n\n\n# is\n\nURL: https://primitives.org.ai/function/is\n\n> Boolean classification\n\n\n\nBoolean classification. Returns `true` or `false`.\n\n## Import\n\n```typescript\nimport { is } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nis`${input} question?`\nis(classification: string, context: object)\n```\n\n## Examples\n\n```typescript\n// Tagged template - natural question format\nconst isSpam = await is`${emailContent} spam?`\nconst isUrgent = await is`${message} urgent?`\nconst isValid = await is`${code} valid TypeScript?`\nconst isProfessional = await is`${text} professional tone?`\n\n// With context object\nconst isPositive = await is('positive sentiment', { review: 'Great product!' })\n```\n\n## Use Cases\n\n```typescript\n// Content moderation\nconst isAppropriate = await is`${userPost} appropriate for all ages?`\nif (!isAppropriate) {\n  await flagForReview(userPost)\n}\n\n// Validation\nconst isValidEmail = await is`${input} a valid email address?`\nconst isSecure = await is`${password} a strong password?`\n\n// Classification\nconst isQuestion = await is`${text} a question?`\nconst isTechnical = await is`${article} technical content?`\n```\n\n## With Options\n\n```typescript\n// Use more powerful model for complex decisions\nconst isFactual = await is`${claim} factually accurate?`({\n  model: 'claude-opus-4-5',\n})\n```\n\n## Type Signature\n\n```typescript\ntype IsFunction = {\n  (strings: TemplateStringsArray, ...values: unknown[]): Promise<boolean>\n  (classification: string, context: object): Promise<boolean>\n}\n```\n\n\n# list\n\nURL: https://primitives.org.ai/function/list\n\n> Generate a list of items\n\n\n\nGenerate a list of items. Supports streaming with async iteration.\n\n## Import\n\n```typescript\nimport { list } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nlist`prompt`\nlist`prompt`(options)\nfor await (const item of list`prompt`) { }\n```\n\n## Examples\n\n```typescript\n// Get all at once\nconst ideas = await list`startup ideas for ${industry}`\nconst tags = await list`tags for: ${articleContent}`\n\n// With count\nconst topTen = await list`10 blog post titles for ${topic}`\n\n// Stream items as generated\nfor await (const idea of list`startup ideas for ${industry}`) {\n  console.log(idea)\n}\n```\n\n## Streaming Pattern\n\nProcess items as they're generated:\n\n```typescript\nfor await (const idea of list`startup ideas for ${industry}`) {\n  const validation = await research`market size for ${idea}`\n\n  if (validation.marketSize > 1_000_000_000) {\n    console.log('Billion dollar idea:', idea)\n    break  // Early termination\n  }\n}\n```\n\n## Options\n\n| Option  | Type   | Description                 |\n| ------- | ------ | --------------------------- |\n| `count` | number | Number of items to generate |\n| `model` | string | Model to use                |\n\n## Use Cases\n\n```typescript\n// Brainstorming\nconst features = await list`features for ${product}`\nconst angles = await list`marketing angles for ${campaign}`\n\n// Content planning\nconst titles = await list`25 blog post titles for ${topic}`\nconst chapters = await list`chapters for book about ${subject}`\n\n// Research\nconst questions = await list`research questions about ${topic}`\nconst keywords = await list`SEO keywords for ${page}`\n```\n\n\n# lists\n\nURL: https://primitives.org.ai/function/lists\n\n> Generate multiple named lists at once\n\n\n\nGenerate multiple named lists at once.\n\n## Import\n\n```typescript\nimport { lists } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nlists`prompt`\nlists`prompt`(options)\n```\n\n## Examples\n\n```typescript\n// Tagged template\nconst { pros, cons } = await lists`pros and cons of ${topic}`\n\n// SWOT analysis\nconst { strengths, weaknesses, opportunities, threats } = await lists`\n  SWOT analysis for ${{ company, market, competitors }}\n`\n\n// Content gaps\nconst { existing, missing, opportunities } = await lists`\n  content gap analysis for ${{ topic, competitors }}\n`\n```\n\n## Use Cases\n\n```typescript\n// Decision making\nconst { reasons, risks } = await lists`\n  reasons to proceed and risks for ${decision}\n`\n\n// Competitive analysis\nconst { ourAdvantages, theirAdvantages } = await lists`\n  comparison of ${ourProduct} vs ${competitor}\n`\n\n// Planning\nconst { mustHave, niceToHave, outOfScope } = await lists`\n  requirements prioritization for ${project}\n`\n```\n\n## Return Type\n\nReturns an object with string arrays:\n\n```typescript\nconst result = await lists`pros and cons of ${topic}`\n// {\n//   pros: ['Pro 1', 'Pro 2', ...],\n//   cons: ['Con 1', 'Con 2', ...]\n// }\n```\n\n## vs Multiple list() Calls\n\n```typescript\n// These achieve similar results:\n\n// Single call - faster, contextual\nconst { pros, cons } = await lists`pros and cons of ${topic}`\n\n// Multiple calls - separate context\nconst pros = await list`pros of ${topic}`\nconst cons = await list`cons of ${topic}`\n```\n\nUse `lists` when items are related and should be generated together.\n\n\n# read\n\nURL: https://primitives.org.ai/function/read\n\n> Fetch and convert URL to markdown\n\n\n\nFetch and convert a URL to markdown. Powered by Firecrawl.\n\n## Import\n\n```typescript\nimport { read } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nread`${url}`\nread(url: string)\n```\n\n## Examples\n\n```typescript\n// Get markdown from URL\nconst article = await read`https://example.com/blog/post`\n\n// Process the content\nconst content = await read`${url}`\nconst summary = await summarize`${content}`\nconst keyPoints = await list`main takeaways from ${content}`\n```\n\n## Chaining\n\n```typescript\n// Read and process\nconst content = await read`${url}`\nconst summary = await summarize`${content}`\nconst isRelevant = await is`${content} relevant to ${topic}?`\n\n// Read multiple pages\nconst docs = await Promise.all([\n  read`https://docs.example.com/intro`,\n  read`https://docs.example.com/api`,\n  read`https://docs.example.com/examples`,\n])\nconst overview = await write`documentation overview based on ${docs}`\n```\n\n## vs browse\n\n| Function | Use Case                               |\n| -------- | -------------------------------------- |\n| `read`   | Static content, articles, docs         |\n| `browse` | Interactive pages, JavaScript-rendered |\n\n```typescript\n// Static content - use read\nconst article = await read`https://blog.example.com/post`\n\n// Interactive page - use browse\nconst page = await browse`https://app.example.com`\nconst data = await page.extract`pricing information`\n```\n\n\n# research\n\nURL: https://primitives.org.ai/function/research\n\n> Agentic web research and synthesis\n\n\n\nAgentic research that searches, reads, and synthesizes information.\n\n## Import\n\n```typescript\nimport { research } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nresearch`topic`\nresearch`topic`(options)\n```\n\n## Examples\n\n```typescript\n// Quick research\nconst findings = await research`${topic}`\n\n// With depth control\nconst deep = await research`market size for AI developer tools`({\n  depth: 'thorough',\n})\n\n// With context\nconst report = await research`competitor analysis for ${{ company, market }}`\n```\n\n## Return Type\n\n```typescript\ninterface Research {\n  summary: string           // Key findings\n  sources: Array<{\n    url: string\n    title: string\n    relevance: number\n  }>\n  findings: string[]        // Individual findings\n  confidence: number        // 0-1 confidence score\n}\n```\n\n## Options\n\n| Option    | Values                    | Description          |\n| --------- | ------------------------- | -------------------- |\n| `depth`   | `'quick'` \\| `'thorough'` | Research depth       |\n| `sources` | number                    | Max sources to check |\n| `model`   | string                    | Model for synthesis  |\n\n## Chaining\n\n```typescript\n// Research â†’ Content\nconst brand = await ai.storyBrand({ hero: 'developers', guide: 'our product' })\nconst marketResearch = await research`market validation for ${{ brand }}`\nconst pitch = await write`investor pitch based on ${{ brand, marketResearch }}`\n\n// Research â†’ Extract â†’ Research\nconst initial = await research`competitors in ${market}`\nfor await (const competitor of extract`company names from ${initial}`) {\n  const analysis = await research`${competitor} vs ${ourProduct}`\n}\n```\n\n\n# review\n\nURL: https://primitives.org.ai/function/review\n\n> Get detailed review and feedback from a human\n\n\n\nPause execution and wait for a structured human review with rating, feedback, and optional approval.\n\n## Import\n\n```typescript\nimport { review } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nreview`content to review`\nreview`content`(options)\n```\n\n## Examples\n\n```typescript\n// Simple review\nconst result = await review`\n  Blog Post Draft\n\n  ${blogPost}\n`\n\nconsole.log(result.approved)  // boolean\nconsole.log(result.rating)    // 1-5\nconsole.log(result.feedback)  // string\n\n// With options\nconst codeReview = await review`\n  Pull Request #${pr.number}\n\n  ${pr.diff}\n`({\n  assignTo: { role: 'senior-engineer' },\n  rubric: ['correctness', 'readability', 'performance'],\n})\n```\n\n## Options\n\n| Option            | Type         | Description               |\n| ----------------- | ------------ | ------------------------- |\n| `assignTo`        | `Assignment` | Who should review         |\n| `channel`         | `string`     | Notification channel      |\n| `timeout`         | `string`     | How long to wait          |\n| `rubric`          | `string[]`   | Categories to rate        |\n| `requireApproval` | `boolean`    | Include approval decision |\n\n## Returns\n\n```typescript\ninterface Review {\n  approved?: boolean      // If requireApproval is true\n  rating: number          // 1-5 overall rating\n  ratings?: Record<string, number>  // Per-rubric ratings\n  feedback: string        // Written feedback\n  reviewer: string        // Who reviewed\n  reviewedAt: Date        // When reviewed\n}\n```\n\n## When to Use\n\n* Content review (docs, blog posts, marketing)\n* Code review\n* Design review\n* Quality assurance\n* Any review needing detailed feedback\n\n\n# slides\n\nURL: https://primitives.org.ai/function/slides\n\n> Generate markdown-based presentations\n\n\n\nGenerate markdown-based presentations (Slidev, Marp, reveal.js).\n\n## Import\n\n```typescript\nimport { slides } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nslides`topic`\nslides`topic`(options)\nslides(topic: string, options?: SlideOptions)\n```\n\n## Examples\n\n```typescript\n// Quick presentation\nconst deck = await slides`${topic}`\n\n// With structure\nconst pitch = await slides`investor pitch for ${{ brand, market, traction }}`\n\n// With options\nconst presentation = await slides('quarterly review', {\n  format: 'slidev',\n  slides: 12,\n  style: 'minimal',\n})\n\n// With speaker notes\nconst workshop = await slides`TypeScript workshop${{\n  format: 'marp',\n  includeNotes: true,\n  duration: '2 hours',\n}}`\n```\n\n## Options\n\n| Option         | Type                                 | Description           |\n| -------------- | ------------------------------------ | --------------------- |\n| `format`       | `'slidev'` \\| `'marp'` \\| `'reveal'` | Output format         |\n| `slides`       | number                               | Number of slides      |\n| `style`        | string                               | Visual style          |\n| `includeNotes` | boolean                              | Include speaker notes |\n| `duration`     | string                               | Presentation duration |\n\n## From Research\n\n```typescript\nconst research = await research`AI market trends 2025`\nconst analysis = await lists`key insights from ${research}`\n\nconst deck = await slides`executive presentation${{\n  research,\n  analysis,\n  audience: 'board of directors',\n}}`\n```\n\n## Output Formats\n\n```typescript\n// Slidev (Vue-based)\nconst slidev = await slides`topic`({ format: 'slidev' })\n\n// Marp (Markdown-based)\nconst marp = await slides`topic`({ format: 'marp' })\n\n// reveal.js\nconst reveal = await slides`topic`({ format: 'reveal' })\n```\n\n\n# summarize\n\nURL: https://primitives.org.ai/function/summarize\n\n> Condense text to key points\n\n\n\nCondense text to its key points.\n\n## Import\n\n```typescript\nimport { summarize } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nsummarize`${text}`\nsummarize`${text}`(options)\n```\n\n## Examples\n\n```typescript\n// Quick summary\nconst summary = await summarize`${longArticle}`\n\n// With length control\nconst brief = await summarize`${document}`({ length: 'short' })   // 1-2 sentences\nconst detailed = await summarize`${document}`({ length: 'long' }) // paragraphs\n\n// For specific audience\nconst execSummary = await summarize`${technicalReport}${{\n  audience: 'executives',\n  focus: 'business impact',\n}}`\n```\n\n## Options\n\n| Option     | Values                              | Description       |\n| ---------- | ----------------------------------- | ----------------- |\n| `length`   | `'short'` \\| `'medium'` \\| `'long'` | Output length     |\n| `audience` | string                              | Target audience   |\n| `focus`    | string                              | What to emphasize |\n| `format`   | `'bullets'` \\| `'paragraph'`        | Output format     |\n\n## Combining with Other Functions\n\n```typescript\n// Summarize research results\nconst research = await research`AI market trends 2025`\nconst keyPoints = await summarize`${research}`\n\n// Chain with write\nconst article = await write`blog post about ${topic}`\nconst tldr = await summarize`${article}`({ length: 'short' })\n\n// Process multiple documents\nconst summaries = await Promise.all(\n  documents.map(doc => summarize`${doc}`({ length: 'short' }))\n)\nconst overview = await write`overview based on ${summaries}`\n```\n\n\n# video\n\nURL: https://primitives.org.ai/function/video\n\n> Generate videos from text descriptions\n\n\n\nGenerate videos from text descriptions.\n\n## Import\n\n```typescript\nimport { video } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nvideo`description`\nvideo`description`(options)\nvideo(description: string, options?: VideoOptions)\n```\n\n## Examples\n\n```typescript\n// Tagged template\nconst teaser = await video`product demo for ${productName}`\nconst explainer = await video`explain ${concept} with animations`\n\n// With options\nconst ad = await video('promotional video for SaaS product', {\n  duration: 30,\n  aspect: '16:9',\n  style: 'motion graphics',\n})\n\n// With detailed requirements\nconst tutorial = await video`coding tutorial${{\n  topic: 'Building REST APIs',\n  duration: 60,\n  style: 'screen recording with voiceover',\n  chapters: ['Setup', 'Routes', 'Testing'],\n}}`\n```\n\n## Options\n\n| Option     | Type                            | Description       |\n| ---------- | ------------------------------- | ----------------- |\n| `duration` | number                          | Length in seconds |\n| `aspect`   | `'16:9'` \\| `'9:16'` \\| `'1:1'` | Aspect ratio      |\n| `style`    | string                          | Visual style      |\n| `format`   | string                          | Output format     |\n\n## Use Cases\n\n```typescript\n// Social media\nconst teaser = await video`15 second teaser for ${product}${{\n  aspect: '9:16',  // Vertical for TikTok/Reels\n}}`\n\n// Marketing\nconst ad = await video`30 second ad for ${campaign}`\nconst demo = await video`product demo showing ${features}`\n\n// Content\nconst explainer = await video`explain ${concept} simply`\nconst intro = await video`channel intro for ${brand}`\n```\n\n## Return Type\n\nReturns a Buffer containing the video data:\n\n```typescript\nconst videoBuffer = await video`product demo`\nawait fs.writeFile('demo.mp4', videoBuffer)\n```\n\n\n# write\n\nURL: https://primitives.org.ai/function/write\n\n> Generate formatted text content\n\n\n\nGenerate text content with optional formatting and structure.\n\n## Import\n\n```typescript\nimport { write } from 'ai-functions'\n```\n\n## Syntax\n\n```typescript\nwrite`prompt with ${values}`\nwrite(type: string, context: object)\n```\n\n## Examples\n\n```typescript\n// Tagged template\nconst email = await write`professional email to ${recipient} about ${subject}`\nconst bio = await write`twitter bio for ${{ name, profession, interests }}`\n\n// With options\nconst post = await write('blog post', {\n  topic: 'TypeScript Best Practices',\n  length: 'medium',\n  tone: 'casual',\n})\n\n// Complex context\nconst article = await write`\n  technical blog post about ${topic}\n  ${{ tone: 'friendly but authoritative', length: '1500 words' }}\n`({ model: 'gemini-3-flash' })\n```\n\n## Content Types\n\n```typescript\n// Articles\nconst post = await write`blog post about ${topic}`\nconst article = await write`technical article on ${subject}`\n\n// Communications\nconst email = await write`professional email about ${matter}`\nconst message = await write`slack message announcing ${news}`\n\n// Social\nconst tweet = await write`tweet about ${topic}`\nconst bio = await write`linkedin bio for ${person}`\n\n// Marketing\nconst copy = await write`landing page copy for ${product}`\nconst tagline = await write`tagline for ${brand}`\n```\n\n## Options\n\n| Option     | Description                               |\n| ---------- | ----------------------------------------- |\n| `length`   | `'short'` \\| `'medium'` \\| `'long'`       |\n| `tone`     | `'formal'` \\| `'casual'` \\| `'technical'` |\n| `audience` | Target audience description               |\n| `format`   | Output format (markdown, plain, etc.)     |\n\n\n# Approvals\n\nURL: https://primitives.org.ai/human/approvals\n\n> Human approval gates in automated workflows\n\n\n\n# Approval Gates\n\nInsert human approval checkpoints into automated workflows for decisions that require accountability, judgment, or regulatory compliance.\n\n## Basic Approval\n\n```typescript\nimport { human } from 'human-in-the-loop'\n\nconst approval = human.approval({\n  name: 'manager-approval',\n  description: 'Manager must approve this request',\n  assignTo: { role: 'manager' },\n})\n\n// Use in workflow\nconst result = await approval.request({\n  context: { request: purchaseRequest },\n  timeout: '48h',\n})\n\nif (result.approved) {\n  await processRequest(purchaseRequest)\n} else {\n  await rejectRequest(purchaseRequest, result.reason)\n}\n```\n\n## Approval Configuration\n\n```typescript\nconst purchaseApproval = human.approval({\n  name: 'purchase-approval',\n  description: 'Approve purchase requests over $1000',\n\n  // Who can approve\n  assignTo: {\n    role: 'finance-approver',\n    minLevel: 3,  // Manager level 3+\n  },\n\n  // Alternative approvers\n  fallback: [\n    { after: '24h', assignTo: 'department-head' },\n    { after: '48h', assignTo: 'cfo' },\n  ],\n\n  // Context to show\n  showContext: ['request', 'budget', 'policy', 'history'],\n\n  // Required fields\n  require: {\n    decision: ['approve', 'reject', 'defer'],\n    reason: { when: 'decision = reject' },\n    notes: false,\n  },\n\n  // Timeout behavior\n  timeout: '72h',\n  onTimeout: 'escalate',  // 'escalate' | 'auto-approve' | 'auto-reject'\n})\n```\n\n## Dynamic Assignment\n\n```typescript\nconst dynamicApproval = human.approval({\n  name: 'expense-approval',\n\n  // Assign based on request attributes\n  assignTo: ({ input }) => {\n    if (input.amount > 10000) {\n      return { role: 'cfo' }\n    }\n    if (input.amount > 1000) {\n      return { role: 'finance-manager' }\n    }\n    return input.requester.manager\n  },\n\n  // Or use approval matrix\n  approvalMatrix: {\n    conditions: [\n      { amount: { gt: 10000 }, approver: 'cfo' },\n      { amount: { gt: 1000 }, approver: 'finance-manager' },\n      { category: 'travel', approver: 'travel-coordinator' },\n      { default: 'direct-manager' },\n    ],\n  },\n})\n```\n\n## Multi-Level Approval\n\n```typescript\nconst multiLevelApproval = human.approval({\n  name: 'contract-approval',\n\n  levels: [\n    {\n      name: 'legal-review',\n      assignTo: { role: 'legal-counsel' },\n      actions: ['approve', 'request-changes', 'reject'],\n    },\n    {\n      name: 'finance-approval',\n      assignTo: { role: 'finance-director' },\n      actions: ['approve', 'reject'],\n      requiresPrevious: true,\n    },\n    {\n      name: 'executive-approval',\n      assignTo: { role: 'ceo' },\n      when: 'value > 100000',\n      actions: ['approve', 'reject'],\n      requiresPrevious: true,\n    },\n  ],\n\n  // Approval mode\n  mode: 'sequential',  // 'sequential' | 'parallel' | 'any'\n})\n```\n\n## Parallel Approvals\n\n```typescript\nconst parallelApproval = human.approval({\n  name: 'cross-functional-approval',\n\n  approvers: [\n    { role: 'engineering-lead', required: true },\n    { role: 'product-manager', required: true },\n    { role: 'legal', required: false },\n  ],\n\n  mode: 'parallel',\n\n  // How to combine decisions\n  resolution: {\n    approve: 'all-required',  // All required must approve\n    reject: 'any',            // Any rejection rejects\n  },\n})\n```\n\n## Conditional Approval\n\n```typescript\nconst conditionalApproval = human.approval({\n  name: 'conditional-purchase',\n\n  // Only require approval when\n  when: [\n    'amount > 500',\n    'vendor.new = true',\n    'category = software',\n  ],\n\n  // Skip approval when\n  skip: [\n    'requester.level >= 5',\n    'preApproved = true',\n  ],\n\n  assignTo: { role: 'manager' },\n})\n```\n\n## Delegation\n\n```typescript\nconst delegatedApproval = human.approval({\n  name: 'delegatable-approval',\n\n  delegation: {\n    allowed: true,\n    maxDepth: 2,  // Can delegate to someone who delegates\n    preserveContext: true,\n    notifyOriginal: true,\n  },\n\n  // Delegate automatically when\n  autoDelegation: {\n    when: ['approver.outOfOffice = true'],\n    to: 'approver.delegate',\n  },\n})\n\n// Approver can delegate\nawait approval.delegate({\n  to: 'backup-approver@company.com',\n  reason: 'Out of office this week',\n  expires: nextMonday,\n})\n```\n\n## Approval with Modifications\n\n```typescript\nconst modifiableApproval = human.approval({\n  name: 'budget-approval',\n\n  actions: [\n    {\n      name: 'approve',\n      allowModifications: ['amount', 'timeline'],\n    },\n    {\n      name: 'approve-with-conditions',\n      requiresNotes: true,\n      addConditions: true,\n    },\n    {\n      name: 'reject',\n      requiresReason: true,\n    },\n  ],\n})\n\n// Approver can modify\nconst result = await approval.request({ budget })\n\nif (result.action === 'approve') {\n  // May have modifications\n  budget.amount = result.modifications?.amount ?? budget.amount\n}\n```\n\n## Approval Workflow Integration\n\n```typescript\nimport { workflow } from 'ai-workflows'\n\nconst purchaseWorkflow = workflow({\n  name: 'purchase-request',\n\n  execute: async (ctx, request) => {\n    // Validate request\n    await step('validate', () => validateRequest(request))\n\n    // Check budget\n    const budget = await step('check-budget', () => checkBudget(request))\n\n    // Human approval gate\n    const approval = await step('approve', () =>\n      human.approval({\n        name: 'manager-approval',\n        assignTo: request.requester.manager,\n        showContext: { request, budget },\n        timeout: '48h',\n      }).request()\n    )\n\n    if (!approval.approved) {\n      await step('notify-rejection', () =>\n        notifyRequester(request, approval.reason)\n      )\n      return { status: 'rejected', reason: approval.reason }\n    }\n\n    // Process approved request\n    await step('process', () => processRequest(request))\n\n    return { status: 'approved', processedAt: new Date() }\n  },\n})\n```\n\n## Approval UI\n\n```typescript\nconst approvalForm = human.approval({\n  name: 'visual-approval',\n\n  ui: {\n    layout: 'card',\n    sections: [\n      {\n        title: 'Request Summary',\n        fields: ['amount', 'category', 'description'],\n        highlight: ['amount'],\n      },\n      {\n        title: 'Policy Check',\n        type: 'checklist',\n        items: [\n          'Within budget guidelines',\n          'Approved vendor',\n          'Business justification provided',\n        ],\n      },\n      {\n        title: 'Previous Approvals',\n        type: 'history',\n        source: 'context.approvalHistory',\n      },\n    ],\n    actions: {\n      approve: { color: 'green', icon: 'check' },\n      reject: { color: 'red', icon: 'x' },\n    },\n  },\n})\n```\n\n## Notifications\n\n```typescript\nconst approvalWithNotifications = human.approval({\n  name: 'notified-approval',\n\n  notifications: {\n    // When approval is requested\n    onRequest: {\n      channels: ['email', 'slack'],\n      template: 'approval-request',\n    },\n\n    // Reminders\n    remind: [\n      { after: '24h', channels: ['slack'] },\n      { after: '48h', channels: ['email', 'slack'] },\n    ],\n\n    // When decision is made\n    onDecision: {\n      notify: ['requester', 'cc-list'],\n      channels: ['email'],\n    },\n  },\n})\n```\n\n## Audit Trail\n\n```typescript\n// All approvals are logged\nconst auditLog = await human.getApprovalAudit({\n  approval: 'purchase-approval',\n  period: 'last-30-days',\n})\n\nauditLog.forEach((entry) => {\n  console.log(entry.requestId)\n  console.log(entry.approver)\n  console.log(entry.decision)\n  console.log(entry.timestamp)\n  console.log(entry.reason)\n})\n```\n\n## Best Practices\n\n1. **Clear context** - Show approvers everything they need\n2. **Appropriate timeouts** - Balance urgency with thoroughness\n3. **Escalation paths** - Don't let requests get stuck\n4. **Audit everything** - Maintain compliance trail\n5. **Delegation support** - Handle vacations and absences\n6. **Mobile-friendly** - Enable approvals on the go\n\n\n# Collaboration\n\nURL: https://primitives.org.ai/human/collaboration\n\n> Human and AI working together effectively\n\n\n\n# Human + AI Collaboration\n\nThe best outcomes come from humans and AI working together, each contributing their unique strengths.\n\n## Assisted Work\n\n### AI-Assisted Human Work\n\n```typescript\nimport { human } from 'human-in-the-loop'\n\nconst assistedReview = human.assisted({\n  name: 'ai-assisted-review',\n\n  // AI provides assistance\n  aiAssist: {\n    suggestions: true,       // Suggest responses\n    autoComplete: true,      // Complete sentences\n    factCheck: true,         // Verify claims\n    grammarCheck: true,      // Check grammar\n    similarCases: true,      // Show similar past cases\n    nextSteps: true,         // Suggest next actions\n  },\n\n  // Human makes final decisions\n  humanDecides: {\n    finalApproval: true,\n    edits: true,\n    escalation: true,\n  },\n})\n```\n\n### Suggestion System\n\n```typescript\nconst suggestiveTask = human.task({\n  name: 'suggested-response',\n\n  aiSuggestions: {\n    // Generate response suggestions\n    responses: {\n      count: 3,\n      style: 'professional',\n      tone: 'context.customerSentiment',\n    },\n\n    // Suggest actions\n    actions: {\n      enabled: true,\n      confidence: 0.7,  // Only show above this confidence\n    },\n\n    // Highlight key information\n    highlights: {\n      entities: true,\n      dates: true,\n      amounts: true,\n      requirements: true,\n    },\n  },\n})\n```\n\n## Feedback Loops\n\n### Learning from Human Edits\n\n```typescript\nconst learningTask = human.task({\n  name: 'learning-from-edits',\n\n  feedback: {\n    // Capture when human edits AI output\n    captureEdits: true,\n\n    // Track acceptance/rejection\n    captureDecisions: true,\n\n    // Ask for explicit feedback\n    collectFeedback: {\n      enabled: true,\n      frequency: 'always',  // 'always' | 'sample' | 'on-reject'\n      questions: [\n        'Was the AI suggestion helpful?',\n        'What could be improved?',\n      ],\n    },\n\n    // Send to training pipeline\n    feedTo: 'ai-improvement-pipeline',\n  },\n})\n```\n\n### Correction Handling\n\n```typescript\nconst correctableTask = human.task({\n  name: 'correctable',\n\n  corrections: {\n    // Track what was changed\n    trackChanges: true,\n\n    // Categorize corrections\n    categories: [\n      'factual-error',\n      'tone-adjustment',\n      'missing-information',\n      'policy-compliance',\n      'formatting',\n    ],\n\n    // Learn from patterns\n    analyze: {\n      enabled: true,\n      minSamples: 100,\n      reportTo: 'ai-team',\n    },\n  },\n})\n```\n\n## Handoffs\n\n### AI to Human\n\n```typescript\nimport { workflow } from 'ai-workflows'\n\nconst supportFlow = workflow({\n  name: 'ai-first-support',\n\n  execute: async (ctx, ticket) => {\n    // AI attempts resolution\n    const aiResponse = await step('ai-attempt', () =>\n      aiSupport.handle(ticket)\n    )\n\n    // Check if handoff needed\n    if (aiResponse.confidence < 0.7 || aiResponse.needsHuman) {\n      // Hand off to human\n      const humanResult = await step('human-support', () =>\n        human.task({\n          name: 'support-handoff',\n          assignTo: { role: 'support-agent' },\n\n          // Provide AI context\n          context: {\n            aiAnalysis: aiResponse.analysis,\n            suggestedResponse: aiResponse.suggestion,\n            confidence: aiResponse.confidence,\n            reasoning: aiResponse.reasoning,\n          },\n        }).request()\n      )\n\n      return humanResult\n    }\n\n    return aiResponse\n  },\n})\n```\n\n### Human to AI\n\n```typescript\nconst delegatingTask = human.task({\n  name: 'delegating-task',\n\n  // Human can delegate to AI\n  delegation: {\n    toAI: {\n      enabled: true,\n      tasks: ['research', 'summarize', 'format', 'translate'],\n    },\n  },\n\n  // UI for delegation\n  ui: {\n    showDelegateButton: true,\n    delegateOptions: [\n      { action: 'research', label: 'Research this topic' },\n      { action: 'summarize', label: 'Summarize document' },\n      { action: 'draft', label: 'Draft a response' },\n    ],\n  },\n})\n```\n\n## Co-Pilot Mode\n\n```typescript\nconst coPilot = human.coPilot({\n  name: 'writing-copilot',\n\n  // Real-time assistance\n  realtime: {\n    suggestions: true,\n    completion: true,\n    correction: true,\n  },\n\n  // Context awareness\n  context: {\n    document: true,\n    history: true,\n    style: 'context.brandVoice',\n  },\n\n  // Controls\n  controls: {\n    toggleAssist: true,\n    adjustConfidence: true,\n    chooseStyle: true,\n  },\n})\n```\n\n## Collaborative Editing\n\n```typescript\nconst collaborativeDoc = human.collaborative({\n  name: 'collaborative-document',\n\n  participants: {\n    humans: ['editor', 'reviewer'],\n    ai: ['assistant', 'fact-checker'],\n  },\n\n  // Who can do what\n  roles: {\n    editor: { edit: true, approve: true },\n    reviewer: { comment: true, suggest: true },\n    assistant: { suggest: true, format: true },\n    'fact-checker': { annotate: true, flag: true },\n  },\n\n  // Real-time collaboration\n  realtime: true,\n  showCursors: true,\n  showTyping: true,\n})\n```\n\n## Intelligent Triage\n\n```typescript\nconst intelligentTriage = workflow({\n  name: 'intelligent-triage',\n\n  execute: async (ctx, items) => {\n    // AI categorizes and prioritizes\n    const triaged = await step('ai-triage', () =>\n      aiTriage.process(items)\n    )\n\n    // Group by confidence\n    const confident = triaged.filter((i) => i.confidence > 0.9)\n    const uncertain = triaged.filter((i) => i.confidence <= 0.9)\n\n    // AI handles confident cases\n    await step('ai-process', () =>\n      Promise.all(confident.map(processAutomatically))\n    )\n\n    // Humans review uncertain cases\n    await step('human-review', () =>\n      human.task({\n        name: 'triage-review',\n        items: uncertain,\n        showAiRecommendation: true,\n      }).request()\n    )\n  },\n})\n```\n\n## Quality Assurance\n\n```typescript\nconst qaWorkflow = workflow({\n  name: 'human-ai-qa',\n\n  execute: async (ctx, content) => {\n    // AI performs initial QA\n    const aiQA = await step('ai-qa', () =>\n      aiQualityCheck.check(content)\n    )\n\n    // Human reviews AI findings\n    const humanReview = await step('human-qa', () =>\n      human.task({\n        name: 'qa-review',\n        context: {\n          content,\n          aiFindings: aiQA.issues,\n          aiConfidence: aiQA.confidence,\n        },\n        actions: ['confirm', 'override', 'add-issue'],\n      }).request()\n    )\n\n    // Combine AI and human findings\n    const allIssues = combineFindings(aiQA.issues, humanReview.additions)\n\n    return { issues: allIssues, reviewed: true }\n  },\n})\n```\n\n## Training Humans\n\n```typescript\nconst trainingTask = human.task({\n  name: 'training-mode',\n\n  training: {\n    enabled: true,\n\n    // Show correct answers after submission\n    showCorrectAnswer: true,\n\n    // Explain AI reasoning\n    explainReasoning: true,\n\n    // Track learning progress\n    trackProgress: true,\n\n    // Adjust difficulty\n    adaptiveDifficulty: true,\n  },\n})\n```\n\n## Metrics and Analytics\n\n```typescript\nconst collaborationMetrics = await human.getCollaborationMetrics({\n  period: 'last-30-days',\n})\n\nconsole.log(collaborationMetrics)\n// {\n//   aiSuggestionsAccepted: 0.72,\n//   aiSuggestionsEdited: 0.18,\n//   aiSuggestionsRejected: 0.10,\n//   humanCorrections: {\n//     total: 450,\n//     byCategory: { 'tone': 150, 'factual': 100, ... },\n//   },\n//   escalationRate: 0.15,\n//   avgResolutionTime: {\n//     aiOnly: '5m',\n//     humanOnly: '25m',\n//     collaborative: '12m',\n//   },\n//   satisfaction: {\n//     aiOnly: 4.2,\n//     humanOnly: 4.5,\n//     collaborative: 4.7,\n//   },\n// }\n```\n\n## Best Practices\n\n1. **Clear roles** - Define what AI vs human handles\n2. **Seamless handoffs** - Include full context\n3. **Learn from feedback** - Improve AI from corrections\n4. **Trust indicators** - Show AI confidence levels\n5. **Override capability** - Humans can always override\n6. **Measure outcomes** - Track collaborative effectiveness\n\n\n# Human\n\nURL: https://primitives.org.ai/human\n\n> Human-in-the-loop integration for approvals, reviews, creative work, and judgment calls\n\n\n\nFirst-class support for human participation in AI-powered workflows. Not everything can or should be automatedâ€”humans bring judgment, creativity, empathy, and accountability that AI cannot replicate.\n\n## Why Human-in-the-Loop?\n\nSome tasks inherently require human involvement:\n\n* **Judgment calls**: Decisions with ethical, legal, or strategic implications\n* **Creative work**: Writing, design, and ideation that requires human creativity\n* **Approvals**: Sign-offs that carry accountability\n* **Edge cases**: Situations AI hasn't been trained to handle\n* **Quality assurance**: Final verification of AI-generated outputs\n* **Relationship management**: Interactions requiring empathy and nuance\n\n```typescript\nimport { human, approval, review } from 'human-in-the-loop'\n\nconst humanReview = human({\n  name: 'content-review',\n\n  task: {\n    description: 'Review AI-generated content for accuracy and tone',\n    estimatedTime: '10m',\n    skills: ['content-writing', 'brand-guidelines'],\n  },\n\n  input: z.object({\n    content: z.string(),\n    context: z.string(),\n    targetAudience: z.string(),\n  }),\n\n  output: z.object({\n    approved: z.boolean(),\n    edits: z.string().optional(),\n    feedback: z.string(),\n  }),\n\n  ui: 'content-review-form',\n})\n```\n\n## Integration Points\n\n### Approval Gates\n\nInsert human approvals into workflows:\n\n```typescript\nconst purchaseWorkflow = workflow({\n  name: 'purchase-approval',\n\n  steps: [\n    validateRequest,\n    checkBudget,\n\n    // Human approval gate\n    human.approval({\n      name: 'manager-approval',\n      assignTo: ({ input }) => input.requester.manager,\n      showContext: ['request', 'budgetStatus'],\n      timeout: '48h',\n      escalateTo: 'department-head',\n    }),\n\n    processPayment,\n    notifyVendor,\n  ],\n})\n```\n\n### Review Cycles\n\nHumans review and refine AI outputs:\n\n```typescript\nconst contentPipeline = workflow({\n  name: 'content-creation',\n\n  steps: [\n    // AI generates draft\n    generateDraft,\n\n    // Human reviews\n    human.review({\n      name: 'editorial-review',\n      assignTo: { role: 'editor' },\n      actions: ['approve', 'request-changes', 'reject'],\n      onRequestChanges: (feedback) => regenerateDraft(feedback),\n      maxIterations: 3,\n    }),\n\n    // Final human sign-off\n    human.approval({\n      name: 'final-approval',\n      assignTo: { role: 'content-lead' },\n    }),\n\n    publish,\n  ],\n})\n```\n\n### Escalation Paths\n\nAI handles routine cases, humans handle exceptions:\n\n```typescript\nconst supportFlow = workflow({\n  name: 'customer-support',\n\n  steps: [\n    classifyTicket,\n    attemptAutoResponse,\n\n    human.escalation({\n      when: [\n        'confidence < 0.7',\n        'sentiment = negative',\n        'topic in [refund, complaint, legal]',\n        'customer.tier = enterprise',\n      ],\n      assignTo: { role: 'support-specialist' },\n      context: ['conversation', 'customerProfile', 'aiAnalysis'],\n    }),\n  ],\n})\n```\n\n## Human Interfaces\n\nDefine how humans interact with tasks:\n\n### Forms\n\n```typescript\nconst approvalForm = human.form({\n  name: 'expense-approval',\n\n  fields: [\n    { name: 'decision', type: 'select', options: ['approve', 'reject', 'request-info'] },\n    { name: 'notes', type: 'textarea', required: false },\n    { name: 'adjustedAmount', type: 'number', showWhen: 'decision === approve' },\n  ],\n\n  context: {\n    show: ['expense', 'policy', 'history'],\n    highlight: ['amount', 'category', 'requester'],\n  },\n})\n```\n\n### Workspaces\n\n```typescript\nconst reviewWorkspace = human.workspace({\n  name: 'document-review',\n\n  layout: 'split-view',\n  panels: [\n    { type: 'document-viewer', source: 'input.document' },\n    { type: 'annotation-tools' },\n    { type: 'ai-suggestions', source: 'context.suggestions' },\n    { type: 'decision-form', form: reviewDecisionForm },\n  ],\n})\n```\n\n## Assignment and Routing\n\n### Skills-Based Routing\n\n```typescript\nconst skillRouting = human.routing({\n  strategy: 'skills-match',\n\n  skills: {\n    required: ['customer-service'],\n    preferred: ['product-knowledge', 'technical-support'],\n  },\n\n  factors: {\n    availability: 0.4,\n    expertise: 0.3,\n    workload: 0.2,\n    performance: 0.1,\n  },\n})\n```\n\n### Queue Management\n\n```typescript\nconst humanQueue = human.queue({\n  name: 'review-queue',\n\n  prioritization: [\n    { condition: 'deadline < 1h', boost: 3 },\n    { condition: 'customer.tier = enterprise', boost: 2 },\n    { condition: 'type = escalation', boost: 1.5 },\n  ],\n\n  fairness: {\n    maxTasksPerPerson: 10,\n    rotateAfter: '2h',\n    breakReminders: true,\n  },\n})\n```\n\n## Quality and Feedback\n\n### Feedback Loops\n\n```typescript\nconst feedbackLoop = human.feedback({\n  collect: {\n    afterCompletion: true,\n    sampleRate: 0.2,  // 20% of tasks\n    questions: [\n      'Was the AI-provided context helpful?',\n      'How could the task be improved?',\n    ],\n  },\n\n  improve: {\n    shareWith: 'ai-training-pipeline',\n    updatePrompts: true,\n    adjustRouting: true,\n  },\n})\n```\n\n### Performance Tracking\n\n```typescript\nconst metrics = await human.getMetrics({\n  period: 'last-30-days',\n  include: [\n    'avgResponseTime',\n    'accuracy',\n    'throughput',\n    'satisfaction',\n  ],\n})\n```\n\n## Human + AI Collaboration\n\nThe best outcomes come from humans and AI working together:\n\n```typescript\nconst collaborativeReview = workflow({\n  name: 'collaborative-review',\n\n  steps: [\n    // AI does initial analysis\n    aiAnalysis,\n\n    // Human reviews with AI assistance\n    human.assisted({\n      name: 'assisted-review',\n      aiAssist: {\n        suggestions: true,\n        autoComplete: true,\n        factCheck: true,\n        similarCases: true,\n      },\n      humanDecides: {\n        finalApproval: true,\n        edits: true,\n        escalation: true,\n      },\n    }),\n  ],\n})\n```\n\n## Availability and Scheduling\n\n```typescript\nconst scheduling = human.schedule({\n  workingHours: {\n    timezone: 'America/New_York',\n    hours: '9:00-17:00',\n    days: ['mon', 'tue', 'wed', 'thu', 'fri'],\n  },\n\n  outOfHours: {\n    queue: true,\n    fallback: 'on-call-team',\n    urgent: 'page-on-call',\n  },\n\n  capacity: {\n    targetUtilization: 0.8,\n    bufferForUrgent: 0.1,\n  },\n})\n```\n\n\n# Interfaces\n\nURL: https://primitives.org.ai/human/interfaces\n\n> Forms, workspaces, and UI for human tasks\n\n\n\n# Human Interfaces\n\nDefine how humans interact with tasks through forms, workspaces, and custom UI components.\n\n## Forms\n\n### Basic Form\n\n```typescript\nimport { human } from 'human-in-the-loop'\n\nconst approvalForm = human.form({\n  name: 'expense-approval',\n\n  fields: [\n    {\n      name: 'decision',\n      type: 'select',\n      options: ['approve', 'reject', 'request-more-info'],\n      required: true,\n    },\n    {\n      name: 'notes',\n      type: 'textarea',\n      placeholder: 'Add any notes...',\n      required: false,\n    },\n  ],\n})\n```\n\n### Field Types\n\n```typescript\nconst comprehensiveForm = human.form({\n  name: 'detailed-form',\n\n  fields: [\n    // Text inputs\n    { name: 'title', type: 'text', maxLength: 100 },\n    { name: 'description', type: 'textarea', rows: 4 },\n    { name: 'email', type: 'email' },\n    { name: 'phone', type: 'phone' },\n    { name: 'url', type: 'url' },\n\n    // Numbers\n    { name: 'amount', type: 'number', min: 0, max: 10000 },\n    { name: 'rating', type: 'rating', scale: 5 },\n    { name: 'slider', type: 'slider', min: 0, max: 100, step: 10 },\n\n    // Selection\n    { name: 'category', type: 'select', options: ['A', 'B', 'C'] },\n    { name: 'tags', type: 'multiselect', options: ['tag1', 'tag2', 'tag3'] },\n    { name: 'priority', type: 'radio', options: ['low', 'medium', 'high'] },\n    { name: 'features', type: 'checkbox', options: ['f1', 'f2', 'f3'] },\n\n    // Date/Time\n    { name: 'dueDate', type: 'date' },\n    { name: 'meetingTime', type: 'datetime' },\n    { name: 'duration', type: 'duration' },\n\n    // Files\n    { name: 'attachment', type: 'file', accept: '.pdf,.doc' },\n    { name: 'images', type: 'files', accept: 'image/*', maxFiles: 5 },\n\n    // Rich content\n    { name: 'content', type: 'richtext' },\n    { name: 'code', type: 'code', language: 'typescript' },\n    { name: 'markdown', type: 'markdown' },\n\n    // Special\n    { name: 'signature', type: 'signature' },\n    { name: 'location', type: 'location' },\n  ],\n})\n```\n\n### Conditional Fields\n\n```typescript\nconst conditionalForm = human.form({\n  name: 'conditional-form',\n\n  fields: [\n    {\n      name: 'decision',\n      type: 'select',\n      options: ['approve', 'reject', 'defer'],\n    },\n    {\n      name: 'reason',\n      type: 'textarea',\n      showWhen: 'decision === \"reject\"',\n      required: { when: 'decision === \"reject\"' },\n    },\n    {\n      name: 'deferUntil',\n      type: 'date',\n      showWhen: 'decision === \"defer\"',\n    },\n    {\n      name: 'adjustedAmount',\n      type: 'number',\n      showWhen: 'decision === \"approve\"',\n      label: 'Adjusted Amount (optional)',\n    },\n  ],\n})\n```\n\n### Form Validation\n\n```typescript\nconst validatedForm = human.form({\n  name: 'validated-form',\n\n  fields: [\n    {\n      name: 'email',\n      type: 'email',\n      required: true,\n      validation: {\n        pattern: /^[\\w-\\.]+@company\\.com$/,\n        message: 'Must be a company email',\n      },\n    },\n    {\n      name: 'amount',\n      type: 'number',\n      validation: {\n        min: 0,\n        max: { value: 'context.budget', message: 'Exceeds budget' },\n        custom: (value, form) =>\n          value > form.previousAmount ? 'Cannot increase amount' : null,\n      },\n    },\n  ],\n\n  // Form-level validation\n  validate: (values) => {\n    const errors = {}\n    if (values.endDate < values.startDate) {\n      errors.endDate = 'End date must be after start date'\n    }\n    return errors\n  },\n})\n```\n\n## Workspaces\n\n### Basic Workspace\n\n```typescript\nconst reviewWorkspace = human.workspace({\n  name: 'document-review',\n\n  layout: 'split-view',\n\n  panels: [\n    {\n      type: 'document-viewer',\n      source: 'input.document',\n      position: 'left',\n    },\n    {\n      type: 'form',\n      form: reviewForm,\n      position: 'right',\n    },\n  ],\n})\n```\n\n### Multi-Panel Workspace\n\n```typescript\nconst analysisWorkspace = human.workspace({\n  name: 'data-analysis',\n\n  layout: 'grid',\n\n  panels: [\n    {\n      id: 'data',\n      type: 'data-table',\n      source: 'input.dataset',\n      position: { row: 1, col: 1, colspan: 2 },\n      features: ['sort', 'filter', 'search'],\n    },\n    {\n      id: 'chart',\n      type: 'chart',\n      source: 'input.dataset',\n      chartType: 'auto',\n      position: { row: 1, col: 3 },\n    },\n    {\n      id: 'suggestions',\n      type: 'ai-suggestions',\n      source: 'context.analysis',\n      position: { row: 2, col: 1 },\n    },\n    {\n      id: 'notes',\n      type: 'notes',\n      position: { row: 2, col: 2 },\n    },\n    {\n      id: 'decision',\n      type: 'form',\n      form: decisionForm,\n      position: { row: 2, col: 3 },\n    },\n  ],\n})\n```\n\n### Panel Types\n\n```typescript\nconst panels = [\n  // Content viewers\n  { type: 'document-viewer', source: 'input.doc' },\n  { type: 'pdf-viewer', source: 'input.pdf' },\n  { type: 'image-viewer', source: 'input.images' },\n  { type: 'code-viewer', source: 'input.code', language: 'typescript' },\n  { type: 'diff-viewer', source: { old: 'input.old', new: 'input.new' } },\n\n  // Data display\n  { type: 'data-table', source: 'input.data' },\n  { type: 'chart', source: 'input.metrics', chartType: 'line' },\n  { type: 'json-viewer', source: 'input.json' },\n  { type: 'timeline', source: 'input.events' },\n\n  // Interactive\n  { type: 'form', form: myForm },\n  { type: 'annotation-tools' },\n  { type: 'drawing-canvas' },\n  { type: 'notes' },\n\n  // AI assistance\n  { type: 'ai-suggestions', source: 'context.suggestions' },\n  { type: 'ai-chat', agent: 'assistant' },\n  { type: 'similar-items', source: 'context.similar' },\n\n  // Context\n  { type: 'context-panel', source: 'context' },\n  { type: 'history', source: 'context.history' },\n  { type: 'related-items', source: 'context.related' },\n]\n```\n\n## Context Display\n\n### Showing Context\n\n```typescript\nconst contextualTask = human.task({\n  name: 'contextual-review',\n\n  context: {\n    // What to show\n    show: ['request', 'customer', 'history', 'policy'],\n\n    // How to display\n    display: {\n      request: { panel: 'main', highlight: ['amount', 'category'] },\n      customer: { panel: 'sidebar', compact: true },\n      history: { panel: 'bottom', type: 'timeline' },\n      policy: { panel: 'collapsible', expanded: false },\n    },\n  },\n})\n```\n\n### Context Sections\n\n```typescript\nconst structuredContext = human.task({\n  name: 'structured-context',\n\n  context: {\n    sections: [\n      {\n        title: 'Request Details',\n        source: 'input.request',\n        display: 'card',\n        fields: ['id', 'amount', 'category', 'description'],\n      },\n      {\n        title: 'Customer Profile',\n        source: 'context.customer',\n        display: 'profile',\n        compact: true,\n      },\n      {\n        title: 'Similar Past Requests',\n        source: 'context.similar',\n        display: 'list',\n        maxItems: 5,\n      },\n      {\n        title: 'AI Analysis',\n        source: 'context.aiAnalysis',\n        display: 'formatted',\n        highlight: ['recommendation', 'confidence'],\n      },\n    ],\n  },\n})\n```\n\n## Custom Components\n\n```typescript\nimport { registerComponent } from 'human-in-the-loop'\n\n// Register custom component\nregisterComponent({\n  name: 'custom-rating',\n\n  props: {\n    value: { type: 'number' },\n    max: { type: 'number', default: 5 },\n    labels: { type: 'array' },\n  },\n\n  render: ({ value, max, labels, onChange }) => (\n    <div className=\"rating\">\n      {Array.from({ length: max }, (_, i) => (\n        <button\n          key={i}\n          className={i < value ? 'active' : ''}\n          onClick={() => onChange(i + 1)}\n        >\n          {labels?.[i] || i + 1}\n        </button>\n      ))}\n    </div>\n  ),\n})\n\n// Use in form\nconst form = human.form({\n  fields: [\n    {\n      name: 'satisfaction',\n      type: 'custom-rating',\n      max: 5,\n      labels: ['Poor', 'Fair', 'Good', 'Great', 'Excellent'],\n    },\n  ],\n})\n```\n\n## Themes and Styling\n\n```typescript\nconst styledTask = human.task({\n  name: 'styled-task',\n\n  ui: {\n    theme: 'light',  // 'light' | 'dark' | 'auto'\n\n    styles: {\n      primaryColor: '#0066cc',\n      accentColor: '#00cc66',\n      fontFamily: 'Inter, sans-serif',\n    },\n\n    branding: {\n      logo: 'https://company.com/logo.png',\n      title: 'Company Review Portal',\n    },\n  },\n})\n```\n\n## Mobile Support\n\n```typescript\nconst mobileTask = human.task({\n  name: 'mobile-friendly',\n\n  ui: {\n    responsive: true,\n\n    mobile: {\n      layout: 'stack',  // Stack panels vertically\n      simplify: true,   // Use simplified controls\n      offlineSupport: true,\n    },\n\n    tablet: {\n      layout: 'sidebar',\n    },\n\n    desktop: {\n      layout: 'grid',\n    },\n  },\n})\n```\n\n## Best Practices\n\n1. **Keep forms simple** - Only ask for necessary information\n2. **Smart defaults** - Pre-fill when possible\n3. **Clear validation** - Immediate, helpful error messages\n4. **Responsive design** - Support all device sizes\n5. **Show context** - Give humans the information they need\n6. **Progress indication** - Show form completion status\n\n\n# Reviews\n\nURL: https://primitives.org.ai/human/reviews\n\n> Human review cycles for AI outputs and quality assurance\n\n\n\n# Review Cycles\n\nHuman review enables quality assurance, feedback loops, and iterative refinement of AI-generated outputs.\n\n## Basic Review\n\n```typescript\nimport { human } from 'human-in-the-loop'\n\nconst review = human.review({\n  name: 'content-review',\n  description: 'Review AI-generated content',\n  assignTo: { role: 'editor' },\n\n  actions: ['approve', 'request-changes', 'reject'],\n})\n\nconst result = await review.request({\n  content: aiGeneratedContent,\n  context: { targetAudience, guidelines },\n})\n```\n\n## Review Configuration\n\n```typescript\nconst contentReview = human.review({\n  name: 'editorial-review',\n\n  // What to review\n  subject: 'content',\n  displayAs: 'document',\n\n  // Who reviews\n  assignTo: {\n    role: 'editor',\n    skills: ['content-writing', 'brand-guidelines'],\n  },\n\n  // Available actions\n  actions: [\n    {\n      name: 'approve',\n      description: 'Content is ready to publish',\n    },\n    {\n      name: 'approve-with-edits',\n      description: 'Minor edits made, ready to publish',\n      allowsEdits: true,\n    },\n    {\n      name: 'request-changes',\n      description: 'Significant changes needed',\n      requiresFeedback: true,\n    },\n    {\n      name: 'reject',\n      description: 'Content does not meet standards',\n      requiresReason: true,\n    },\n  ],\n\n  // Review criteria\n  criteria: [\n    'Accuracy of information',\n    'Adherence to brand voice',\n    'Grammar and spelling',\n    'Appropriateness for audience',\n  ],\n})\n```\n\n## Iterative Review\n\n```typescript\nconst iterativeReview = human.review({\n  name: 'iterative-content-review',\n\n  // Allow multiple rounds\n  maxIterations: 3,\n\n  onRequestChanges: async (feedback, iteration) => {\n    // Regenerate content based on feedback\n    const revised = await regenerateContent({\n      original: feedback.original,\n      feedback: feedback.comments,\n      iteration,\n    })\n\n    // Submit for re-review\n    return revised\n  },\n\n  onMaxIterations: 'escalate',  // 'escalate' | 'reject' | 'approve-as-is'\n})\n```\n\n## Multi-Reviewer\n\n```typescript\nconst multiReview = human.review({\n  name: 'peer-review',\n\n  reviewers: [\n    { role: 'technical-reviewer', weight: 0.5 },\n    { role: 'editorial-reviewer', weight: 0.3 },\n    { role: 'subject-expert', weight: 0.2 },\n  ],\n\n  // How many must review\n  requireReviews: 2,\n\n  // How to combine decisions\n  consensus: {\n    approve: 'majority',   // 'majority' | 'all' | 'any'\n    reject: 'any',\n  },\n})\n```\n\n## Review Workflow\n\n```typescript\nimport { workflow } from 'ai-workflows'\n\nconst contentPipeline = workflow({\n  name: 'content-creation',\n\n  execute: async (ctx, brief) => {\n    // AI generates draft\n    const draft = await step('generate', () =>\n      generateContent(brief)\n    )\n\n    // First review: Editorial\n    const editorial = await step('editorial-review', () =>\n      human.review({\n        name: 'editorial',\n        assignTo: { role: 'editor' },\n        subject: draft,\n      }).request()\n    )\n\n    let content = editorial.approved ? editorial.content : draft\n\n    // Handle changes if requested\n    while (!editorial.approved && editorial.action === 'request-changes') {\n      content = await step('revise', () =>\n        reviseContent(content, editorial.feedback)\n      )\n\n      editorial = await step('re-review', () =>\n        human.review({\n          name: 'editorial',\n          assignTo: { role: 'editor' },\n          subject: content,\n        }).request()\n      )\n    }\n\n    // Final approval\n    const final = await step('final-approval', () =>\n      human.approval({\n        name: 'publish-approval',\n        assignTo: { role: 'content-lead' },\n        context: { content, reviewHistory: editorial },\n      }).request()\n    )\n\n    if (final.approved) {\n      await step('publish', () => publishContent(content))\n    }\n\n    return { status: final.approved ? 'published' : 'rejected' }\n  },\n})\n```\n\n## Review with Annotations\n\n```typescript\nconst annotatedReview = human.review({\n  name: 'document-review',\n\n  // Enable inline annotations\n  annotations: {\n    enabled: true,\n    types: ['comment', 'suggestion', 'highlight', 'strikethrough'],\n  },\n\n  // UI configuration\n  ui: {\n    layout: 'split-view',\n    panels: [\n      { type: 'document-viewer', annotations: true },\n      { type: 'annotation-sidebar' },\n      { type: 'review-form' },\n    ],\n  },\n})\n\n// Access annotations in result\nconst result = await annotatedReview.request({ document })\nconsole.log(result.annotations)\n// [\n//   { type: 'comment', position: { start: 100, end: 150 }, text: 'Clarify this' },\n//   { type: 'suggestion', position: { start: 200, end: 220 }, suggestion: 'Better wording' },\n// ]\n```\n\n## Structured Feedback\n\n```typescript\nconst structuredReview = human.review({\n  name: 'code-review',\n\n  feedbackSchema: {\n    overall: {\n      type: 'rating',\n      scale: 5,\n      required: true,\n    },\n    categories: {\n      type: 'ratings',\n      items: ['readability', 'correctness', 'performance', 'security'],\n      scale: 5,\n    },\n    comments: {\n      type: 'textarea',\n      required: { when: 'overall < 3' },\n    },\n    suggestions: {\n      type: 'list',\n      itemType: 'text',\n      maxItems: 10,\n    },\n  },\n})\n```\n\n## Review Criteria\n\n```typescript\nconst criteriaReview = human.review({\n  name: 'quality-review',\n\n  // Checklist criteria\n  criteria: [\n    {\n      name: 'accuracy',\n      description: 'Information is factually correct',\n      required: true,\n    },\n    {\n      name: 'completeness',\n      description: 'All required topics are covered',\n      required: true,\n    },\n    {\n      name: 'clarity',\n      description: 'Writing is clear and understandable',\n      required: true,\n    },\n    {\n      name: 'formatting',\n      description: 'Proper formatting and structure',\n      required: false,\n    },\n  ],\n\n  // Must pass all required criteria to approve\n  passRequirement: 'all-required',\n})\n```\n\n## Blind Review\n\n```typescript\nconst blindReview = human.review({\n  name: 'blind-peer-review',\n\n  // Hide author identity\n  blind: {\n    hideAuthor: true,\n    hideReviewerFromAuthor: true,\n    revealAfter: 'decision',\n  },\n\n  // Multiple independent reviewers\n  reviewers: {\n    count: 3,\n    independent: true,  // Reviews not shared until all complete\n  },\n})\n```\n\n## Time-Boxed Review\n\n```typescript\nconst timeBoxedReview = human.review({\n  name: 'rapid-review',\n\n  // Time constraints\n  timeBox: {\n    target: '15m',      // Target completion time\n    maximum: '1h',      // Hard deadline\n    showTimer: true,\n  },\n\n  // Simplified for speed\n  actions: ['approve', 'flag-for-detailed-review'],\n\n  // Auto-escalate if not completed\n  onTimeout: 'escalate-to-detailed-review',\n})\n```\n\n## Review Feedback to AI\n\n```typescript\n// Feed review feedback back to improve AI\nconst feedbackLoop = human.review({\n  name: 'training-review',\n\n  feedbackCapture: {\n    enabled: true,\n    captureEdits: true,\n    captureRatings: true,\n    captureComments: true,\n  },\n\n  onComplete: async (review) => {\n    // Send to training pipeline\n    await trainingPipeline.submit({\n      original: review.original,\n      humanEdited: review.final,\n      feedback: review.feedback,\n      outcome: review.action,\n    })\n  },\n})\n```\n\n## Review Analytics\n\n```typescript\n// Track review metrics\nconst metrics = await human.getReviewMetrics({\n  review: 'content-review',\n  period: 'last-30-days',\n})\n\nconsole.log(metrics)\n// {\n//   totalReviews: 150,\n//   approvalRate: 0.72,\n//   avgIterations: 1.3,\n//   avgReviewTime: '12m',\n//   byReviewer: { ... },\n//   byCategory: { ... },\n// }\n```\n\n## Best Practices\n\n1. **Clear criteria** - Define what good looks like\n2. **Structured feedback** - Make feedback actionable\n3. **Reasonable iterations** - Set max iterations to prevent loops\n4. **Track patterns** - Use analytics to improve AI\n5. **Time expectations** - Set appropriate SLAs\n6. **Blind when appropriate** - Reduce bias in sensitive reviews\n\n\n# Routing\n\nURL: https://primitives.org.ai/human/routing\n\n> Task assignment, skills matching, and queue management\n\n\n\n# Routing and Assignment\n\nRoute tasks to the right humans based on skills, availability, workload, and other factors.\n\n## Basic Routing\n\n```typescript\nimport { human } from 'human-in-the-loop'\n\nconst task = human.task({\n  name: 'support-ticket',\n\n  routing: {\n    strategy: 'round-robin',\n    assignTo: { team: 'support' },\n  },\n})\n```\n\n## Routing Strategies\n\n### Round Robin\n\n```typescript\nconst roundRobin = human.routing({\n  strategy: 'round-robin',\n  assignTo: { team: 'support' },\n  skipUnavailable: true,\n})\n```\n\n### Skills-Based\n\n```typescript\nconst skillsRouting = human.routing({\n  strategy: 'skills-match',\n\n  skills: {\n    required: ['customer-service'],\n    preferred: ['technical-support', 'product-knowledge'],\n  },\n\n  // How to score matches\n  scoring: {\n    requiredSkillWeight: 1.0,\n    preferredSkillWeight: 0.5,\n    experienceWeight: 0.3,\n  },\n})\n```\n\n### Load-Balanced\n\n```typescript\nconst loadBalanced = human.routing({\n  strategy: 'load-balanced',\n\n  factors: {\n    currentWorkload: 0.4,   // Current task count\n    availability: 0.3,      // Schedule availability\n    capacity: 0.2,          // Max task capacity\n    recentAssignments: 0.1, // Fair distribution\n  },\n\n  limits: {\n    maxTasksPerPerson: 10,\n    maxHighPriorityPerPerson: 3,\n  },\n})\n```\n\n### Priority-Based\n\n```typescript\nconst priorityRouting = human.routing({\n  strategy: 'priority',\n\n  rules: [\n    {\n      condition: 'priority = critical',\n      assignTo: { role: 'senior-specialist' },\n    },\n    {\n      condition: 'customer.tier = enterprise',\n      assignTo: { team: 'enterprise-support' },\n    },\n    {\n      condition: 'topic = billing',\n      assignTo: { team: 'billing' },\n    },\n    {\n      default: true,\n      assignTo: { team: 'general-support' },\n    },\n  ],\n})\n```\n\n## Dynamic Assignment\n\n```typescript\nconst dynamicRouting = human.routing({\n  strategy: 'dynamic',\n\n  assignTo: async ({ task, context }) => {\n    // Custom assignment logic\n    if (task.language !== 'en') {\n      return findByLanguage(task.language)\n    }\n\n    if (task.complexity === 'high') {\n      return findByExpertise(task.category)\n    }\n\n    return findAvailable({ team: 'support' })\n  },\n})\n```\n\n## Queue Management\n\n### Basic Queue\n\n```typescript\nconst taskQueue = human.queue({\n  name: 'review-queue',\n\n  // Queue settings\n  settings: {\n    maxSize: 1000,\n    defaultPriority: 'normal',\n    fifo: true,  // First in, first out\n  },\n})\n\n// Add to queue\nawait taskQueue.add(task)\n\n// Get next task for worker\nconst next = await taskQueue.getNext({ worker: workerId })\n```\n\n### Priority Queue\n\n```typescript\nconst priorityQueue = human.queue({\n  name: 'priority-queue',\n\n  prioritization: [\n    // Priority boosting rules\n    { condition: 'priority = critical', boost: 10 },\n    { condition: 'deadline < 1h', boost: 5 },\n    { condition: 'customer.tier = enterprise', boost: 3 },\n    { condition: 'waitTime > 30m', boost: 2 },\n    { condition: 'type = escalation', boost: 1.5 },\n  ],\n\n  // Decay waiting tasks' priority over time\n  aging: {\n    enabled: true,\n    boostPerHour: 0.5,\n  },\n})\n```\n\n### SLA-Based Queue\n\n```typescript\nconst slaQueue = human.queue({\n  name: 'sla-queue',\n\n  sla: {\n    critical: { responseTime: '15m', resolution: '1h' },\n    high: { responseTime: '1h', resolution: '4h' },\n    normal: { responseTime: '4h', resolution: '24h' },\n    low: { responseTime: '24h', resolution: '72h' },\n  },\n\n  // Escalate when SLA at risk\n  escalation: {\n    warnAt: 0.75,  // 75% of SLA time\n    escalateAt: 0.9,\n    escalateTo: 'supervisor',\n  },\n})\n```\n\n## Fairness and Limits\n\n```typescript\nconst fairQueue = human.queue({\n  name: 'fair-queue',\n\n  fairness: {\n    // Distribution limits\n    maxTasksPerPerson: 10,\n    maxHighPriorityPerPerson: 3,\n\n    // Rotation\n    rotateAfter: '2h',\n    breakReminders: {\n      after: '90m',\n      message: 'Consider taking a short break',\n    },\n\n    // Variety\n    maxSameTypeConsecutive: 3,\n    balanceCategories: true,\n  },\n})\n```\n\n## Availability\n\n### Schedule-Based\n\n```typescript\nconst scheduledRouting = human.routing({\n  strategy: 'skills-match',\n\n  availability: {\n    // Consider working hours\n    respectSchedule: true,\n\n    // Working hours\n    workingHours: {\n      default: '9:00-17:00',\n      timezone: 'local',\n    },\n\n    // Handle out of hours\n    outOfHours: {\n      queue: true,\n      fallback: 'on-call-team',\n    },\n  },\n})\n```\n\n### Real-Time Availability\n\n```typescript\nconst realtimeRouting = human.routing({\n  strategy: 'load-balanced',\n\n  availability: {\n    realtime: true,\n    statusCheck: true,  // Check user status\n\n    statuses: {\n      available: { eligible: true, weight: 1.0 },\n      busy: { eligible: true, weight: 0.5 },\n      away: { eligible: false },\n      offline: { eligible: false },\n    },\n  },\n})\n```\n\n## Escalation Paths\n\n```typescript\nconst escalatingRouting = human.routing({\n  strategy: 'tiered',\n\n  tiers: [\n    {\n      name: 'tier-1',\n      assignTo: { role: 'support-agent' },\n      timeout: '30m',\n    },\n    {\n      name: 'tier-2',\n      assignTo: { role: 'senior-agent' },\n      timeout: '1h',\n    },\n    {\n      name: 'tier-3',\n      assignTo: { role: 'specialist' },\n      timeout: '2h',\n    },\n    {\n      name: 'management',\n      assignTo: { role: 'support-manager' },\n      final: true,\n    },\n  ],\n\n  escalateOn: ['timeout', 'request', 'complexity-increase'],\n})\n```\n\n## Queue Analytics\n\n```typescript\nconst stats = await taskQueue.getStats()\n\nconsole.log(stats)\n// {\n//   total: 150,\n//   waiting: 45,\n//   inProgress: 30,\n//   completed: 75,\n//   avgWaitTime: '12m',\n//   avgProcessTime: '25m',\n//   slaCompliance: 0.92,\n//   byPriority: { critical: 5, high: 20, ... },\n//   byAssignee: { 'user_1': 10, 'user_2': 12, ... },\n// }\n\n// Real-time monitoring\ntaskQueue.on('sla-warning', (task) => {\n  console.log(`SLA at risk for task ${task.id}`)\n})\n\ntaskQueue.on('queue-full', () => {\n  console.log('Queue is at capacity')\n})\n```\n\n## Claiming and Reassignment\n\n```typescript\n// Worker claims task\nawait taskQueue.claim(taskId, { worker: workerId })\n\n// Release task back to queue\nawait taskQueue.release(taskId, {\n  reason: 'Need specialist assistance',\n  preserveProgress: true,\n})\n\n// Reassign to specific person\nawait taskQueue.reassign(taskId, {\n  to: 'specialist@company.com',\n  reason: 'Requires technical expertise',\n})\n\n// Bulk reassignment\nawait taskQueue.bulkReassign({\n  from: 'agent_leaving',\n  to: 'team',\n  preserveProgress: true,\n})\n```\n\n## Notifications\n\n```typescript\nconst notifiedQueue = human.queue({\n  name: 'notified-queue',\n\n  notifications: {\n    onAssignment: {\n      channels: ['email', 'slack', 'push'],\n      template: 'task-assigned',\n    },\n\n    onEscalation: {\n      channels: ['email', 'slack'],\n      includeContext: true,\n    },\n\n    reminders: [\n      { after: '30m', channels: ['slack'] },\n      { after: '1h', channels: ['email'] },\n    ],\n  },\n})\n```\n\n## Best Practices\n\n1. **Match skills to tasks** - Route based on expertise\n2. **Balance workload** - Prevent burnout\n3. **Set clear SLAs** - Define expectations\n4. **Enable escalation** - Provide escape valves\n5. **Monitor queues** - React to backlogs early\n6. **Support reassignment** - Handle unavailability gracefully\n\n\n# ai-database\n\nURL: https://primitives.org.ai/packages/ai-database\n\n> Schema-first database with vector embeddings\n\n\n\n```bash\nnpm install ai-database\n```\n\nAI-native database with natural language queries and semantic search.\n\n```typescript\nimport { DB } from 'ai-database'\n\nconst db = new DB({ namespace: 'my-app' })\n\n// Create with AI\nawait db.User.create`a developer named Alice`\n\n// Query naturally\nconst users = await db.User.find`active in the last week`\n\n// Semantic search\nconst similar = await db.Article.search`machine learning tutorials`\n```\n\n## Features\n\n* Schema inference from natural language\n* Vector embeddings for semantic search\n* Graph relationships between entities\n* Multiple storage providers (Cloudflare D1, Turso, etc.)\n\n## Related\n\n* [Database Primitive](/database) â€” Full documentation\n* [ai-providers](/packages/ai-providers) â€” Embedding providers\n\n\n# ai-functions\n\nURL: https://primitives.org.ai/packages/ai-functions\n\n> Call AI like a functionâ€”no prompts, no configuration\n\n\n\n```bash\nnpm install ai-functions\n```\n\nThe foundation package. Provides tagged template literals for calling AI naturally.\n\n```typescript\nimport { ai, list, is, code } from 'ai-functions'\n\nconst summary = await ai`summarize ${article}`\nconst ideas = await list`blog post ideas about ${topic}`\nconst isSpam = await is`${message} spam?`\nconst fn = await code`function to calculate fibonacci`\n```\n\n## Exports\n\n| Export      | Description                       |\n| ----------- | --------------------------------- |\n| `ai`        | Text generation                   |\n| `generate`  | Structured generation with schema |\n| `write`     | Long-form content                 |\n| `summarize` | Summarization                     |\n| `list`      | Generate a list                   |\n| `lists`     | Generate multiple lists           |\n| `extract`   | Extract structured data           |\n| `is`        | Boolean classification            |\n| `decide`    | Multi-option decision             |\n| `code`      | Code generation                   |\n| `diagram`   | Diagram generation                |\n| `image`     | Image generation                  |\n| `video`     | Video generation                  |\n| `do`        | Agentic single-pass               |\n| `research`  | Web research                      |\n| `read`      | Read URL content                  |\n| `browse`    | Browser automation                |\n| `ask`       | Human input                       |\n| `approve`   | Human approval                    |\n| `review`    | Human review                      |\n\n## Related\n\n* [Functions](/functions) â€” Full documentation\n* [Function Primitive](/function) â€” The Function abstraction\n\n\n# ai-providers\n\nURL: https://primitives.org.ai/packages/ai-providers\n\n> Provider integrations for AI services\n\n\n\n```bash\nnpm install ai-providers\n```\n\nConnect to Anthropic, OpenAI, Google, Cloudflare, and more.\n\n```typescript\nimport { anthropic, openai, cloudflare } from 'ai-providers'\n\n// Use Anthropic\nconst claude = anthropic({ apiKey: process.env.ANTHROPIC_API_KEY })\n\n// Use OpenAI\nconst gpt = openai({ apiKey: process.env.OPENAI_API_KEY })\n\n// Use Cloudflare Workers AI (no API key needed in Workers)\nconst cf = cloudflare()\n```\n\n## Providers\n\n| Provider   | Models                  | Embeddings       |\n| ---------- | ----------------------- | ---------------- |\n| Anthropic  | Claude 4, Sonnet, Haiku | â€”                |\n| OpenAI     | GPT-4, GPT-3.5          | text-embedding-3 |\n| Google     | Gemini Pro, Flash       | â€”                |\n| Cloudflare | Workers AI models       | bge-\\*           |\n| Ollama     | Local models            | Local embeddings |\n\n## Related\n\n* [language-models](/packages/language-models) â€” Unified interface\n* [ai-functions](/packages/ai-functions) â€” Uses providers internally\n\n\n# ai-workflows\n\nURL: https://primitives.org.ai/packages/ai-workflows\n\n> Durable execution and state machines\n\n\n\n```bash\nnpm install ai-workflows\n```\n\nOrchestrate complex processes with automatic persistence, retries, and recovery.\n\n```typescript\nimport { workflow, step } from 'ai-workflows'\n\nconst processOrder = workflow('process-order', async (ctx, order) => {\n  const validated = await ctx.run('validate', () => validateOrder(order))\n  const payment = await ctx.run('charge', () => chargeCard(validated))\n  await ctx.run('fulfill', () => fulfillOrder(payment))\n  return { success: true }\n})\n```\n\n## Features\n\n* Durable execution with automatic checkpointing\n* State machines for explicit state management\n* Parallel execution with `Promise.all`\n* Human-in-the-loop integration\n* Timers and scheduled execution\n\n## Related\n\n* [Workflow Primitive](/workflow) â€” Full documentation\n* [ai-functions](/packages/ai-functions) â€” Functions to orchestrate\n* [human-in-the-loop](/packages/human-in-the-loop) â€” Human steps\n\n\n# autonomous-agents\n\nURL: https://primitives.org.ai/packages/autonomous-agents\n\n> Truly autonomous agents with identity and memory\n\n\n\n```bash\nnpm install autonomous-agents\n```\n\nCreate agents that are long-term members of your organization with real identity.\n\n```typescript\nimport { agent } from 'autonomous-agents'\n\nconst reviewer = agent({\n  name: 'code-reviewer',\n  identity: {\n    email: 'reviewer@company.com',\n    slack: '@code-reviewer',\n  },\n  capabilities: [reviewCode, suggestFixes],\n  memory: { type: 'persistent' },\n})\n\nawait reviewer.assign(pullRequest)\n```\n\n## Features\n\n* Real identity (email, Slack, calendar)\n* Long-term persistent memory\n* Capability-based permissions\n* Autonomous goal pursuit\n* Human escalation paths\n\n## Related\n\n* [Agent Primitive](/agent) â€” Full documentation\n* [ai-functions](/packages/ai-functions) â€” Agent capabilities\n* [ai-workflows](/packages/ai-workflows) â€” Agent workflows\n\n\n# business-as-code\n\nURL: https://primitives.org.ai/packages/business-as-code\n\n> Express business processes and structures as code\n\n\n\n```bash\nnpm install business-as-code\n```\n\nDefine organizations, teams, processes, and policies as code.\n\n```typescript\nimport { business, team, process, policy } from 'business-as-code'\n\nconst acme = business({\n  name: 'Acme Corp',\n  teams: [\n    team({ name: 'Engineering', members: [...] }),\n    team({ name: 'Sales', members: [...] }),\n  ],\n  processes: [\n    process({ name: 'hiring', steps: [...] }),\n    process({ name: 'expense-approval', steps: [...] }),\n  ],\n  policies: [\n    policy({ name: 'expense-limit', rule: amount => amount < 5000 }),\n  ],\n})\n```\n\n## Features\n\n* Organizational structure as code\n* Process definitions with versioning\n* Policy enforcement\n* Audit and compliance\n* AI and human collaboration\n\n## Related\n\n* [Business Primitive](/business) â€” Full documentation\n* [ai-workflows](/packages/ai-workflows) â€” Process orchestration\n* [human-in-the-loop](/packages/human-in-the-loop) â€” Human approvals\n\n\n# digital-products\n\nURL: https://primitives.org.ai/packages/digital-products\n\n> Compose primitives into complete products\n\n\n\n```bash\nnpm install digital-products\n```\n\nDefine complete products with capabilities, APIs, and interfaces.\n\n```typescript\nimport { product, api, ui } from 'digital-products'\n\nconst app = product({\n  name: 'document-processor',\n  capabilities: [\n    uploadDocument,\n    extractData,\n    generateSummary,\n  ],\n  api: api({\n    routes: ['/upload', '/process', '/status'],\n  }),\n  ui: ui({\n    pages: ['upload', 'results'],\n  }),\n})\n```\n\n## Features\n\n* Declarative capability definitions\n* API generation from capabilities\n* UI scaffolding\n* Versioning and deployment\n\n## Related\n\n* [Product Primitive](/product) â€” Full documentation\n* [ai-functions](/packages/ai-functions) â€” Product capabilities\n* [services-as-software](/packages/services-as-software) â€” Service packaging\n\n\n# digital-tasks\n\nURL: https://primitives.org.ai/packages/digital-tasks\n\n> Task management for digital workers\n\n\n\n```bash\nnpm install digital-tasks\n```\n\nWrap functions with lifecycle management, status tracking, and dependencies.\n\n```typescript\nimport { task, queue } from 'digital-tasks'\n\nconst reviewTask = task({\n  name: 'review-document',\n  fn: reviewDocument,\n  assignment: { role: 'reviewer' },\n  dependencies: ['upload-document'],\n})\n\nconst q = queue({ concurrency: 5 })\nawait q.enqueue(reviewTask, { document })\n```\n\n## Features\n\n* Status tracking (pending, in\\_progress, completed, failed)\n* Dependencies between tasks\n* Worker assignment and load balancing\n* Priority queues\n* Retry policies\n\n## Related\n\n* [Task Primitive](/task) â€” Full documentation\n* [ai-functions](/packages/ai-functions) â€” Task implementations\n* [digital-workers](/packages/digital-workers) â€” Worker execution\n\n\n# digital-tools\n\nURL: https://primitives.org.ai/packages/digital-tools\n\n> Tools and integrations for agents\n\n\n\n```bash\nnpm install digital-tools\n```\n\nPre-built tools for web search, code execution, file operations, and more.\n\n```typescript\nimport { webSearch, codeExec, fileSystem, http } from 'digital-tools'\n\nconst search = webSearch({ provider: 'google', maxResults: 10 })\nconst exec = codeExec({ runtime: 'node', timeout: 30000 })\nconst fs = fileSystem({ root: '/workspace' })\nconst api = http({ baseUrl: 'https://api.example.com' })\n\n// Use in agents\nconst agent = agent({\n  tools: [search, exec, fs, api],\n})\n```\n\n## Available Tools\n\n| Tool         | Description        |\n| ------------ | ------------------ |\n| `webSearch`  | Search the web     |\n| `codeExec`   | Execute code       |\n| `fileSystem` | Read/write files   |\n| `http`       | Make HTTP requests |\n| `browser`    | Browser automation |\n| `database`   | Database queries   |\n\n## Related\n\n* [autonomous-agents](/packages/autonomous-agents) â€” Use tools in agents\n* [Agentic Functions](/function/agentic) â€” Tool-using functions\n\n\n# digital-workers\n\nURL: https://primitives.org.ai/packages/digital-workers\n\n> Worker abstractions for task execution\n\n\n\n```bash\nnpm install digital-workers\n```\n\nDefine workers that process tasks from queues.\n\n```typescript\nimport { worker, pool } from 'digital-workers'\n\nconst reviewWorker = worker({\n  name: 'document-reviewer',\n  capabilities: [reviewDocument, extractData],\n  concurrency: 5,\n})\n\nconst workerPool = pool({\n  workers: [reviewWorker, summaryWorker],\n  scaling: { min: 1, max: 10 },\n})\n\nawait workerPool.start()\n```\n\n## Features\n\n* Capability-based task matching\n* Concurrency control\n* Auto-scaling pools\n* Health monitoring\n* Graceful shutdown\n\n## Related\n\n* [digital-tasks](/packages/digital-tasks) â€” Task definitions\n* [ai-functions](/packages/ai-functions) â€” Worker capabilities\n* [autonomous-agents](/packages/autonomous-agents) â€” Agent workers\n\n\n# human-in-the-loop\n\nURL: https://primitives.org.ai/packages/human-in-the-loop\n\n> Human integration for approvals, reviews, and judgment\n\n\n\n```bash\nnpm install human-in-the-loop\n```\n\nFirst-class human participation in AI workflows.\n\n```typescript\nimport { approve, review, ask } from 'human-in-the-loop'\n\nconst approved = await approve`\n  Expense: ${expense.description}\n  Amount: $${expense.amount}\n`({ assignTo: { role: 'manager' } })\n\nif (approved) {\n  await processExpense(expense)\n}\n```\n\n## Features\n\n* Slack, email, and web notifications\n* Role-based assignment\n* Timeout and escalation policies\n* Audit logging\n* Custom approval UIs\n\n## Related\n\n* [Human Primitive](/human) â€” Full documentation\n* [ai-workflows](/packages/ai-workflows) â€” Workflow integration\n* [Human Functions](/function/human) â€” ask, approve, review\n\n\n# Packages\n\nURL: https://primitives.org.ai/packages\n\n> NPM packages implementing the Primitives.org.ai abstractions\n\n\n\nAll packages work together seamlessly. Install what you need.\n\n## Core\n\n| Package                                          | Description               | Primitive             |\n| ------------------------------------------------ | ------------------------- | --------------------- |\n| [ai-functions](/packages/ai-functions)           | Call AI like a function   | [Function](/function) |\n| [ai-database](/packages/ai-database)             | Schema-first with vectors | [Database](/database) |\n| [ai-workflows](/packages/ai-workflows)           | Durable execution         | [Workflow](/workflow) |\n| [autonomous-agents](/packages/autonomous-agents) | Agents with identity      | [Agent](/agent)       |\n| [human-in-the-loop](/packages/human-in-the-loop) | Human integration         | [Human](/human)       |\n| [digital-tasks](/packages/digital-tasks)         | Task management           | [Task](/task)         |\n\n## Products\n\n| Package                                                | Description           | Primitive             |\n| ------------------------------------------------------ | --------------------- | --------------------- |\n| [digital-products](/packages/digital-products)         | Compose into products | [Product](/product)   |\n| [services-as-software](/packages/services-as-software) | AI-delivered services | [Service](/service)   |\n| [business-as-code](/packages/business-as-code)         | Business processes    | [Business](/business) |\n\n## Infrastructure\n\n| Package                                      | Description           |\n| -------------------------------------------- | --------------------- |\n| [language-models](/packages/language-models) | Unified LLM interface |\n| [ai-providers](/packages/ai-providers)       | Provider integrations |\n| [digital-workers](/packages/digital-workers) | Worker execution      |\n| [digital-tools](/packages/digital-tools)     | Tools for agents      |\n\n## Quick Start\n\n```bash\nnpm install ai-functions\n```\n\n```typescript\nimport { ai, list, is } from 'ai-functions'\n\nconst summary = await ai`summarize ${article}`\nconst ideas = await list`blog post ideas`\nconst spam = await is`${message} spam?`\n```\n\n\n# language-models\n\nURL: https://primitives.org.ai/packages/language-models\n\n> Unified interface for working with LLMs\n\n\n\n```bash\nnpm install language-models\n```\n\nProvider-agnostic interface for text generation and embeddings.\n\n```typescript\nimport { llm } from 'language-models'\n\nconst response = await llm.generate({\n  model: 'claude-sonnet-4-20250514',\n  messages: [{ role: 'user', content: 'Hello!' }],\n})\n\nconst embedding = await llm.embed({\n  model: 'text-embedding-3-small',\n  input: 'Hello world',\n})\n```\n\n## Supported Providers\n\n* Anthropic (Claude)\n* OpenAI (GPT)\n* Google (Gemini)\n* Cloudflare Workers AI\n* Ollama (local)\n\n## Related\n\n* [ai-providers](/packages/ai-providers) â€” Provider implementations\n* [ai-functions](/packages/ai-functions) â€” Higher-level abstractions\n\n\n# services-as-software\n\nURL: https://primitives.org.ai/packages/services-as-software\n\n> AI delivering work traditionally performed by humans\n\n\n\n```bash\nnpm install services-as-software\n```\n\nPackage AI capabilities as callable services with SLAs and pricing.\n\n```typescript\nimport { service, sla, pricing } from 'services-as-software'\n\nconst taxPrep = service({\n  name: 'tax-preparation',\n  description: 'AI-powered tax preparation service',\n  implementation: taxPrepWorkflow,\n  sla: sla({\n    responseTime: '24h',\n    accuracy: 0.99,\n  }),\n  pricing: pricing({\n    base: 49,\n    perComplexity: 10,\n  }),\n})\n```\n\n## Features\n\n* SLA definitions and monitoring\n* Usage-based pricing\n* Quality guarantees\n* Human escalation\n* Audit trails\n\n## Related\n\n* [Service Primitive](/service) â€” Full documentation\n* [ai-workflows](/packages/ai-workflows) â€” Service implementations\n* [business-as-code](/packages/business-as-code) â€” Business integration\n\n\n# API\n\nURL: https://primitives.org.ai/product/api\n\n> Define programmatic interfaces\n\n\n\n# API\n\nThe `API()` function defines programmatic interfaces with endpoints, authentication, and rate limiting.\n\n## Basic Usage\n\n```typescript\nimport { API, Endpoint } from 'digital-products'\n\nconst myAPI = API({\n  id: 'my-api',\n  name: 'My API',\n  description: 'A RESTful API',\n  version: '1.0.0',\n  style: 'rest',\n  baseUrl: 'https://api.example.com',\n})\n```\n\n## Endpoints\n\nDefine API endpoints:\n\n```typescript\nimport { API, Endpoint } from 'digital-products'\n\nconst myAPI = API({\n  id: 'my-api',\n  name: 'My API',\n  version: '1.0.0',\n  style: 'rest',\n  baseUrl: 'https://api.example.com',\n  endpoints: [\n    Endpoint('GET', '/users', 'List all users', {\n      response: {\n        users: ['Array of user objects'],\n        total: 'Total count (number)',\n      },\n    }),\n    Endpoint('GET', '/users/:id', 'Get user by ID', {\n      response: {\n        id: 'User ID',\n        name: 'User name',\n        email: 'User email',\n      },\n    }),\n    Endpoint('POST', '/users', 'Create a user', {\n      request: {\n        name: 'User name',\n        email: 'User email',\n      },\n      response: {\n        id: 'User ID',\n        name: 'User name',\n        email: 'User email',\n      },\n      auth: true,\n    }),\n    Endpoint('PUT', '/users/:id', 'Update user', {\n      request: {\n        name: 'User name',\n        email: 'User email',\n      },\n      auth: true,\n    }),\n    Endpoint('DELETE', '/users/:id', 'Delete user', {\n      auth: true,\n    }),\n  ],\n})\n```\n\n### Endpoint Helper\n\n```typescript\nEndpoint(method, path, description, options?)\n```\n\n| Parameter          | Type    | Description          |\n| ------------------ | ------- | -------------------- |\n| `method`           | string  | HTTP method          |\n| `path`             | string  | URL path             |\n| `description`      | string  | Endpoint description |\n| `options.request`  | schema  | Request body schema  |\n| `options.response` | schema  | Response schema      |\n| `options.auth`     | boolean | Requires auth        |\n\n## API Styles\n\n| Style       | Description           |\n| ----------- | --------------------- |\n| `rest`      | RESTful API           |\n| `graphql`   | GraphQL API           |\n| `rpc`       | Remote procedure call |\n| `grpc`      | gRPC API              |\n| `websocket` | WebSocket API         |\n\n## Authentication\n\nAdd API authentication:\n\n```typescript\nimport { API, APIAuth } from 'digital-products'\n\nconst myAPI = API({\n  id: 'my-api',\n  name: 'My API',\n  version: '1.0.0',\n  style: 'rest',\n  auth: APIAuth({\n    type: 'bearer',   // or 'api-key', 'oauth2', 'basic'\n    header: 'Authorization',\n  }),\n})\n```\n\n### Auth Types\n\n| Type      | Description            |\n| --------- | ---------------------- |\n| `bearer`  | Bearer token in header |\n| `api-key` | API key authentication |\n| `oauth2`  | OAuth 2.0 flow         |\n| `basic`   | Basic authentication   |\n\n## Rate Limiting\n\nConfigure rate limits:\n\n```typescript\nimport { API, RateLimit } from 'digital-products'\n\nconst myAPI = API({\n  id: 'my-api',\n  name: 'My API',\n  version: '1.0.0',\n  style: 'rest',\n  rateLimit: RateLimit({\n    requests: 100,      // Max requests\n    window: 60,         // Per 60 seconds\n    onExceeded: 'reject', // or 'queue'\n  }),\n})\n```\n\n## Complete Example\n\n```typescript\nimport { API, Endpoint, APIAuth, RateLimit } from 'digital-products'\n\nconst ordersAPI = API({\n  id: 'orders-api',\n  name: 'Orders API',\n  description: 'E-commerce orders management API',\n  version: '2.0.0',\n  style: 'rest',\n  baseUrl: 'https://api.store.com/v2',\n\n  endpoints: [\n    Endpoint('GET', '/orders', 'List orders', {\n      response: {\n        orders: [{\n          id: 'Order ID',\n          status: 'pending | processing | shipped | delivered',\n          total: 'Order total (number)',\n          items: ['Array of order items'],\n        }],\n        pagination: {\n          page: 'Current page (number)',\n          totalPages: 'Total pages (number)',\n        },\n      },\n    }),\n    Endpoint('POST', '/orders', 'Create order', {\n      request: {\n        items: [{\n          productId: 'Product ID',\n          quantity: 'Quantity (number)',\n        }],\n        shippingAddress: {\n          street: 'Street address',\n          city: 'City',\n          zip: 'ZIP code',\n        },\n      },\n      response: {\n        id: 'Order ID',\n        status: 'Order status',\n      },\n      auth: true,\n    }),\n    Endpoint('GET', '/orders/:id', 'Get order details', {\n      response: {\n        id: 'Order ID',\n        status: 'Order status',\n        items: ['Order items'],\n        total: 'Total (number)',\n        createdAt: 'Created date (date)',\n      },\n      auth: true,\n    }),\n  ],\n\n  auth: APIAuth({\n    type: 'bearer',\n    header: 'Authorization',\n  }),\n\n  rateLimit: RateLimit({\n    requests: 1000,\n    window: 3600,\n    onExceeded: 'reject',\n  }),\n})\n```\n\n## OpenAPI/Swagger\n\nAPIs automatically generate OpenAPI specs:\n\n```typescript\n// Access the OpenAPI spec\nconst spec = myAPI.toOpenAPI()\n// Returns OpenAPI 3.0 compliant specification\n```\n\n## Type Definition\n\n```typescript\ninterface APIDefinition {\n  id: string\n  name: string\n  description?: string\n  version?: string\n  style?: 'rest' | 'graphql' | 'rpc' | 'grpc' | 'websocket'\n  baseUrl?: string\n  endpoints?: EndpointDefinition[]\n  auth?: APIAuthDefinition\n  rateLimit?: RateLimitDefinition\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# App\n\nURL: https://primitives.org.ai/product/app\n\n> Define interactive applications\n\n\n\n# App\n\nThe `App()` function defines interactive user-facing applications with routes, state management, and authentication.\n\n## Basic Usage\n\n```typescript\nimport { App, Route, State, Auth } from 'digital-products'\n\nconst myApp = App({\n  id: 'my-app',\n  name: 'My App',\n  description: 'A web application',\n  version: '1.0.0',\n  framework: 'react',\n})\n```\n\n## Routes\n\nDefine application routes:\n\n```typescript\nconst myApp = App({\n  id: 'my-app',\n  name: 'My App',\n  framework: 'react',\n  routes: [\n    Route('/', 'Home'),\n    Route('/about', 'About'),\n    Route('/users/:id', 'UserDetail', {\n      meta: { title: 'User Profile' },\n    }),\n    Route('/dashboard', 'Dashboard', {\n      meta: { requiresAuth: true },\n    }),\n  ],\n})\n```\n\n### Route Helper\n\n```typescript\nRoute(path, component, options?)\n```\n\n| Parameter      | Type   | Description      |\n| -------------- | ------ | ---------------- |\n| `path`         | string | URL path pattern |\n| `component`    | string | Component name   |\n| `options.meta` | object | Route metadata   |\n\n## State Management\n\nConfigure state management:\n\n```typescript\nconst myApp = App({\n  id: 'my-app',\n  name: 'My App',\n  framework: 'react',\n  state: State({\n    library: 'zustand',  // or 'redux', 'jotai', 'recoil'\n    schema: {\n      user: 'Current user object',\n      settings: 'App settings object',\n      cart: ['Array of cart items'],\n    },\n    persistence: {\n      type: 'local',  // or 'session', 'none'\n      key: 'app-state',\n    },\n  }),\n})\n```\n\n### State Libraries\n\n| Library   | Description                  |\n| --------- | ---------------------------- |\n| `zustand` | Lightweight state management |\n| `redux`   | Predictable state container  |\n| `jotai`   | Primitive and flexible state |\n| `recoil`  | Facebook's state management  |\n\n## Authentication\n\nAdd authentication:\n\n```typescript\nconst myApp = App({\n  id: 'my-app',\n  name: 'My App',\n  framework: 'react',\n  auth: Auth({\n    provider: 'clerk',  // or 'auth0', 'firebase', 'supabase'\n    protectedRoutes: ['/dashboard', '/profile', '/settings'],\n    redirectTo: '/login',\n  }),\n})\n```\n\n### Auth Providers\n\n| Provider   | Description            |\n| ---------- | ---------------------- |\n| `clerk`    | Modern auth platform   |\n| `auth0`    | Identity platform      |\n| `firebase` | Google auth service    |\n| `supabase` | Open source auth       |\n| `nextauth` | Next.js authentication |\n\n## Complete Example\n\n```typescript\nimport { App, Route, State, Auth } from 'digital-products'\n\nconst dashboard = App({\n  id: 'dashboard-app',\n  name: 'Analytics Dashboard',\n  description: 'Real-time analytics for your business',\n  version: '2.0.0',\n  framework: 'react',\n\n  routes: [\n    Route('/', 'Home'),\n    Route('/login', 'Login'),\n    Route('/dashboard', 'Dashboard'),\n    Route('/reports', 'Reports'),\n    Route('/reports/:id', 'ReportDetail'),\n    Route('/settings', 'Settings'),\n  ],\n\n  state: State({\n    library: 'zustand',\n    schema: {\n      user: 'Current user object',\n      reports: ['Array of report objects'],\n      filters: {\n        dateRange: 'Selected date range',\n        metrics: ['Selected metrics'],\n      },\n    },\n    persistence: {\n      type: 'local',\n      key: 'dashboard-state',\n    },\n  }),\n\n  auth: Auth({\n    provider: 'clerk',\n    protectedRoutes: ['/dashboard', '/reports', '/settings'],\n    redirectTo: '/login',\n  }),\n})\n```\n\n## Framework Support\n\n| Framework | Features     |\n| --------- | ------------ |\n| `react`   | Full support |\n| `vue`     | Full support |\n| `svelte`  | Full support |\n| `solid`   | Full support |\n| `next`    | SSR + React  |\n| `nuxt`    | SSR + Vue    |\n\n## Type Definition\n\n```typescript\ninterface AppDefinition {\n  id: string\n  name: string\n  description?: string\n  version?: string\n  framework?: 'react' | 'vue' | 'svelte' | 'solid' | 'next' | 'nuxt'\n  routes?: RouteDefinition[]\n  state?: StateDefinition\n  auth?: AuthDefinition\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Content\n\nURL: https://primitives.org.ai/product/content\n\n> Define content structures\n\n\n\n# Content\n\nThe `Content()` function defines content structures with schemas, workflows, and publishing pipelines.\n\n## Basic Usage\n\n```typescript\nimport { Content } from 'digital-products'\n\nconst blogContent = Content({\n  id: 'blog',\n  name: 'Blog Posts',\n  description: 'Blog content for the website',\n  version: '1.0.0',\n  format: 'mdx',\n  source: './content/blog',\n})\n```\n\n## Content Formats\n\n| Format     | Description          |\n| ---------- | -------------------- |\n| `mdx`      | MDX (Markdown + JSX) |\n| `markdown` | Standard Markdown    |\n| `html`     | HTML content         |\n| `json`     | JSON data            |\n| `yaml`     | YAML data            |\n\n## Frontmatter Schema\n\nDefine content metadata:\n\n```typescript\nconst blogContent = Content({\n  id: 'blog',\n  name: 'Blog Posts',\n  format: 'mdx',\n  source: './content/blog',\n  frontmatter: {\n    title: 'Post title',\n    author: 'Author name',\n    date: 'Publication date (date)',\n    tags: ['Array of tags'],\n    featured: 'Featured post (boolean)',\n    category: 'tech | business | design',\n  },\n})\n```\n\n## Categories\n\nOrganize content by category:\n\n```typescript\nconst blogContent = Content({\n  id: 'blog',\n  name: 'Blog Posts',\n  format: 'mdx',\n  source: './content/blog',\n  categories: ['Technology', 'Business', 'Design', 'Marketing'],\n})\n```\n\n## Publishing Workflow\n\nDefine content workflows with states and transitions:\n\n```typescript\nimport { Content, Workflow } from 'digital-products'\n\nconst blogContent = Content({\n  id: 'blog',\n  name: 'Blog Posts',\n  format: 'mdx',\n  source: './content/blog',\n  workflow: Workflow({\n    states: ['draft', 'review', 'approved', 'published', 'archived'],\n    initialState: 'draft',\n    transitions: [\n      { from: 'draft', to: 'review', action: 'submit' },\n      { from: 'review', to: 'approved', action: 'approve' },\n      { from: 'review', to: 'draft', action: 'reject' },\n      { from: 'approved', to: 'published', action: 'publish' },\n      { from: 'published', to: 'archived', action: 'archive' },\n    ],\n    approvals: [\n      { state: 'review', roles: ['editor', 'admin'] },\n      { state: 'approved', roles: ['admin'] },\n    ],\n  }),\n})\n```\n\n### Workflow States\n\nCommon workflow states:\n\n| State       | Description          |\n| ----------- | -------------------- |\n| `draft`     | Work in progress     |\n| `review`    | Awaiting review      |\n| `approved`  | Approved for publish |\n| `published` | Live content         |\n| `archived`  | Removed from site    |\n\n### Workflow Approvals\n\nControl who can transition content:\n\n```typescript\napprovals: [\n  { state: 'review', roles: ['editor', 'admin'] },\n  { state: 'approved', roles: ['admin'] },\n]\n```\n\n## Complete Example\n\n```typescript\nimport { Content, Workflow } from 'digital-products'\n\nconst documentation = Content({\n  id: 'docs',\n  name: 'Documentation',\n  description: 'Product documentation',\n  version: '1.0.0',\n  format: 'mdx',\n  source: './content/docs',\n\n  frontmatter: {\n    title: 'Page title',\n    description: 'Page description',\n    section: 'getting-started | guides | api | reference',\n    order: 'Sort order (number)',\n    lastUpdated: 'Last update date (date)',\n    authors: ['Array of author names'],\n  },\n\n  categories: [\n    'Getting Started',\n    'Guides',\n    'API Reference',\n    'Examples',\n  ],\n\n  workflow: Workflow({\n    states: ['draft', 'review', 'published'],\n    initialState: 'draft',\n    transitions: [\n      { from: 'draft', to: 'review', action: 'submit' },\n      { from: 'review', to: 'published', action: 'approve' },\n      { from: 'review', to: 'draft', action: 'revise' },\n      { from: 'published', to: 'draft', action: 'unpublish' },\n    ],\n    approvals: [\n      { state: 'review', roles: ['tech-writer', 'admin'] },\n    ],\n  }),\n})\n```\n\n## Blog Example\n\n```typescript\nimport { Content, Workflow } from 'digital-products'\n\nconst blog = Content({\n  id: 'blog',\n  name: 'Company Blog',\n  description: 'News, updates, and insights',\n  version: '1.0.0',\n  format: 'mdx',\n  source: './content/blog',\n\n  frontmatter: {\n    title: 'Post title',\n    slug: 'URL slug',\n    excerpt: 'Short description',\n    author: {\n      name: 'Author name',\n      avatar: 'Avatar URL',\n      twitter: 'Twitter handle',\n    },\n    date: 'Publication date (date)',\n    updatedAt: 'Last updated (date)',\n    tags: ['Array of tags'],\n    category: 'engineering | product | company | culture',\n    featured: 'Featured article (boolean)',\n    coverImage: 'Cover image URL',\n    readingTime: 'Estimated reading time',\n  },\n\n  categories: ['Engineering', 'Product', 'Company', 'Culture'],\n\n  workflow: Workflow({\n    states: ['draft', 'review', 'scheduled', 'published', 'archived'],\n    initialState: 'draft',\n    transitions: [\n      { from: 'draft', to: 'review', action: 'submit' },\n      { from: 'review', to: 'draft', action: 'revise' },\n      { from: 'review', to: 'scheduled', action: 'schedule' },\n      { from: 'review', to: 'published', action: 'publish-now' },\n      { from: 'scheduled', to: 'published', action: 'auto-publish' },\n      { from: 'published', to: 'archived', action: 'archive' },\n    ],\n    approvals: [\n      { state: 'review', roles: ['editor', 'content-manager'] },\n    ],\n  }),\n})\n```\n\n## Type Definition\n\n```typescript\ninterface ContentDefinition {\n  id: string\n  name: string\n  description?: string\n  version?: string\n  format?: 'mdx' | 'markdown' | 'html' | 'json' | 'yaml'\n  source?: string\n  frontmatter?: SimpleSchema\n  categories?: string[]\n  workflow?: WorkflowDefinition\n  metadata?: Record<string, unknown>\n}\n\ninterface WorkflowDefinition {\n  states: string[]\n  initialState: string\n  transitions: {\n    from: string\n    to: string\n    action: string\n  }[]\n  approvals?: {\n    state: string\n    roles: string[]\n  }[]\n}\n```\n\n\n# Data\n\nURL: https://primitives.org.ai/product/data\n\n> Define data structures\n\n\n\n# Data\n\nThe `Data()` function defines data structures with schemas, indexes, relationships, and validation rules.\n\n## Basic Usage\n\n```typescript\nimport { Data } from 'digital-products'\n\nconst userData = Data({\n  id: 'users',\n  name: 'Users',\n  description: 'User data store',\n  version: '1.0.0',\n  schema: {\n    id: 'User ID',\n    name: 'User name',\n    email: 'User email',\n    createdAt: 'Creation timestamp (date)',\n  },\n})\n```\n\n## Schema Definition\n\nDefine data structure with types:\n\n```typescript\nconst userData = Data({\n  id: 'users',\n  name: 'Users',\n  schema: {\n    id: 'User ID',\n    name: 'User name',\n    email: 'User email',\n    age: 'User age (number)',\n    active: 'Account active (boolean)',\n    role: 'admin | user | guest',\n    createdAt: 'Creation timestamp (date)',\n    settings: {\n      theme: 'light | dark',\n      notifications: 'Notifications enabled (boolean)',\n    },\n    tags: ['Array of tags'],\n  },\n})\n```\n\n## Database Providers\n\n| Provider      | Description        |\n| ------------- | ------------------ |\n| `postgres`    | PostgreSQL         |\n| `mysql`       | MySQL              |\n| `sqlite`      | SQLite             |\n| `mongodb`     | MongoDB            |\n| `planetscale` | PlanetScale        |\n| `supabase`    | Supabase           |\n| `firebase`    | Firebase Firestore |\n\n```typescript\nconst userData = Data({\n  id: 'users',\n  name: 'Users',\n  provider: 'postgres',\n  schema: { /* ... */ },\n})\n```\n\n## Indexes\n\nAdd database indexes:\n\n```typescript\nimport { Data, Index } from 'digital-products'\n\nconst userData = Data({\n  id: 'users',\n  name: 'Users',\n  schema: {\n    id: 'User ID',\n    email: 'User email',\n    role: 'User role',\n    createdAt: 'Creation date (date)',\n  },\n  indexes: [\n    Index('email_idx', ['email'], { unique: true }),\n    Index('role_idx', ['role']),\n    Index('created_idx', ['createdAt']),\n    Index('role_created_idx', ['role', 'createdAt']),\n  ],\n})\n```\n\n### Index Options\n\n| Option    | Description           |\n| --------- | --------------------- |\n| `unique`  | Enforce unique values |\n| `sparse`  | Skip null values      |\n| `partial` | Conditional index     |\n\n## Relationships\n\nDefine relationships between data types:\n\n```typescript\nimport { Data, Relationship } from 'digital-products'\n\nconst userData = Data({\n  id: 'users',\n  name: 'Users',\n  schema: {\n    id: 'User ID',\n    name: 'User name',\n    email: 'User email',\n  },\n  relationships: [\n    Relationship('one-to-many', 'userId', 'posts', 'author'),\n    Relationship('one-to-many', 'userId', 'comments', 'user'),\n    Relationship('many-to-many', 'userId', 'teams', 'members'),\n  ],\n})\n```\n\n### Relationship Types\n\n| Type           | Description               |\n| -------------- | ------------------------- |\n| `one-to-one`   | Single reference          |\n| `one-to-many`  | Multiple references       |\n| `many-to-many` | Many references both ways |\n\n## Validation\n\nAdd validation rules:\n\n```typescript\nimport { Data, Validate } from 'digital-products'\n\nconst userData = Data({\n  id: 'users',\n  name: 'Users',\n  schema: {\n    id: 'User ID',\n    name: 'User name',\n    email: 'User email',\n    age: 'User age (number)',\n  },\n  validation: [\n    Validate('email', 'email', 'Must be a valid email'),\n    Validate('name', 'required', 'Name is required'),\n    Validate('name', 'minLength:2', 'Name must be at least 2 characters'),\n    Validate('age', 'min:0', 'Age must be positive'),\n    Validate('age', 'max:150', 'Age must be realistic'),\n  ],\n})\n```\n\n### Validation Rules\n\n| Rule            | Description           |\n| --------------- | --------------------- |\n| `required`      | Field must be present |\n| `email`         | Valid email format    |\n| `url`           | Valid URL format      |\n| `min:n`         | Minimum value         |\n| `max:n`         | Maximum value         |\n| `minLength:n`   | Minimum string length |\n| `maxLength:n`   | Maximum string length |\n| `pattern:regex` | Match regex pattern   |\n\n## Complete Example\n\n```typescript\nimport { Data, Index, Relationship, Validate } from 'digital-products'\n\nconst orderData = Data({\n  id: 'orders',\n  name: 'Orders',\n  description: 'E-commerce order data',\n  version: '1.0.0',\n  provider: 'postgres',\n\n  schema: {\n    id: 'Order ID',\n    userId: 'Customer ID',\n    status: 'pending | processing | shipped | delivered | cancelled',\n    items: [{\n      productId: 'Product ID',\n      name: 'Product name',\n      quantity: 'Quantity (number)',\n      price: 'Unit price (number)',\n    }],\n    subtotal: 'Subtotal (number)',\n    tax: 'Tax amount (number)',\n    shipping: 'Shipping cost (number)',\n    total: 'Total amount (number)',\n    shippingAddress: {\n      street: 'Street address',\n      city: 'City',\n      state: 'State',\n      zip: 'ZIP code',\n      country: 'Country',\n    },\n    createdAt: 'Order date (date)',\n    updatedAt: 'Last updated (date)',\n  },\n\n  indexes: [\n    Index('user_idx', ['userId']),\n    Index('status_idx', ['status']),\n    Index('created_idx', ['createdAt']),\n    Index('user_status_idx', ['userId', 'status']),\n  ],\n\n  relationships: [\n    Relationship('many-to-one', 'userId', 'users', 'customer'),\n    Relationship('one-to-many', 'orderId', 'shipments', 'order'),\n  ],\n\n  validation: [\n    Validate('userId', 'required', 'Customer ID is required'),\n    Validate('items', 'minLength:1', 'Order must have at least one item'),\n    Validate('total', 'min:0', 'Total must be positive'),\n  ],\n})\n```\n\n## Type Definition\n\n```typescript\ninterface DataDefinition {\n  id: string\n  name: string\n  description?: string\n  version?: string\n  schema: SimpleSchema\n  provider?: 'postgres' | 'mysql' | 'sqlite' | 'mongodb' | 'planetscale' | 'supabase' | 'firebase'\n  indexes?: IndexDefinition[]\n  relationships?: RelationshipDefinition[]\n  validation?: ValidationRule[]\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Dataset\n\nURL: https://primitives.org.ai/product/dataset\n\n> Define curated data collections\n\n\n\n# Dataset\n\nThe `Dataset()` function defines curated data collections with schemas, licensing, and update schedules.\n\n## Basic Usage\n\n```typescript\nimport { Dataset } from 'digital-products'\n\nconst movieDataset = Dataset({\n  id: 'movies',\n  name: 'Movie Database',\n  description: 'Comprehensive movie information dataset',\n  version: '2024.1',\n  format: 'parquet',\n  source: 's3://datasets/movies.parquet',\n})\n```\n\n## Data Formats\n\n| Format    | Description            |\n| --------- | ---------------------- |\n| `json`    | JSON format            |\n| `csv`     | Comma-separated values |\n| `parquet` | Apache Parquet         |\n| `arrow`   | Apache Arrow           |\n| `avro`    | Apache Avro            |\n\n## Schema Definition\n\nDefine the dataset structure:\n\n```typescript\nconst movieDataset = Dataset({\n  id: 'movies',\n  name: 'Movie Database',\n  format: 'parquet',\n  schema: {\n    id: 'Movie ID',\n    title: 'Movie title',\n    year: 'Release year (number)',\n    genres: ['Array of genre names'],\n    rating: 'Average rating (number)',\n    votes: 'Number of votes (number)',\n    runtime: 'Runtime in minutes (number)',\n    director: 'Director name',\n    cast: ['Array of actor names'],\n    plot: 'Plot summary',\n  },\n})\n```\n\n## Dataset Metadata\n\nAdd comprehensive metadata:\n\n```typescript\nconst movieDataset = Dataset({\n  id: 'movies',\n  name: 'Movie Database',\n  description: 'Comprehensive movie information from 1900 to present',\n  version: '2024.1',\n  format: 'parquet',\n  source: 's3://datasets/movies.parquet',\n  size: 1000000,           // Number of records\n  license: 'CC-BY-4.0',    // License identifier\n  updateFrequency: 'daily', // Update schedule\n  schema: { /* ... */ },\n})\n```\n\n## Licenses\n\nCommon data licenses:\n\n| License        | Description            |\n| -------------- | ---------------------- |\n| `CC0`          | Public domain          |\n| `CC-BY-4.0`    | Attribution            |\n| `CC-BY-SA-4.0` | Attribution ShareAlike |\n| `MIT`          | MIT License            |\n| `Apache-2.0`   | Apache License         |\n| `proprietary`  | Proprietary data       |\n\n## Update Frequency\n\n| Frequency   | Description        |\n| ----------- | ------------------ |\n| `realtime`  | Continuous updates |\n| `hourly`    | Every hour         |\n| `daily`     | Every day          |\n| `weekly`    | Every week         |\n| `monthly`   | Every month        |\n| `quarterly` | Every quarter      |\n| `yearly`    | Once a year        |\n| `static`    | No updates         |\n\n## Complete Example\n\n```typescript\nimport { Dataset } from 'digital-products'\n\nconst stockDataset = Dataset({\n  id: 'stock-prices',\n  name: 'Historical Stock Prices',\n  description: 'Daily stock prices for S&P 500 companies from 2000 to present',\n  version: '2024.12',\n  format: 'parquet',\n  source: 's3://financial-data/stocks.parquet',\n\n  schema: {\n    symbol: 'Stock ticker symbol',\n    date: 'Trading date (date)',\n    open: 'Opening price (number)',\n    high: 'Daily high (number)',\n    low: 'Daily low (number)',\n    close: 'Closing price (number)',\n    adjustedClose: 'Adjusted close (number)',\n    volume: 'Trading volume (number)',\n    dividends: 'Dividends paid (number)',\n    splits: 'Stock splits (number)',\n  },\n\n  size: 5000000,\n  license: 'CC-BY-4.0',\n  updateFrequency: 'daily',\n})\n```\n\n## E-commerce Dataset\n\n```typescript\nimport { Dataset } from 'digital-products'\n\nconst productsDataset = Dataset({\n  id: 'product-catalog',\n  name: 'Product Catalog',\n  description: 'Complete product catalog with pricing and inventory',\n  version: '1.0.0',\n  format: 'json',\n  source: './data/products.json',\n\n  schema: {\n    id: 'Product ID',\n    sku: 'Stock keeping unit',\n    name: 'Product name',\n    description: 'Product description',\n    category: 'Category path',\n    brand: 'Brand name',\n    price: 'Current price (number)',\n    salePrice: 'Sale price (number)',\n    currency: 'Price currency',\n    inStock: 'In stock (boolean)',\n    quantity: 'Available quantity (number)',\n    images: ['Array of image URLs'],\n    attributes: {\n      color: 'Product color',\n      size: 'Product size',\n      weight: 'Weight in kg (number)',\n    },\n    createdAt: 'Created date (date)',\n    updatedAt: 'Updated date (date)',\n  },\n\n  size: 50000,\n  license: 'proprietary',\n  updateFrequency: 'hourly',\n})\n```\n\n## ML Training Dataset\n\n```typescript\nimport { Dataset } from 'digital-products'\n\nconst sentimentDataset = Dataset({\n  id: 'sentiment-reviews',\n  name: 'Product Review Sentiment',\n  description: 'Labeled product reviews for sentiment analysis training',\n  version: '3.0.0',\n  format: 'csv',\n  source: 's3://ml-datasets/sentiment-reviews.csv',\n\n  schema: {\n    id: 'Review ID',\n    text: 'Review text',\n    rating: 'Star rating 1-5 (number)',\n    sentiment: 'positive | neutral | negative',\n    category: 'Product category',\n    verified: 'Verified purchase (boolean)',\n    helpfulVotes: 'Helpful vote count (number)',\n    date: 'Review date (date)',\n  },\n\n  size: 2500000,\n  license: 'CC-BY-4.0',\n  updateFrequency: 'monthly',\n})\n```\n\n## Type Definition\n\n```typescript\ninterface DatasetDefinition {\n  id: string\n  name: string\n  description?: string\n  version?: string\n  format?: 'json' | 'csv' | 'parquet' | 'arrow' | 'avro'\n  schema?: SimpleSchema\n  source?: string\n  size?: number\n  license?: string\n  updateFrequency?: 'realtime' | 'hourly' | 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly' | 'static'\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Product\n\nURL: https://primitives.org.ai/product\n\n> Compose primitives into complete products with declarative interfaces\n\n\n\nCompose Functions, Databases, Workflows, and Agents into complete, deployable products with declarative capability and interface definitions.\n\n## Defining a Product\n\n```typescript\nimport { product, api, ui, capability } from 'digital-products'\n\nconst supportPortal = product({\n  name: 'support-portal',\n  description: 'AI-powered customer support system',\n\n  // What the product can do\n  capabilities: [\n    capability('answer-questions', {\n      function: answerQuestions,\n      rateLimit: '100/minute',\n    }),\n    capability('create-ticket', {\n      workflow: ticketCreationWorkflow,\n      auth: 'authenticated',\n    }),\n    capability('escalate-to-human', {\n      function: escalateToHuman,\n      auth: 'authenticated',\n    }),\n  ],\n\n  // How users interact\n  interfaces: {\n    api: api({\n      version: 'v1',\n      endpoints: [\n        { path: '/ask', method: 'POST', capability: 'answer-questions' },\n        { path: '/tickets', method: 'POST', capability: 'create-ticket' },\n      ],\n    }),\n\n    widget: ui({\n      type: 'embedded-widget',\n      component: 'ChatWidget',\n      config: { theme: 'light', position: 'bottom-right' },\n    }),\n  },\n\n  // State and storage\n  database: supportDatabase,\n\n  // Autonomous actors\n  agents: [supportAgent, triageAgent],\n})\n```\n\n## Capabilities\n\nCapabilities are the atomic units of product functionality:\n\n```typescript\nconst searchCapability = capability('semantic-search', {\n  // The underlying function\n  function: semanticSearch,\n\n  // Access control\n  auth: {\n    required: true,\n    scopes: ['read:documents'],\n  },\n\n  // Rate limiting\n  rateLimit: {\n    requests: 1000,\n    period: 'hour',\n    by: 'user',\n  },\n\n  // Usage tracking\n  metering: {\n    unit: 'search',\n    track: ['user', 'organization'],\n  },\n\n  // Documentation\n  description: 'Search documents using natural language',\n  examples: [\n    { input: { query: 'quarterly revenue' }, output: { results: [...] } },\n  ],\n})\n```\n\n## API Interface\n\nDefine RESTful or GraphQL APIs:\n\n```typescript\nconst productApi = api({\n  version: 'v1',\n  basePath: '/api',\n\n  endpoints: [\n    {\n      path: '/documents',\n      method: 'GET',\n      capability: 'list-documents',\n      query: z.object({ limit: z.number().optional() }),\n    },\n    {\n      path: '/documents/:id',\n      method: 'GET',\n      capability: 'get-document',\n      params: z.object({ id: z.string() }),\n    },\n    {\n      path: '/documents',\n      method: 'POST',\n      capability: 'create-document',\n      body: documentSchema,\n    },\n    {\n      path: '/search',\n      method: 'POST',\n      capability: 'semantic-search',\n      body: z.object({ query: z.string() }),\n    },\n  ],\n\n  middleware: [\n    authenticate,\n    rateLimit,\n    logRequest,\n  ],\n})\n```\n\n## UI Components\n\nProducts can include user interfaces:\n\n```typescript\nconst productUI = ui({\n  type: 'web-app',\n\n  pages: {\n    '/': homePage,\n    '/dashboard': dashboardPage,\n    '/documents/:id': documentPage,\n  },\n\n  components: {\n    SearchBar: searchBarComponent,\n    DocumentList: documentListComponent,\n    ChatWidget: chatWidgetComponent,\n  },\n\n  theme: {\n    colors: { primary: '#3b82f6' },\n    fonts: { body: 'Inter' },\n  },\n})\n```\n\n## Multi-Tenancy\n\nBuilt-in support for SaaS products:\n\n```typescript\nconst saasProduct = product({\n  name: 'saas-platform',\n\n  tenancy: {\n    type: 'organization',\n    isolation: 'row-level',\n\n    tiers: {\n      free: {\n        limits: { users: 5, storage: '1GB' },\n        features: ['basic-search'],\n      },\n      pro: {\n        limits: { users: 50, storage: '100GB' },\n        features: ['basic-search', 'ai-features', 'api-access'],\n      },\n      enterprise: {\n        limits: { users: 'unlimited', storage: 'unlimited' },\n        features: ['*'],\n        support: 'dedicated',\n      },\n    },\n  },\n})\n```\n\n## Deployment\n\nProducts deploy as complete units:\n\n```typescript\n// Deploy to production\nawait supportPortal.deploy({\n  environment: 'production',\n  region: 'us-east-1',\n\n  scaling: {\n    min: 2,\n    max: 10,\n    target: { cpu: 70 },\n  },\n\n  domains: {\n    api: 'api.support.example.com',\n    app: 'support.example.com',\n  },\n})\n\n// Check deployment status\nconst status = await supportPortal.status()\nconsole.log(status)\n// {\n//   environment: 'production',\n//   version: '1.2.3',\n//   health: 'healthy',\n//   instances: 3,\n//   endpoints: {\n//     api: 'https://api.support.example.com',\n//     app: 'https://support.example.com',\n//   },\n// }\n```\n\n## Versioning\n\nManage product versions and migrations:\n\n```typescript\nconst productV2 = product({\n  name: 'my-product',\n  version: '2.0.0',\n\n  migration: {\n    from: '1.x',\n    steps: [\n      { type: 'schema', migration: 'add-new-fields' },\n      { type: 'backfill', function: backfillNewData },\n      { type: 'deprecate', capability: 'old-search' },\n    ],\n  },\n\n  compatibility: {\n    apiVersions: ['v1', 'v2'],\n    deprecations: [\n      { version: 'v1', sunset: '2024-12-31' },\n    ],\n  },\n})\n```\n\n## Observability\n\nProducts come with built-in observability:\n\n```typescript\n// Metrics\nconst metrics = await supportPortal.metrics({\n  period: 'last-24h',\n  include: ['requests', 'latency', 'errors', 'usage'],\n})\n\n// Logs\nconst logs = await supportPortal.logs({\n  level: 'error',\n  since: lastHour,\n})\n\n// Traces\nconst traces = await supportPortal.traces({\n  capability: 'answer-questions',\n  sample: 0.1,\n})\n```\n\n\n# MCP\n\nURL: https://primitives.org.ai/product/mcp\n\n> Define Model Context Protocol servers\n\n\n\n# MCP\n\nThe `MCP()` function defines Model Context Protocol servers for AI tool integration.\n\n## What is MCP?\n\nModel Context Protocol (MCP) is a standard for connecting AI models to external tools, data sources, and capabilities. MCP servers expose:\n\n* **Tools**: Functions that AI can call\n* **Resources**: Data sources AI can access\n* **Prompts**: Pre-defined prompt templates\n\n## Basic Usage\n\n```typescript\nimport { MCP, Tool, Resource, Prompt } from 'digital-products'\n\nconst mcpServer = MCP({\n  id: 'my-mcp',\n  name: 'My MCP Server',\n  description: 'Custom MCP server for AI tools',\n  version: '1.0.0',\n  transport: 'stdio',\n})\n```\n\n## Transport Types\n\n| Transport   | Description           |\n| ----------- | --------------------- |\n| `stdio`     | Standard input/output |\n| `http`      | HTTP server           |\n| `websocket` | WebSocket connection  |\n\n## Tools\n\nDefine tools that AI can invoke:\n\n```typescript\nimport { MCP, Tool } from 'digital-products'\n\nconst mcpServer = MCP({\n  id: 'file-tools',\n  name: 'File Tools',\n  version: '1.0.0',\n  transport: 'stdio',\n  tools: [\n    Tool('searchFiles', 'Search for files in the project', {\n      query: 'Search query',\n      path: 'Directory to search in',\n      maxResults: 'Maximum results (number)',\n    }),\n    Tool('readFile', 'Read file contents', {\n      path: 'File path to read',\n    }),\n    Tool('writeFile', 'Write content to file', {\n      path: 'File path to write',\n      content: 'Content to write',\n    }),\n    Tool('listDirectory', 'List directory contents', {\n      path: 'Directory path',\n      recursive: 'Include subdirectories (boolean)',\n    }),\n  ],\n})\n```\n\n### Tool Helper\n\n```typescript\nTool(name, description, parameters)\n```\n\n| Parameter     | Type   | Description        |\n| ------------- | ------ | ------------------ |\n| `name`        | string | Tool identifier    |\n| `description` | string | What the tool does |\n| `parameters`  | schema | Input parameters   |\n\n## Resources\n\nExpose data sources:\n\n```typescript\nimport { MCP, Resource } from 'digital-products'\n\nconst mcpServer = MCP({\n  id: 'data-server',\n  name: 'Data Server',\n  version: '1.0.0',\n  transport: 'http',\n  resources: [\n    Resource('file://project', 'Project Files', 'Access to all project files'),\n    Resource('db://users', 'User Database', 'Read-only access to user data'),\n    Resource('api://weather', 'Weather API', 'Current weather information'),\n  ],\n})\n```\n\n### Resource Helper\n\n```typescript\nResource(uri, name, description)\n```\n\n| Parameter     | Type   | Description          |\n| ------------- | ------ | -------------------- |\n| `uri`         | string | Resource URI         |\n| `name`        | string | Display name         |\n| `description` | string | Resource description |\n\n## Prompts\n\nDefine reusable prompt templates:\n\n```typescript\nimport { MCP, Prompt } from 'digital-products'\n\nconst mcpServer = MCP({\n  id: 'prompt-server',\n  name: 'Prompt Server',\n  version: '1.0.0',\n  transport: 'stdio',\n  prompts: [\n    Prompt(\n      'codeReview',\n      'Review code for best practices',\n      'Review the following code for best practices, security issues, and potential improvements:\\n\\n{{code}}',\n      { code: 'Code to review' }\n    ),\n    Prompt(\n      'summarize',\n      'Summarize text content',\n      'Summarize the following content in {{length}} sentences:\\n\\n{{content}}',\n      { content: 'Text to summarize', length: 'Number of sentences' }\n    ),\n    Prompt(\n      'translate',\n      'Translate text to another language',\n      'Translate the following text to {{language}}:\\n\\n{{text}}',\n      { text: 'Text to translate', language: 'Target language' }\n    ),\n  ],\n})\n```\n\n### Prompt Helper\n\n```typescript\nPrompt(name, description, template, parameters)\n```\n\n| Parameter     | Type   | Description                     |\n| ------------- | ------ | ------------------------------- |\n| `name`        | string | Prompt identifier               |\n| `description` | string | What the prompt does            |\n| `template`    | string | Prompt template with `{{vars}}` |\n| `parameters`  | schema | Template parameters             |\n\n## Complete Example\n\n````typescript\nimport { MCP, Tool, Resource, Prompt } from 'digital-products'\n\nconst devToolsMCP = MCP({\n  id: 'dev-tools',\n  name: 'Developer Tools MCP',\n  description: 'MCP server for development workflows',\n  version: '1.0.0',\n  transport: 'stdio',\n\n  tools: [\n    Tool('searchCode', 'Search codebase for patterns', {\n      pattern: 'Search pattern (regex)',\n      fileTypes: 'File extensions to search',\n      caseSensitive: 'Case sensitive (boolean)',\n    }),\n    Tool('runTests', 'Run test suite', {\n      path: 'Test path or pattern',\n      coverage: 'Generate coverage (boolean)',\n    }),\n    Tool('formatCode', 'Format code file', {\n      path: 'File to format',\n      config: 'Formatter config',\n    }),\n    Tool('lintCode', 'Lint code for issues', {\n      path: 'Path to lint',\n      fix: 'Auto-fix issues (boolean)',\n    }),\n    Tool('gitStatus', 'Get git repository status', {\n      path: 'Repository path',\n    }),\n    Tool('gitDiff', 'Get git diff', {\n      staged: 'Show staged changes (boolean)',\n    }),\n  ],\n\n  resources: [\n    Resource('file://src', 'Source Code', 'Project source files'),\n    Resource('file://tests', 'Test Files', 'Test suite files'),\n    Resource('file://docs', 'Documentation', 'Project documentation'),\n    Resource('git://log', 'Git History', 'Recent commit history'),\n  ],\n\n  prompts: [\n    Prompt(\n      'reviewPR',\n      'Review a pull request',\n      'Review this pull request:\\n\\nTitle: {{title}}\\n\\nDescription: {{description}}\\n\\nChanges:\\n{{diff}}\\n\\nProvide feedback on code quality, potential issues, and suggestions.',\n      { title: 'PR title', description: 'PR description', diff: 'Code diff' }\n    ),\n    Prompt(\n      'explainCode',\n      'Explain code functionality',\n      'Explain what this code does:\\n\\n```{{language}}\\n{{code}}\\n```',\n      { language: 'Programming language', code: 'Code to explain' }\n    ),\n    Prompt(\n      'generateTests',\n      'Generate tests for code',\n      'Generate unit tests for this {{language}} code:\\n\\n```{{language}}\\n{{code}}\\n```\\n\\nUse {{framework}} testing framework.',\n      { language: 'Language', code: 'Code to test', framework: 'Test framework' }\n    ),\n  ],\n})\n````\n\n## Database MCP Server\n\n```typescript\nimport { MCP, Tool, Resource } from 'digital-products'\n\nconst databaseMCP = MCP({\n  id: 'database-mcp',\n  name: 'Database Tools',\n  description: 'MCP server for database operations',\n  version: '1.0.0',\n  transport: 'http',\n\n  tools: [\n    Tool('query', 'Execute SQL query', {\n      sql: 'SQL query to execute',\n      database: 'Database name',\n    }),\n    Tool('describe', 'Describe table schema', {\n      table: 'Table name',\n      database: 'Database name',\n    }),\n    Tool('listTables', 'List all tables', {\n      database: 'Database name',\n    }),\n  ],\n\n  resources: [\n    Resource('db://postgres/main', 'Main Database', 'Production database'),\n    Resource('db://postgres/analytics', 'Analytics DB', 'Analytics database'),\n  ],\n})\n```\n\n## Type Definition\n\n```typescript\ninterface MCPDefinition {\n  id: string\n  name: string\n  description?: string\n  version?: string\n  transport?: 'stdio' | 'http' | 'websocket'\n  tools?: ToolDefinition[]\n  resources?: ResourceDefinition[]\n  prompts?: PromptDefinition[]\n  auth?: MCPAuthDefinition\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Registry\n\nURL: https://primitives.org.ai/product/registry\n\n> Manage products centrally\n\n\n\n# Registry\n\nThe `registry` provides a central place to store, retrieve, and manage all your products.\n\n## Basic Usage\n\n```typescript\nimport { registry, App, API, Site } from 'digital-products'\n\n// Products are automatically registered when created\nconst myApp = App({ id: 'my-app', name: 'My App' })\nconst myAPI = API({ id: 'my-api', name: 'My API' })\nconst mySite = Site({ id: 'my-site', name: 'My Site' })\n\n// List all products\nconst products = registry.list()\nconsole.log(products.map(p => p.name))\n// ['My App', 'My API', 'My Site']\n```\n\n## Methods\n\n### list()\n\nGet all registered products:\n\n```typescript\nconst allProducts = registry.list()\nconsole.log(allProducts.length)  // Number of products\n```\n\n### get(id)\n\nRetrieve a specific product by ID:\n\n```typescript\nconst myApp = registry.get('my-app')\nif (myApp) {\n  console.log(myApp.name)  // 'My App'\n}\n```\n\n### listByType(type)\n\nList products by type:\n\n```typescript\n// Get all apps\nconst apps = registry.listByType('app')\nconsole.log(apps.map(a => a.name))\n\n// Get all APIs\nconst apis = registry.listByType('api')\n\n// Get all sites\nconst sites = registry.listByType('site')\n\n// Available types: 'product', 'app', 'api', 'content', 'data', 'dataset', 'site', 'mcp', 'sdk'\n```\n\n### remove(id)\n\nRemove a product from the registry:\n\n```typescript\nregistry.remove('my-app')\nconsole.log(registry.get('my-app'))  // undefined\n```\n\n### clear()\n\nRemove all products:\n\n```typescript\nregistry.clear()\nconsole.log(registry.list().length)  // 0\n```\n\n## Product Discovery\n\nUse the registry for product discovery and introspection:\n\n```typescript\nimport { registry } from 'digital-products'\n\n// List all APIs in the system\nconst apis = registry.listByType('api')\nfor (const api of apis) {\n  console.log(`${api.name}: ${api.baseUrl}`)\n}\n\n// Find products by criteria\nconst allProducts = registry.list()\nconst published = allProducts.filter(p => p.version && !p.version.includes('alpha'))\n```\n\n## Example: API Gateway\n\nBuild an API gateway from registered APIs:\n\n```typescript\nimport { registry, API } from 'digital-products'\n\n// Register multiple APIs\nAPI({ id: 'users-api', name: 'Users', baseUrl: '/api/users' })\nAPI({ id: 'orders-api', name: 'Orders', baseUrl: '/api/orders' })\nAPI({ id: 'products-api', name: 'Products', baseUrl: '/api/products' })\n\n// Create gateway from registry\nfunction createGateway() {\n  const apis = registry.listByType('api')\n\n  return {\n    routes: apis.map(api => ({\n      prefix: api.baseUrl,\n      target: api,\n    })),\n\n    getAPI(id: string) {\n      return registry.get(id)\n    },\n  }\n}\n\nconst gateway = createGateway()\n```\n\n## Example: Documentation Generator\n\nGenerate documentation from registered products:\n\n```typescript\nimport { registry } from 'digital-products'\n\nfunction generateDocs() {\n  const products = registry.list()\n\n  return products.map(product => ({\n    id: product.id,\n    name: product.name,\n    description: product.description,\n    version: product.version,\n    type: product.type,\n  }))\n}\n\nconst docs = generateDocs()\nconsole.log(JSON.stringify(docs, null, 2))\n```\n\n## Example: Health Check\n\nCheck health of all registered services:\n\n```typescript\nimport { registry } from 'digital-products'\n\nasync function healthCheck() {\n  const apis = registry.listByType('api')\n\n  const results = await Promise.all(\n    apis.map(async (api) => {\n      try {\n        const response = await fetch(`${api.baseUrl}/health`)\n        return {\n          id: api.id,\n          name: api.name,\n          healthy: response.ok,\n          status: response.status,\n        }\n      } catch (error) {\n        return {\n          id: api.id,\n          name: api.name,\n          healthy: false,\n          error: error.message,\n        }\n      }\n    })\n  )\n\n  return results\n}\n```\n\n## Type Safety\n\nThe registry preserves type information:\n\n```typescript\nimport { registry, App, API } from 'digital-products'\n\n// Create typed products\nconst app = App({ id: 'typed-app', name: 'Typed App', framework: 'react' })\nconst api = API({ id: 'typed-api', name: 'Typed API', style: 'rest' })\n\n// Get with type assertion\nconst retrievedApp = registry.get('typed-app') as AppDefinition\nconsole.log(retrievedApp.framework)  // 'react'\n\n// Or use listByType for automatic typing\nconst apps = registry.listByType('app')\napps[0].framework  // TypeScript knows this is AppDefinition\n```\n\n## Clearing for Tests\n\nIn tests, clear the registry between runs:\n\n```typescript\nimport { registry } from 'digital-products'\n\ndescribe('My Tests', () => {\n  beforeEach(() => {\n    registry.clear()\n  })\n\n  it('should register products', () => {\n    App({ id: 'test-app', name: 'Test' })\n    expect(registry.list().length).toBe(1)\n  })\n})\n```\n\n\n# SDK\n\nURL: https://primitives.org.ai/product/sdk\n\n> Define software development kits\n\n\n\n# SDK\n\nThe `SDK()` function defines software development kits with exports, documentation, and examples.\n\n## Basic Usage\n\n```typescript\nimport { SDK } from 'digital-products'\n\nconst mySDK = SDK({\n  id: 'my-sdk',\n  name: 'My SDK',\n  description: 'JavaScript SDK for My API',\n  version: '1.0.0',\n  language: 'typescript',\n  api: 'my-api',\n})\n```\n\n## Languages\n\n| Language     | Description           |\n| ------------ | --------------------- |\n| `typescript` | TypeScript/JavaScript |\n| `javascript` | JavaScript only       |\n| `python`     | Python                |\n| `go`         | Go                    |\n| `rust`       | Rust                  |\n| `java`       | Java                  |\n| `csharp`     | C#                    |\n| `ruby`       | Ruby                  |\n| `php`        | PHP                   |\n\n## Exports\n\nDefine what the SDK exports:\n\n```typescript\nimport { SDK, Export } from 'digital-products'\n\nconst mySDK = SDK({\n  id: 'my-sdk',\n  name: 'My SDK',\n  version: '1.0.0',\n  language: 'typescript',\n  api: 'my-api',\n  exports: [\n    Export('function', 'createClient', 'Create an API client', {\n      parameters: {\n        apiKey: 'API key for authentication',\n        baseUrl: 'Optional base URL',\n      },\n      returns: 'API client instance',\n    }),\n    Export('class', 'APIClient', 'Main API client', {\n      methods: [\n        Export('function', 'get', 'GET request', {\n          parameters: { path: 'Request path' },\n          returns: 'Response data',\n        }),\n        Export('function', 'post', 'POST request', {\n          parameters: { path: 'Request path', data: 'Request body' },\n          returns: 'Response data',\n        }),\n        Export('function', 'put', 'PUT request', {\n          parameters: { path: 'Request path', data: 'Request body' },\n          returns: 'Response data',\n        }),\n        Export('function', 'delete', 'DELETE request', {\n          parameters: { path: 'Request path' },\n          returns: 'Response data',\n        }),\n      ],\n    }),\n    Export('type', 'ClientOptions', 'Client configuration options', {\n      properties: {\n        apiKey: 'API key',\n        baseUrl: 'Base URL',\n        timeout: 'Request timeout (number)',\n      },\n    }),\n  ],\n})\n```\n\n### Export Types\n\n| Type        | Description          |\n| ----------- | -------------------- |\n| `function`  | Exported function    |\n| `class`     | Exported class       |\n| `type`      | Type definition      |\n| `const`     | Constant value       |\n| `interface` | Interface definition |\n\n## Installation\n\nSpecify installation instructions:\n\n```typescript\nconst mySDK = SDK({\n  id: 'my-sdk',\n  name: 'My SDK',\n  version: '1.0.0',\n  language: 'typescript',\n  install: 'npm install my-sdk',\n})\n```\n\n## Examples\n\nAdd usage examples:\n\n```typescript\nimport { SDK, Export, Example } from 'digital-products'\n\nconst mySDK = SDK({\n  id: 'my-sdk',\n  name: 'My SDK',\n  version: '1.0.0',\n  language: 'typescript',\n  api: 'my-api',\n  install: 'npm install my-sdk',\n  examples: [\n    Example(\n      'Basic Usage',\n      'Create a client and make a request',\n      `import { createClient } from 'my-sdk'\n\nconst client = createClient({ apiKey: 'YOUR_API_KEY' })\nconst users = await client.get('/users')\nconsole.log(users)`,\n      '{ users: [...] }'\n    ),\n    Example(\n      'With TypeScript',\n      'Type-safe API calls',\n      `import { createClient, User } from 'my-sdk'\n\nconst client = createClient({ apiKey: 'YOUR_API_KEY' })\nconst user = await client.get<User>('/users/123')\nconsole.log(user.name)`,\n      '{ id: \"123\", name: \"John\" }'\n    ),\n    Example(\n      'Error Handling',\n      'Handle API errors',\n      `import { createClient, APIError } from 'my-sdk'\n\nconst client = createClient({ apiKey: 'YOUR_API_KEY' })\n\ntry {\n  const user = await client.get('/users/999')\n} catch (error) {\n  if (error instanceof APIError) {\n    console.error(\\`API Error: \\${error.status} - \\${error.message}\\`)\n  }\n}`,\n      'API Error: 404 - User not found'\n    ),\n  ],\n})\n```\n\n### Example Helper\n\n```typescript\nExample(title, description, code, output?)\n```\n\n| Parameter     | Type   | Description            |\n| ------------- | ------ | ---------------------- |\n| `title`       | string | Example title          |\n| `description` | string | What the example shows |\n| `code`        | string | Code snippet           |\n| `output`      | string | Expected output        |\n\n## Complete Example\n\n```typescript\nimport { SDK, Export, Example } from 'digital-products'\n\nconst paymentsSDK = SDK({\n  id: 'payments-sdk',\n  name: 'Payments SDK',\n  description: 'Official SDK for the Payments API',\n  version: '2.0.0',\n  language: 'typescript',\n  api: 'payments-api',\n  install: 'npm install @company/payments-sdk',\n\n  exports: [\n    Export('function', 'createPaymentsClient', 'Create a payments client', {\n      parameters: {\n        apiKey: 'Your API key',\n        environment: 'sandbox | production',\n      },\n      returns: 'PaymentsClient instance',\n    }),\n\n    Export('class', 'PaymentsClient', 'Main payments client', {\n      methods: [\n        Export('function', 'createPayment', 'Create a payment', {\n          parameters: {\n            amount: 'Amount in cents (number)',\n            currency: 'Currency code',\n            customerId: 'Customer ID',\n          },\n          returns: 'Payment object',\n        }),\n        Export('function', 'getPayment', 'Get payment by ID', {\n          parameters: { paymentId: 'Payment ID' },\n          returns: 'Payment object',\n        }),\n        Export('function', 'refundPayment', 'Refund a payment', {\n          parameters: {\n            paymentId: 'Payment ID',\n            amount: 'Refund amount (optional)',\n          },\n          returns: 'Refund object',\n        }),\n        Export('function', 'listPayments', 'List payments', {\n          parameters: {\n            customerId: 'Filter by customer',\n            limit: 'Max results (number)',\n          },\n          returns: 'Array of payments',\n        }),\n      ],\n    }),\n\n    Export('type', 'Payment', 'Payment object', {\n      properties: {\n        id: 'Payment ID',\n        amount: 'Amount in cents (number)',\n        currency: 'Currency code',\n        status: 'pending | succeeded | failed',\n        customerId: 'Customer ID',\n        createdAt: 'Created timestamp (date)',\n      },\n    }),\n\n    Export('type', 'PaymentError', 'Payment error', {\n      properties: {\n        code: 'Error code',\n        message: 'Error message',\n        type: 'card_error | api_error | validation_error',\n      },\n    }),\n  ],\n\n  examples: [\n    Example(\n      'Create a Payment',\n      'Charge a customer',\n      `import { createPaymentsClient } from '@company/payments-sdk'\n\nconst payments = createPaymentsClient({\n  apiKey: 'sk_test_xxx',\n  environment: 'sandbox',\n})\n\nconst payment = await payments.createPayment({\n  amount: 2000, // $20.00\n  currency: 'usd',\n  customerId: 'cus_123',\n})\n\nconsole.log(payment.id)`,\n      'pay_abc123'\n    ),\n    Example(\n      'Process Refund',\n      'Refund a payment',\n      `const refund = await payments.refundPayment({\n  paymentId: 'pay_abc123',\n  amount: 1000, // Partial refund of $10\n})\n\nconsole.log(refund.status)`,\n      'succeeded'\n    ),\n  ],\n})\n```\n\n## Type Definition\n\n```typescript\ninterface SDKDefinition {\n  id: string\n  name: string\n  description?: string\n  version?: string\n  language?: 'typescript' | 'javascript' | 'python' | 'go' | 'rust' | 'java' | 'csharp' | 'ruby' | 'php'\n  api?: string\n  exports?: ExportDefinition[]\n  install?: string\n  examples?: ExampleDefinition[]\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Site\n\nURL: https://primitives.org.ai/product/site\n\n> Define websites and documentation\n\n\n\n# Site\n\nThe `Site()` function defines websites and documentation sites with navigation, SEO, and analytics.\n\n## Basic Usage\n\n```typescript\nimport { Site } from 'digital-products'\n\nconst docsSite = Site({\n  id: 'docs',\n  name: 'Documentation Site',\n  description: 'Product documentation',\n  version: '1.0.0',\n  generator: 'fumadocs',\n})\n```\n\n## Site Generators\n\n| Generator    | Description            |\n| ------------ | ---------------------- |\n| `fumadocs`   | Fumadocs documentation |\n| `next`       | Next.js                |\n| `astro`      | Astro                  |\n| `vitepress`  | VitePress              |\n| `docusaurus` | Docusaurus             |\n| `gatsby`     | Gatsby                 |\n\n## Site Structure\n\nDefine pages and content:\n\n```typescript\nconst docsSite = Site({\n  id: 'docs',\n  name: 'Documentation',\n  generator: 'fumadocs',\n  structure: {\n    home: '/docs/index.mdx',\n    docs: [\n      '/docs/getting-started.mdx',\n      '/docs/installation.mdx',\n      '/docs/api-reference.mdx',\n      '/docs/guides/authentication.mdx',\n      '/docs/guides/deployment.mdx',\n    ],\n  },\n})\n```\n\n## Navigation\n\nBuild site navigation:\n\n```typescript\nimport { Site, Nav } from 'digital-products'\n\nconst docsSite = Site({\n  id: 'docs',\n  name: 'Documentation',\n  generator: 'fumadocs',\n  navigation: [\n    Nav('Home', '/'),\n    Nav('Docs', '/docs', {\n      children: [\n        Nav('Getting Started', '/docs/getting-started'),\n        Nav('Installation', '/docs/installation'),\n        Nav('Guides', '/docs/guides', {\n          children: [\n            Nav('Authentication', '/docs/guides/auth'),\n            Nav('Deployment', '/docs/guides/deploy'),\n          ],\n        }),\n        Nav('API Reference', '/docs/api'),\n      ],\n    }),\n    Nav('Blog', '/blog'),\n    Nav('GitHub', 'https://github.com/example/repo', {\n      external: true,\n    }),\n  ],\n})\n```\n\n## SEO Configuration\n\nOptimize for search engines:\n\n```typescript\nimport { Site, SEO } from 'digital-products'\n\nconst docsSite = Site({\n  id: 'docs',\n  name: 'Documentation',\n  generator: 'fumadocs',\n  seo: SEO({\n    titleTemplate: '%s | My Product',\n    description: 'Official documentation for My Product',\n    keywords: ['docs', 'api', 'reference', 'guide'],\n    ogImage: '/og-image.png',\n    twitterCard: 'summary_large_image',\n    twitterSite: '@myproduct',\n  }),\n})\n```\n\n### SEO Options\n\n| Option          | Description              |\n| --------------- | ------------------------ |\n| `titleTemplate` | Page title template      |\n| `description`   | Default meta description |\n| `keywords`      | SEO keywords             |\n| `ogImage`       | Open Graph image         |\n| `twitterCard`   | Twitter card type        |\n| `twitterSite`   | Twitter @handle          |\n\n## Analytics\n\nAdd analytics tracking:\n\n```typescript\nimport { Site, Analytics } from 'digital-products'\n\nconst docsSite = Site({\n  id: 'docs',\n  name: 'Documentation',\n  generator: 'fumadocs',\n  analytics: Analytics('plausible', 'docs.example.com'),\n})\n```\n\n### Analytics Providers\n\n| Provider    | Usage                                  |\n| ----------- | -------------------------------------- |\n| `plausible` | `Analytics('plausible', 'domain.com')` |\n| `google`    | `Analytics('google', 'UA-XXXXX')`      |\n| `fathom`    | `Analytics('fathom', 'SITEID')`        |\n| `posthog`   | `Analytics('posthog', 'KEY')`          |\n\n## Complete Example\n\n```typescript\nimport { Site, Nav, SEO, Analytics } from 'digital-products'\n\nconst productDocs = Site({\n  id: 'product-docs',\n  name: 'Product Documentation',\n  description: 'Complete documentation for Product',\n  version: '2.0.0',\n  generator: 'fumadocs',\n\n  structure: {\n    home: '/docs/index.mdx',\n    docs: [\n      '/docs/introduction.mdx',\n      '/docs/quickstart.mdx',\n      '/docs/installation.mdx',\n      '/docs/configuration.mdx',\n      '/docs/guides/index.mdx',\n      '/docs/api/index.mdx',\n      '/docs/examples/index.mdx',\n      '/docs/changelog.mdx',\n    ],\n  },\n\n  navigation: [\n    Nav('Docs', '/docs', {\n      children: [\n        Nav('Introduction', '/docs/introduction'),\n        Nav('Quickstart', '/docs/quickstart'),\n        Nav('Guides', '/docs/guides', {\n          children: [\n            Nav('Authentication', '/docs/guides/auth'),\n            Nav('Database', '/docs/guides/database'),\n            Nav('Deployment', '/docs/guides/deployment'),\n          ],\n        }),\n        Nav('API Reference', '/docs/api'),\n        Nav('Examples', '/docs/examples'),\n      ],\n    }),\n    Nav('Blog', '/blog'),\n    Nav('Changelog', '/docs/changelog'),\n    Nav('GitHub', 'https://github.com/example/product', { external: true }),\n  ],\n\n  seo: SEO({\n    titleTemplate: '%s - Product Docs',\n    description: 'Learn how to build with Product',\n    keywords: ['product', 'documentation', 'api', 'sdk'],\n    ogImage: 'https://docs.product.com/og.png',\n    twitterCard: 'summary_large_image',\n    twitterSite: '@product',\n  }),\n\n  analytics: Analytics('plausible', 'docs.product.com'),\n})\n```\n\n## Marketing Site\n\n```typescript\nimport { Site, Nav, SEO, Analytics } from 'digital-products'\n\nconst marketingSite = Site({\n  id: 'marketing',\n  name: 'Product Website',\n  description: 'Marketing website',\n  version: '1.0.0',\n  generator: 'next',\n\n  structure: {\n    home: '/index.tsx',\n    pages: [\n      '/features.tsx',\n      '/pricing.tsx',\n      '/about.tsx',\n      '/contact.tsx',\n      '/blog/index.tsx',\n    ],\n  },\n\n  navigation: [\n    Nav('Home', '/'),\n    Nav('Features', '/features'),\n    Nav('Pricing', '/pricing'),\n    Nav('Blog', '/blog'),\n    Nav('Docs', 'https://docs.product.com', { external: true }),\n    Nav('Login', '/login'),\n    Nav('Sign Up', '/signup', { cta: true }),\n  ],\n\n  seo: SEO({\n    titleTemplate: '%s | Product',\n    description: 'The best product for your needs',\n    ogImage: '/og.png',\n  }),\n\n  analytics: Analytics('google', 'G-XXXXXXXXXX'),\n})\n```\n\n## Type Definition\n\n```typescript\ninterface SiteDefinition {\n  id: string\n  name: string\n  description?: string\n  version?: string\n  generator?: 'fumadocs' | 'next' | 'astro' | 'vitepress' | 'docusaurus' | 'gatsby'\n  structure?: {\n    home: string\n    docs?: string[]\n    pages?: string[]\n  }\n  navigation?: NavDefinition[]\n  seo?: SEODefinition\n  analytics?: AnalyticsDefinition\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Error Handling\n\nURL: https://primitives.org.ai/workflow/errors\n\n> Handle failures and implement recovery strategies\n\n\n\n# Error Handling\n\nWorkflows provide robust error handling with automatic retries, compensation, and recovery strategies.\n\n## Basic Error Handling\n\n```typescript\nimport { workflow, step } from 'ai-workflows'\n\nconst safeWorkflow = workflow({\n  name: 'safe-processing',\n  execute: async (ctx, input) => {\n    try {\n      await step('risky', () => riskyOperation(input))\n    } catch (error) {\n      await step('fallback', () => fallbackOperation(input))\n    }\n  },\n})\n```\n\n## Automatic Retries\n\nConfigure retry behavior for individual steps:\n\n```typescript\nawait step('api-call', () => callExternalAPI(data), {\n  retry: {\n    maxAttempts: 5,\n    backoff: 'exponential',\n    initialDelay: 1000,    // 1 second\n    maxDelay: 60000,       // 1 minute max\n    factor: 2,             // Double each time\n  },\n})\n```\n\n### Backoff Strategies\n\n```typescript\n// Linear backoff: 1s, 2s, 3s, 4s...\n{ backoff: 'linear', initialDelay: 1000 }\n\n// Exponential backoff: 1s, 2s, 4s, 8s...\n{ backoff: 'exponential', initialDelay: 1000, factor: 2 }\n\n// Fixed delay: 5s, 5s, 5s...\n{ backoff: 'fixed', initialDelay: 5000 }\n\n// Custom backoff function\n{ backoff: (attempt) => attempt * 1000 + Math.random() * 500 }\n```\n\n### Retry Conditions\n\n```typescript\nawait step('selective-retry', () => operation(), {\n  retry: {\n    maxAttempts: 3,\n    retryIf: (error) => {\n      // Only retry on specific errors\n      return error.code === 'RATE_LIMIT' ||\n             error.code === 'TIMEOUT' ||\n             error.status >= 500\n    },\n  },\n})\n```\n\n## Compensation (Sagas)\n\nUndo completed steps when later steps fail:\n\n```typescript\nconst orderWorkflow = workflow({\n  name: 'order-saga',\n  execute: async (ctx, order) => {\n    // Each step defines its compensation\n    const reservation = await step(\n      'reserve-inventory',\n      () => reserveInventory(order.items),\n      {\n        compensate: (result) => releaseInventory(result.reservationId),\n      }\n    )\n\n    const payment = await step(\n      'charge-payment',\n      () => chargePayment(order.payment),\n      {\n        compensate: (result) => refundPayment(result.transactionId),\n      }\n    )\n\n    // If shipping fails, previous steps are compensated automatically\n    await step('ship-order', () => shipOrder(order))\n  },\n})\n```\n\n### Manual Compensation\n\n```typescript\nconst workflow = workflow({\n  execute: async (ctx, order) => {\n    const payment = await step('charge', () => chargePayment(order))\n\n    try {\n      await step('fulfill', () => fulfillOrder(order))\n    } catch (error) {\n      // Manual compensation\n      await step('refund', () => refundPayment(payment.transactionId))\n      throw error  // Re-throw to mark workflow as failed\n    }\n  },\n})\n```\n\n## Error Types\n\n### Workflow Errors\n\n```typescript\nimport { WorkflowError, StepError, TimeoutError } from 'ai-workflows'\n\ntry {\n  await workflow.run(input)\n} catch (error) {\n  if (error instanceof TimeoutError) {\n    console.log('Workflow timed out')\n  } else if (error instanceof StepError) {\n    console.log(`Step \"${error.stepName}\" failed:`, error.cause)\n  } else if (error instanceof WorkflowError) {\n    console.log('Workflow failed:', error.message)\n  }\n}\n```\n\n### Custom Errors\n\n```typescript\nimport { WorkflowError } from 'ai-workflows'\n\nclass PaymentError extends WorkflowError {\n  constructor(message: string, public transactionId: string) {\n    super(message, 'PAYMENT_ERROR')\n  }\n}\n\n// Throw in step\nawait step('payment', async () => {\n  const result = await processPayment(order)\n  if (!result.success) {\n    throw new PaymentError('Payment declined', result.transactionId)\n  }\n  return result\n})\n```\n\n## Dead Letter Queue\n\nHandle permanently failed workflows:\n\n```typescript\nconst workflow = workflow({\n  name: 'order-processing',\n\n  onFailed: async (ctx, error) => {\n    // Send to dead letter queue for manual review\n    await sendToDeadLetterQueue({\n      workflowId: ctx.id,\n      input: ctx.input,\n      error: error.message,\n      stack: error.stack,\n    })\n\n    // Notify operations team\n    await notifyOps({\n      type: 'workflow-failed',\n      workflow: ctx.name,\n      id: ctx.id,\n    })\n  },\n\n  execute: async (ctx, input) => {\n    // ... workflow logic\n  },\n})\n```\n\n## Circuit Breaker\n\nPrevent cascade failures:\n\n```typescript\nimport { circuitBreaker } from 'ai-workflows'\n\nconst protectedCall = circuitBreaker({\n  name: 'external-api',\n  threshold: 5,           // Open after 5 failures\n  timeout: 30000,         // Stay open for 30 seconds\n  halfOpenRequests: 3,    // Test with 3 requests\n})\n\nawait step('api-call', () =>\n  protectedCall(() => callExternalAPI(data))\n)\n```\n\n## Workflow Recovery\n\n### Resume Failed Workflow\n\n```typescript\n// Get failed workflow\nconst failed = await workflow.get('wf_123')\n\n// Retry from failed step\nawait failed.retry()\n\n// Or retry from specific step\nawait failed.retry({ fromStep: 'payment' })\n```\n\n### Skip Failed Step\n\n```typescript\n// Skip problematic step and continue\nawait failed.skip('problematic-step', {\n  mockResult: { status: 'skipped' },\n})\n```\n\n## Error Boundaries\n\nIsolate failures within workflow sections:\n\n```typescript\nconst workflow = workflow({\n  execute: async (ctx, data) => {\n    // Critical section - failures propagate\n    await step('critical', () => criticalOperation())\n\n    // Optional section - failures are contained\n    try {\n      await step('optional-enhancement', () => enhance(data))\n    } catch {\n      // Log but continue\n      ctx.log.warn('Enhancement failed, continuing without')\n    }\n\n    // More critical work\n    await step('finalize', () => finalize(data))\n  },\n})\n```\n\n## Timeout Handling\n\n```typescript\nconst workflow = workflow({\n  name: 'time-sensitive',\n  timeout: '1h',  // Overall workflow timeout\n\n  execute: async (ctx, input) => {\n    try {\n      await step('long-operation', () => longOperation(), {\n        timeout: '10m',\n      })\n    } catch (error) {\n      if (error.code === 'TIMEOUT') {\n        // Handle timeout specifically\n        await step('timeout-fallback', () => timeoutFallback())\n      } else {\n        throw error\n      }\n    }\n  },\n})\n```\n\n## Best Practices\n\n1. **Be specific with retries** - Don't retry non-transient errors\n2. **Use idempotent operations** - Safe to retry without side effects\n3. **Define compensations** - Clean up resources on failure\n4. **Log errors contextually** - Include workflow and step context\n5. **Set appropriate timeouts** - Prevent indefinite hangs\n6. **Monitor failure rates** - Alert on unusual patterns\n\n\n# Workflow\n\nURL: https://primitives.org.ai/workflow\n\n> Orchestrate complex processes with durable execution or state machines\n\n\n\nOrchestrate complex processes that span multiple functions, systems, and time horizons with two complementary paradigms: **durable execution** for code-first workflows and **state machines** for explicit state management.\n\n## Durable Execution\n\nWrite workflows as regular code. The runtime handles persistence, retries, and recovery automatically:\n\n```typescript\nimport { workflow, step } from 'ai-workflows'\n\nconst onboardCustomer = workflow({\n  name: 'customer-onboarding',\n  execute: async (ctx, customer) => {\n    // Each step is durably persisted\n    const account = await step('create-account', () =>\n      createAccount(customer)\n    )\n\n    // If this fails, workflow resumes from here on retry\n    await step('send-welcome-email', () =>\n      sendEmail(customer.email, welcomeTemplate)\n    )\n\n    // Human task - workflow pauses until completed\n    const kycResult = await step('kyc-verification', () =>\n      humanTask({\n        type: 'kyc-review',\n        assignTo: 'compliance-team',\n        data: { customer, account },\n      })\n    )\n\n    if (kycResult.approved) {\n      await step('activate-account', () =>\n        activateAccount(account.id)\n      )\n    }\n\n    return { account, kycResult }\n  },\n})\n```\n\n### Durability Guarantees\n\n* **Exactly-once execution**: Each step runs exactly once, even across failures\n* **Automatic state persistence**: Workflow state survives process restarts\n* **Transparent recovery**: Workflows resume from the last completed step\n* **Long-running support**: Workflows can run for hours, days, or weeks\n\n### Waiting and Timers\n\n```typescript\nconst subscriptionWorkflow = workflow({\n  name: 'subscription-lifecycle',\n  execute: async (ctx, subscription) => {\n    await step('activate', () => activateSubscription(subscription))\n\n    // Wait for 30 days - workflow suspends, no resources consumed\n    await ctx.sleep('30d')\n\n    await step('send-renewal-reminder', () =>\n      sendRenewalReminder(subscription)\n    )\n\n    // Wait for external event or timeout\n    const renewed = await ctx.waitForEvent('subscription.renewed', {\n      timeout: '7d',\n      timeoutValue: false,\n    })\n\n    if (!renewed) {\n      await step('expire-subscription', () =>\n        expireSubscription(subscription)\n      )\n    }\n  },\n})\n```\n\n## State Machines\n\nFor complex business logic with explicit states and transitions, use state machines:\n\n```typescript\nimport { stateMachine, state, transition } from 'ai-workflows'\n\nconst orderMachine = stateMachine({\n  name: 'order-lifecycle',\n  initial: 'pending',\n  context: { orderId: '', items: [], total: 0 },\n\n  states: {\n    pending: state({\n      on: {\n        PAYMENT_RECEIVED: transition('processing', {\n          guard: (ctx, event) => event.amount >= ctx.total,\n          action: (ctx) => ctx.paidAt = new Date(),\n        }),\n        CANCEL: transition('cancelled'),\n      },\n    }),\n\n    processing: state({\n      onEnter: async (ctx) => {\n        await notifyWarehouse(ctx.orderId)\n      },\n      on: {\n        SHIPPED: transition('shipped'),\n        OUT_OF_STOCK: transition('backorder'),\n      },\n    }),\n\n    shipped: state({\n      onEnter: async (ctx) => {\n        await sendShippingNotification(ctx.orderId)\n      },\n      on: {\n        DELIVERED: transition('completed'),\n        RETURN_REQUESTED: transition('returning'),\n      },\n    }),\n\n    completed: state({ type: 'final' }),\n    cancelled: state({ type: 'final' }),\n  },\n})\n```\n\n### State Machine Benefits\n\n* **Explicit states**: All possible states are declared upfront\n* **Guarded transitions**: Conditions that must be met for transitions\n* **Entry/exit actions**: Code that runs when entering or leaving states\n* **Visualizable**: Generate diagrams from state machine definitions\n* **Auditable**: Complete history of states and transitions\n\n## Orchestrating AI and Human Work\n\nWorkflows seamlessly coordinate all function types:\n\n```typescript\nconst contentPipeline = workflow({\n  name: 'content-creation',\n  execute: async (ctx, brief) => {\n    // AI generates initial draft\n    const draft = await step('generate-draft', () =>\n      generateContent({ type: 'agentic', brief })\n    )\n\n    // Human reviews and edits\n    const reviewed = await step('human-review', () =>\n      humanTask({\n        type: 'content-review',\n        assignTo: 'content-team',\n        data: { draft, brief },\n        ui: 'content-editor',\n      })\n    )\n\n    // AI polishes based on human feedback\n    const final = await step('polish', () =>\n      polishContent({ type: 'generative', content: reviewed })\n    )\n\n    // Code function publishes\n    await step('publish', () =>\n      publishContent(final)\n    )\n\n    return final\n  },\n})\n```\n\n## Parallel Execution\n\nRun steps in parallel when they're independent:\n\n```typescript\nconst enrichCustomer = workflow({\n  name: 'enrich-customer',\n  execute: async (ctx, customer) => {\n    // Run all enrichment in parallel\n    const [credit, social, company] = await Promise.all([\n      step('credit-check', () => checkCredit(customer)),\n      step('social-lookup', () => lookupSocial(customer)),\n      step('company-info', () => getCompanyInfo(customer.company)),\n    ])\n\n    return { ...customer, credit, social, company }\n  },\n})\n```\n\n## Error Handling\n\n```typescript\nconst robustWorkflow = workflow({\n  name: 'robust-process',\n  execute: async (ctx, input) => {\n    try {\n      await step('risky-operation', () => riskyOperation(input), {\n        retry: { maxAttempts: 3, backoff: 'exponential' },\n      })\n    } catch (error) {\n      // Compensating transaction\n      await step('rollback', () => rollback(input))\n      throw error\n    }\n  },\n})\n```\n\n## Observability\n\nEvery workflow execution is fully observable:\n\n```typescript\nconst execution = await onboardCustomer.start(customer)\n\nconsole.log(execution.status)    // 'running' | 'completed' | 'failed' | 'waiting'\nconsole.log(execution.steps)     // List of completed steps with timing\nconsole.log(execution.events)    // Events received during execution\nconsole.log(execution.waitingOn) // What the workflow is waiting for\n```\n\n\n# Observability\n\nURL: https://primitives.org.ai/workflow/observability\n\n> Monitor, trace, and debug workflow execution\n\n\n\n# Observability\n\nGain visibility into workflow execution with built-in logging, tracing, metrics, and debugging tools.\n\n## Logging\n\n### Built-in Logger\n\n```typescript\nimport { workflow, step } from 'ai-workflows'\n\nconst myWorkflow = workflow({\n  name: 'observable-workflow',\n  execute: async (ctx, input) => {\n    ctx.log.info('Starting workflow', { input })\n\n    const result = await step('process', () => process(input))\n    ctx.log.debug('Processing complete', { result })\n\n    if (result.warnings.length > 0) {\n      ctx.log.warn('Completed with warnings', { warnings: result.warnings })\n    }\n\n    return result\n  },\n})\n```\n\n### Log Levels\n\n```typescript\nctx.log.debug('Detailed debugging info')\nctx.log.info('General information')\nctx.log.warn('Warning conditions')\nctx.log.error('Error conditions')\n```\n\n### Structured Logging\n\n```typescript\nctx.log.info('Order processed', {\n  orderId: order.id,\n  customerId: order.customerId,\n  amount: order.total,\n  items: order.items.length,\n})\n```\n\n## Tracing\n\n### Automatic Traces\n\nEvery workflow execution generates traces automatically:\n\n```typescript\nconst execution = await myWorkflow.run(input)\n\n// Access trace\nconsole.log(execution.traceId)  // 'trace_abc123'\n```\n\n### Custom Spans\n\n```typescript\nconst workflow = workflow({\n  execute: async (ctx, data) => {\n    // Create custom span\n    await ctx.trace.span('custom-operation', async (span) => {\n      span.setAttribute('data.size', data.length)\n\n      const result = await processData(data)\n\n      span.setAttribute('result.count', result.count)\n      return result\n    })\n  },\n})\n```\n\n### Trace Context\n\n```typescript\n// Pass trace context to external services\nawait step('external-call', async () => {\n  const response = await fetch(url, {\n    headers: {\n      'traceparent': ctx.trace.getTraceParent(),\n    },\n  })\n  return response.json()\n})\n```\n\n## Metrics\n\n### Built-in Metrics\n\nWorkflows automatically emit metrics:\n\n* `workflow.started` - Workflow executions started\n* `workflow.completed` - Successful completions\n* `workflow.failed` - Failed executions\n* `workflow.duration` - Execution duration histogram\n* `step.duration` - Individual step durations\n* `step.retries` - Retry counts\n\n### Custom Metrics\n\n```typescript\nimport { metrics } from 'ai-workflows'\n\nconst workflow = workflow({\n  execute: async (ctx, order) => {\n    // Counter\n    metrics.increment('orders.processed')\n\n    // Gauge\n    metrics.gauge('orders.pending', await getPendingCount())\n\n    // Histogram\n    metrics.histogram('order.value', order.total)\n\n    // With labels\n    metrics.increment('orders.by_status', {\n      status: order.status,\n      region: order.region,\n    })\n  },\n})\n```\n\n## Workflow History\n\n### Execution History\n\n```typescript\n// Get workflow execution\nconst execution = await workflow.get('wf_123')\n\n// View all steps\nconst steps = execution.getSteps()\nsteps.forEach((step) => {\n  console.log(`${step.name}: ${step.status}`)\n  console.log(`  Started: ${step.startedAt}`)\n  console.log(`  Completed: ${step.completedAt}`)\n  console.log(`  Duration: ${step.duration}ms`)\n  console.log(`  Attempts: ${step.attempts}`)\n})\n```\n\n### Step Details\n\n```typescript\nconst stepDetail = execution.getStep('payment')\n\nconsole.log(stepDetail.input)    // Input to the step\nconsole.log(stepDetail.output)   // Step result\nconsole.log(stepDetail.error)    // Error if failed\nconsole.log(stepDetail.logs)     // Logs from this step\n```\n\n## Events\n\n### Workflow Events\n\n```typescript\nimport { events } from 'ai-workflows'\n\n// Subscribe to workflow events\nevents.on('workflow.started', (event) => {\n  console.log(`Workflow ${event.workflowName} started: ${event.id}`)\n})\n\nevents.on('workflow.completed', (event) => {\n  console.log(`Workflow ${event.id} completed in ${event.duration}ms`)\n})\n\nevents.on('workflow.failed', (event) => {\n  console.error(`Workflow ${event.id} failed:`, event.error)\n})\n```\n\n### Step Events\n\n```typescript\nevents.on('step.started', (event) => {\n  console.log(`Step ${event.stepName} started`)\n})\n\nevents.on('step.completed', (event) => {\n  console.log(`Step ${event.stepName} completed: ${event.duration}ms`)\n})\n\nevents.on('step.retrying', (event) => {\n  console.warn(`Step ${event.stepName} retrying (attempt ${event.attempt})`)\n})\n```\n\n## Debugging\n\n### Dry Run\n\nTest workflows without side effects:\n\n```typescript\nconst result = await myWorkflow.dryRun(input, {\n  mockSteps: {\n    'payment': { success: true, transactionId: 'mock_123' },\n    'send-email': { sent: true },\n  },\n})\n\nconsole.log(result.steps)  // All steps that would execute\nconsole.log(result.output) // Expected output\n```\n\n### Step-by-Step Execution\n\n```typescript\nconst debugger = await myWorkflow.debug(input)\n\n// Execute step by step\nawait debugger.nextStep()\nconsole.log(debugger.currentStep)\n\nawait debugger.nextStep()\nconsole.log(debugger.state)\n\n// Continue to end\nawait debugger.continue()\n```\n\n### Replay\n\nReplay a completed workflow:\n\n```typescript\nconst execution = await workflow.get('wf_123')\n\n// Replay with same input\nconst replayed = await execution.replay()\n\n// Replay with modified input\nconst modified = await execution.replay({\n  input: { ...execution.input, amount: 200 },\n})\n```\n\n## Dashboard Integration\n\n### Export to OpenTelemetry\n\n```typescript\nimport { configureExporter } from 'ai-workflows'\n\nconfigureExporter({\n  type: 'otlp',\n  endpoint: 'http://collector:4317',\n  serviceName: 'my-workflows',\n})\n```\n\n### Export to DataDog\n\n```typescript\nconfigureExporter({\n  type: 'datadog',\n  apiKey: process.env.DD_API_KEY,\n  site: 'datadoghq.com',\n})\n```\n\n### Custom Exporter\n\n```typescript\nconfigureExporter({\n  type: 'custom',\n  export: async (spans, metrics, logs) => {\n    await myCustomBackend.send({ spans, metrics, logs })\n  },\n})\n```\n\n## Health Checks\n\n```typescript\nimport { health } from 'ai-workflows'\n\n// Check workflow engine health\nconst status = await health.check()\n\nconsole.log(status.healthy)        // true/false\nconsole.log(status.queueDepth)     // Pending workflows\nconsole.log(status.activeWorkers)  // Running workers\nconsole.log(status.latency)        // Processing latency\n```\n\n## Alerting\n\n```typescript\nimport { alerts } from 'ai-workflows'\n\n// Alert on high failure rate\nalerts.create({\n  name: 'high-failure-rate',\n  condition: 'workflow.failed.rate > 0.05',  // 5% failure rate\n  window: '5m',\n  notify: ['ops@company.com'],\n})\n\n// Alert on slow execution\nalerts.create({\n  name: 'slow-execution',\n  condition: 'workflow.duration.p99 > 60000',  // P99 > 1 minute\n  workflow: 'order-processing',\n  notify: ['ops@company.com'],\n})\n```\n\n## Best Practices\n\n1. **Log meaningful context** - Include IDs and relevant data\n2. **Use structured logging** - Enable querying and filtering\n3. **Set up alerts early** - Don't wait for production issues\n4. **Trace across services** - Propagate trace context\n5. **Monitor key metrics** - Track duration, throughput, and errors\n6. **Review failed executions** - Learn from failures\n\n\n# Parallel Execution\n\nURL: https://primitives.org.ai/workflow/parallel\n\n> Run steps concurrently for better performance\n\n\n\n# Parallel Execution\n\nExecute multiple independent operations concurrently to improve workflow performance.\n\n## Basic Parallel Execution\n\n```typescript\nimport { workflow, step, parallel } from 'ai-workflows'\n\nconst orderWorkflow = workflow({\n  name: 'order-processing',\n  execute: async (ctx, order) => {\n    // Run independent steps in parallel\n    const [inventory, payment, shipping] = await parallel([\n      step('check-inventory', () => checkInventory(order.items)),\n      step('validate-payment', () => validatePayment(order.payment)),\n      step('calculate-shipping', () => calculateShipping(order.address)),\n    ])\n\n    // Continue with results\n    await step('create-order', () =>\n      createOrder({ inventory, payment, shipping })\n    )\n  },\n})\n```\n\n## Named Parallel Steps\n\n```typescript\nconst results = await parallel({\n  user: step('fetch-user', () => getUser(userId)),\n  orders: step('fetch-orders', () => getOrders(userId)),\n  preferences: step('fetch-preferences', () => getPreferences(userId)),\n})\n\n// Access by name\nconsole.log(results.user)\nconsole.log(results.orders)\nconsole.log(results.preferences)\n```\n\n## Parallel with Limits\n\nControl concurrency to avoid overwhelming resources:\n\n```typescript\n// Maximum 3 concurrent operations\nconst results = await parallel(\n  items.map((item) => step(`process-${item.id}`, () => processItem(item))),\n  { concurrency: 3 }\n)\n```\n\n## Error Handling in Parallel\n\n### Fail Fast (Default)\n\n```typescript\ntry {\n  // If any step fails, all are cancelled\n  await parallel([\n    step('a', () => operationA()),\n    step('b', () => operationB()),\n    step('c', () => operationC()),\n  ])\n} catch (error) {\n  // First error is thrown\n  console.error('Parallel execution failed:', error)\n}\n```\n\n### Settle All\n\nContinue even if some steps fail:\n\n```typescript\nconst results = await parallel(\n  [\n    step('a', () => operationA()),\n    step('b', () => operationB()),\n    step('c', () => operationC()),\n  ],\n  { settle: true }\n)\n\n// Check results individually\nresults.forEach((result, index) => {\n  if (result.status === 'fulfilled') {\n    console.log(`Step ${index} succeeded:`, result.value)\n  } else {\n    console.log(`Step ${index} failed:`, result.reason)\n  }\n})\n```\n\n## Race Execution\n\nReturn as soon as one step completes:\n\n```typescript\nimport { race } from 'ai-workflows'\n\nconst fastest = await race([\n  step('primary', () => fetchFromPrimary(data)),\n  step('secondary', () => fetchFromSecondary(data)),\n  step('cache', () => fetchFromCache(data)),\n])\n```\n\n## Parallel Workflows\n\nRun entire workflows in parallel:\n\n```typescript\nconst processUsers = workflow({\n  execute: async (ctx, userIds) => {\n    // Process all users concurrently\n    const results = await parallel(\n      userIds.map((id) =>\n        ctx.invoke(processUserWorkflow, { userId: id })\n      ),\n      { concurrency: 10 }\n    )\n\n    return { processed: results.length }\n  },\n})\n```\n\n## Fan-Out / Fan-In Pattern\n\n```typescript\nconst mapReduceWorkflow = workflow({\n  execute: async (ctx, data) => {\n    // Fan-out: Split work across parallel steps\n    const chunks = splitIntoChunks(data, 10)\n\n    const processed = await parallel(\n      chunks.map((chunk, i) =>\n        step(`process-chunk-${i}`, () => processChunk(chunk))\n      ),\n      { concurrency: 5 }\n    )\n\n    // Fan-in: Combine results\n    const combined = await step('combine', () =>\n      combineResults(processed)\n    )\n\n    return combined\n  },\n})\n```\n\n## Conditional Parallel\n\n```typescript\nconst conditionalWorkflow = workflow({\n  execute: async (ctx, order) => {\n    const tasks = []\n\n    // Add tasks based on conditions\n    if (order.requiresApproval) {\n      tasks.push(step('approval', () => requestApproval(order)))\n    }\n\n    if (order.isInternational) {\n      tasks.push(step('customs', () => prepareCustomsForms(order)))\n    }\n\n    tasks.push(step('inventory', () => reserveInventory(order)))\n\n    // Execute whatever tasks were added\n    await parallel(tasks)\n  },\n})\n```\n\n## Timeout for Parallel\n\n```typescript\nconst results = await parallel(\n  [\n    step('slow', () => slowOperation()),\n    step('fast', () => fastOperation()),\n  ],\n  {\n    timeout: '30s',\n    timeoutValue: 'partial', // Return completed results on timeout\n  }\n)\n```\n\n## Nested Parallel\n\n```typescript\nconst complexWorkflow = workflow({\n  execute: async (ctx, data) => {\n    const results = await parallel([\n      // First parallel group\n      parallel([\n        step('a1', () => opA1()),\n        step('a2', () => opA2()),\n      ]),\n\n      // Second parallel group\n      parallel([\n        step('b1', () => opB1()),\n        step('b2', () => opB2()),\n        step('b3', () => opB3()),\n      ]),\n    ])\n\n    return results\n  },\n})\n```\n\n## Best Practices\n\n1. **Independent operations only** - Only parallelize steps with no dependencies\n2. **Set concurrency limits** - Avoid overwhelming external services\n3. **Handle partial failures** - Use `settle: true` when appropriate\n4. **Consider resource usage** - Parallel execution uses more memory\n5. **Use timeouts** - Prevent hanging on slow parallel operations\n\n\n# State Machines\n\nURL: https://primitives.org.ai/workflow/state-machines\n\n> Explicit state management for complex business logic\n\n\n\n# State Machines\n\nState machines provide explicit state management with guarded transitions, making complex business logic predictable and auditable.\n\n## Defining a State Machine\n\n```typescript\nimport { stateMachine, state, transition } from 'ai-workflows'\n\nconst orderMachine = stateMachine({\n  name: 'order-lifecycle',\n  initial: 'draft',\n  context: {\n    orderId: '',\n    items: [],\n    total: 0,\n    paidAt: null,\n    shippedAt: null,\n  },\n\n  states: {\n    draft: state({\n      on: {\n        SUBMIT: transition('pending'),\n        CANCEL: transition('cancelled'),\n      },\n    }),\n\n    pending: state({\n      on: {\n        PAYMENT_RECEIVED: transition('paid', {\n          action: (ctx) => {\n            ctx.paidAt = new Date()\n          },\n        }),\n        CANCEL: transition('cancelled'),\n      },\n    }),\n\n    paid: state({\n      onEnter: async (ctx) => {\n        await notifyWarehouse(ctx.orderId)\n      },\n      on: {\n        SHIP: transition('shipped'),\n        REFUND: transition('refunded'),\n      },\n    }),\n\n    shipped: state({\n      onEnter: async (ctx) => {\n        ctx.shippedAt = new Date()\n        await sendTrackingEmail(ctx.orderId)\n      },\n      on: {\n        DELIVER: transition('delivered'),\n        RETURN: transition('returning'),\n      },\n    }),\n\n    delivered: state({ type: 'final' }),\n    cancelled: state({ type: 'final' }),\n    refunded: state({ type: 'final' }),\n  },\n})\n```\n\n## Guarded Transitions\n\nTransitions can have guards that must pass:\n\n```typescript\npending: state({\n  on: {\n    PAYMENT_RECEIVED: transition('paid', {\n      guard: (ctx, event) => {\n        // Only transition if payment amount matches\n        return event.amount >= ctx.total\n      },\n    }),\n\n    APPLY_DISCOUNT: transition('pending', {\n      guard: (ctx, event) => event.code !== undefined,\n      action: (ctx, event) => {\n        ctx.total = ctx.total * (1 - event.discount)\n      },\n    }),\n  },\n}),\n```\n\n## Entry and Exit Actions\n\nExecute code when entering or leaving states:\n\n```typescript\nprocessing: state({\n  onEnter: async (ctx) => {\n    // Runs when entering 'processing'\n    await startProcessing(ctx.orderId)\n    ctx.processingStartedAt = new Date()\n  },\n\n  onExit: async (ctx) => {\n    // Runs when leaving 'processing'\n    await logProcessingDuration(\n      ctx.orderId,\n      Date.now() - ctx.processingStartedAt\n    )\n  },\n\n  on: {\n    COMPLETE: transition('completed'),\n  },\n}),\n```\n\n## Sending Events\n\n```typescript\nconst instance = await orderMachine.create({\n  orderId: 'order_123',\n  items: [{ name: 'Widget', price: 100 }],\n  total: 100,\n})\n\n// Send events to transition\nawait instance.send('SUBMIT')\nconsole.log(instance.state) // 'pending'\n\nawait instance.send('PAYMENT_RECEIVED', { amount: 100 })\nconsole.log(instance.state) // 'paid'\n\n// Check if transition is possible\nconst canShip = instance.can('SHIP')\n```\n\n## Hierarchical States\n\nStates can be nested:\n\n```typescript\nconst machine = stateMachine({\n  states: {\n    active: state({\n      initial: 'idle',\n\n      states: {\n        idle: state({\n          on: { START: transition('running') },\n        }),\n        running: state({\n          on: { PAUSE: transition('paused') },\n        }),\n        paused: state({\n          on: { RESUME: transition('running') },\n        }),\n      },\n\n      on: {\n        STOP: transition('stopped'),  // Exits all nested states\n      },\n    }),\n\n    stopped: state({ type: 'final' }),\n  },\n})\n```\n\n## Parallel States\n\nRun multiple states simultaneously:\n\n```typescript\nconst machine = stateMachine({\n  type: 'parallel',\n\n  states: {\n    upload: state({\n      initial: 'pending',\n      states: {\n        pending: state({ on: { START: transition('uploading') } }),\n        uploading: state({ on: { COMPLETE: transition('done') } }),\n        done: state({ type: 'final' }),\n      },\n    }),\n\n    validate: state({\n      initial: 'pending',\n      states: {\n        pending: state({ on: { START: transition('validating') } }),\n        validating: state({ on: { PASS: transition('valid') } }),\n        valid: state({ type: 'final' }),\n      },\n    }),\n  },\n})\n```\n\n## History States\n\nRemember previous state when re-entering:\n\n```typescript\nconst machine = stateMachine({\n  states: {\n    editing: state({\n      initial: 'text',\n      states: {\n        text: state({}),\n        formatting: state({}),\n        preview: state({}),\n      },\n      history: 'shallow',  // Remember last child state\n    }),\n\n    saving: state({\n      on: {\n        DONE: transition('editing'),  // Returns to last editing state\n      },\n    }),\n  },\n})\n```\n\n## Visualization\n\nGenerate diagrams from state machine definitions:\n\n```typescript\nimport { visualize } from 'ai-workflows'\n\nconst diagram = visualize(orderMachine, {\n  format: 'mermaid',\n})\n\nconsole.log(diagram)\n// stateDiagram-v2\n//   [*] --> draft\n//   draft --> pending: SUBMIT\n//   draft --> cancelled: CANCEL\n//   pending --> paid: PAYMENT_RECEIVED\n//   ...\n```\n\n## Persistence\n\nState machines are automatically persisted:\n\n```typescript\n// Create with ID for persistence\nconst instance = await orderMachine.create(\n  { orderId: 'order_123' },\n  { id: 'order_123' }\n)\n\n// Later, restore from ID\nconst restored = await orderMachine.get('order_123')\nconsole.log(restored.state)  // Current state\nconsole.log(restored.context)  // Current context\n```\n\n## Event History\n\nTrack all transitions:\n\n```typescript\nconst history = instance.getHistory()\n// [\n//   { from: 'draft', to: 'pending', event: 'SUBMIT', timestamp: ... },\n//   { from: 'pending', to: 'paid', event: 'PAYMENT_RECEIVED', timestamp: ... },\n// ]\n```\n\n\n# Steps\n\nURL: https://primitives.org.ai/workflow/steps\n\n> Define and execute durable workflow steps\n\n\n\n# Steps\n\nSteps are the building blocks of durable workflows. Each step is persisted, enabling automatic recovery and exactly-once execution guarantees.\n\n## Defining Steps\n\n```typescript\nimport { workflow, step } from 'ai-workflows'\n\nconst myWorkflow = workflow({\n  name: 'process-order',\n  execute: async (ctx, order) => {\n    // Each step is durably persisted\n    const validated = await step('validate', () =>\n      validateOrder(order)\n    )\n\n    const payment = await step('charge', () =>\n      chargePayment(order.paymentMethod, validated.total)\n    )\n\n    const shipped = await step('ship', () =>\n      createShipment(order.items, order.address)\n    )\n\n    return { validated, payment, shipped }\n  },\n})\n```\n\n## Step Options\n\nConfigure retry behavior, timeouts, and more:\n\n```typescript\nawait step('risky-operation', () => callExternalAPI(data), {\n  // Retry configuration\n  retry: {\n    maxAttempts: 3,\n    backoff: 'exponential',\n    initialDelay: 1000,\n    maxDelay: 30000,\n  },\n\n  // Timeout\n  timeout: '30s',\n\n  // Idempotency key for deduplication\n  idempotencyKey: `op-${data.id}`,\n})\n```\n\n## Step Results\n\nSteps automatically cache their results:\n\n```typescript\nconst myWorkflow = workflow({\n  execute: async (ctx, input) => {\n    // First execution: runs the function\n    const result = await step('expensive', () => expensiveOperation())\n\n    // If workflow restarts, uses cached result\n    // The function won't run again\n  },\n})\n```\n\n## Conditional Steps\n\nExecute steps conditionally:\n\n```typescript\nconst result = await step('validate', () => validate(data))\n\nif (result.needsReview) {\n  // This step only runs when needed\n  await step('human-review', () =>\n    humanTask({ type: 'review', data })\n  )\n}\n```\n\n## Step Metadata\n\nAccess step execution details:\n\n```typescript\nconst result = await step('process', async () => {\n  return processData(data)\n})\n\n// Step metadata is available\nconsole.log(ctx.steps['process'].startedAt)\nconsole.log(ctx.steps['process'].completedAt)\nconsole.log(ctx.steps['process'].duration)\nconsole.log(ctx.steps['process'].attempts)\n```\n\n## Compensating Steps\n\nHandle failures with compensating transactions:\n\n```typescript\nconst myWorkflow = workflow({\n  execute: async (ctx, order) => {\n    const payment = await step('charge', () =>\n      chargePayment(order)\n    )\n\n    try {\n      await step('fulfill', () => fulfillOrder(order))\n    } catch (error) {\n      // Compensate by refunding\n      await step('refund', () =>\n        refundPayment(payment.transactionId)\n      )\n      throw error\n    }\n  },\n})\n```\n\n## Step Types\n\n### Sync Steps\n\n```typescript\nawait step('sync', () => {\n  return computeValue(data)  // Synchronous\n})\n```\n\n### Async Steps\n\n```typescript\nawait step('async', async () => {\n  return await fetchData(url)  // Asynchronous\n})\n```\n\n### Human Steps\n\n```typescript\nawait step('approval', () =>\n  humanTask({\n    type: 'approve',\n    assignTo: 'manager',\n    data: { request },\n  })\n)\n```\n\n### AI Steps\n\n```typescript\nawait step('analyze', () =>\n  generateContent({\n    prompt: 'Analyze this data',\n    data: input,\n  })\n)\n```\n\n## Best Practices\n\n1. **Keep steps atomic** - Each step should do one thing\n2. **Use descriptive names** - Names appear in logs and UI\n3. **Handle failures explicitly** - Use try/catch for compensating actions\n4. **Avoid side effects in retries** - Ensure operations are idempotent\n\n\n# Timers & Waiting\n\nURL: https://primitives.org.ai/workflow/timers\n\n> Sleep, wait for events, and schedule work\n\n\n\n# Timers & Waiting\n\nWorkflows can wait for arbitrary periods, external events, or scheduled times without consuming resources.\n\n## Sleeping\n\nPause workflow execution for a duration:\n\n```typescript\nconst reminderWorkflow = workflow({\n  name: 'subscription-reminder',\n  execute: async (ctx, subscription) => {\n    await step('activate', () => activateSubscription(subscription))\n\n    // Sleep for 30 days - workflow suspends\n    await ctx.sleep('30d')\n\n    await step('remind', () => sendRenewalReminder(subscription))\n\n    // Sleep for another 7 days\n    await ctx.sleep('7d')\n\n    await step('final-notice', () => sendFinalNotice(subscription))\n  },\n})\n```\n\n### Duration Formats\n\n```typescript\nawait ctx.sleep('5s')     // 5 seconds\nawait ctx.sleep('30m')    // 30 minutes\nawait ctx.sleep('2h')     // 2 hours\nawait ctx.sleep('7d')     // 7 days\nawait ctx.sleep('2w')     // 2 weeks\nawait ctx.sleep(3600000)  // Milliseconds\n```\n\n## Waiting for Events\n\nWait for external events with optional timeout:\n\n```typescript\nconst orderWorkflow = workflow({\n  name: 'order-fulfillment',\n  execute: async (ctx, order) => {\n    await step('create', () => createOrder(order))\n\n    // Wait for payment event\n    const payment = await ctx.waitForEvent('payment.received', {\n      filter: { orderId: order.id },\n      timeout: '24h',\n      timeoutValue: null,\n    })\n\n    if (!payment) {\n      await step('cancel', () => cancelOrder(order.id, 'payment-timeout'))\n      return { status: 'cancelled' }\n    }\n\n    await step('fulfill', () => fulfillOrder(order.id))\n    return { status: 'completed' }\n  },\n})\n```\n\n### Event Matching\n\n```typescript\n// Wait for specific event\nconst event = await ctx.waitForEvent('order.shipped', {\n  filter: { orderId: ctx.orderId },\n})\n\n// Wait for any of multiple events\nconst event = await ctx.waitForEvent(['payment.success', 'payment.failed'], {\n  filter: { orderId: ctx.orderId },\n})\n\n// Complex filtering\nconst event = await ctx.waitForEvent('notification', {\n  filter: (e) => e.type === 'reply' && e.userId === ctx.userId,\n})\n```\n\n## Scheduled Execution\n\nSchedule workflows to run at specific times:\n\n```typescript\nimport { schedule, cron } from 'ai-workflows'\n\n// Schedule for specific time\nawait schedule(reportWorkflow, reportData, {\n  at: new Date('2024-12-31T23:59:00Z'),\n})\n\n// Schedule with delay\nawait schedule(reminderWorkflow, userData, {\n  delay: '7d',\n})\n\n// Recurring schedule\nawait cron('0 9 * * MON', weeklyReportWorkflow, {\n  timezone: 'America/New_York',\n})\n```\n\n### Cron Expressions\n\n```typescript\n// Every day at 9am\ncron('0 9 * * *', dailyWorkflow)\n\n// Every Monday at 10am\ncron('0 10 * * MON', weeklyWorkflow)\n\n// First of every month\ncron('0 0 1 * *', monthlyWorkflow)\n\n// Every 15 minutes\ncron('*/15 * * * *', frequentWorkflow)\n```\n\n## Timeouts\n\nSet timeouts for steps or entire workflows:\n\n```typescript\nconst workflow = workflow({\n  name: 'time-sensitive',\n  timeout: '1h',  // Entire workflow timeout\n\n  execute: async (ctx, input) => {\n    await step('quick', () => quickOperation(), {\n      timeout: '30s',\n    })\n\n    await step('slow', () => slowOperation(), {\n      timeout: '10m',\n    })\n  },\n})\n```\n\n### Timeout Handling\n\n```typescript\nconst workflow = workflow({\n  execute: async (ctx, input) => {\n    try {\n      await step('risky', () => riskyOperation(), {\n        timeout: '5m',\n      })\n    } catch (error) {\n      if (error.code === 'TIMEOUT') {\n        await step('fallback', () => fallbackOperation())\n      }\n      throw error\n    }\n  },\n})\n```\n\n## Deadlines\n\nSet absolute deadlines:\n\n```typescript\nconst workflow = workflow({\n  execute: async (ctx, order) => {\n    // Must complete by deadline\n    ctx.setDeadline(order.fulfillmentDeadline)\n\n    await step('process', () => processOrder(order))\n\n    // Check remaining time\n    const remaining = ctx.timeRemaining()\n    if (remaining < 3600000) {\n      await step('expedite', () => expediteShipping(order))\n    }\n  },\n})\n```\n\n## Signals\n\nReceive signals during execution:\n\n```typescript\nconst workflow = workflow({\n  signals: {\n    cancel: async (ctx, reason) => {\n      await step('cleanup', () => cleanup(ctx.data))\n      ctx.exit({ status: 'cancelled', reason })\n    },\n\n    updatePriority: async (ctx, newPriority) => {\n      ctx.data.priority = newPriority\n    },\n  },\n\n  execute: async (ctx, input) => {\n    // Workflow runs, can receive signals at any time\n    while (!ctx.done) {\n      await step('work', () => doWork(ctx.data))\n      await ctx.sleep('1h')\n    }\n  },\n})\n\n// Send signal to running workflow\nawait workflow.signal('wf_123', 'updatePriority', 'high')\n```\n\n## Polling\n\nImplement polling patterns:\n\n```typescript\nconst workflow = workflow({\n  execute: async (ctx, jobId) => {\n    await step('submit', () => submitJob(jobId))\n\n    // Poll until complete\n    let status = 'pending'\n    while (status === 'pending' || status === 'running') {\n      await ctx.sleep('30s')\n      status = await step('check', () => getJobStatus(jobId))\n    }\n\n    return { jobId, status }\n  },\n})\n```\n\n## Timer Best Practices\n\n1. **Use appropriate granularity** - Don't sleep for seconds if minutes work\n2. **Always set timeouts** - Prevent workflows from running forever\n3. **Handle timeout gracefully** - Implement compensating actions\n4. **Use events over polling** - More efficient when possible\n5. **Consider timezones** - Especially for scheduled workflows\n\n\n# Dependencies\n\nURL: https://primitives.org.ai/task/dependencies\n\n> Task dependencies, blocking, and dependency graphs\n\n\n\n# Dependencies\n\nTasks can depend on other tasks, enabling complex workflows where work is automatically sequenced based on completion.\n\n## Basic Dependencies\n\n```typescript\nimport { createTask, completeTask, getTask } from 'digital-tasks'\n\n// Create first task\nconst task1 = await createTask({\n  function: { type: 'code', name: 'fetchData', ... },\n})\n\n// Create task that depends on task1\nconst task2 = await createTask({\n  function: { type: 'code', name: 'processData', ... },\n  dependencies: [task1.id],\n})\n\nconsole.log(task2.status)  // 'blocked'\n\n// When task1 completes, task2 automatically unblocks\nawait completeTask(task1.id, { data: [...] })\n\nconst updated = await getTask(task2.id)\nconsole.log(updated.status)  // 'queued'\n```\n\n## Multiple Dependencies\n\n```typescript\n// Task depends on multiple tasks completing\nconst finalTask = await createTask({\n  function: processFunc,\n  dependencies: [task1.id, task2.id, task3.id],\n})\n\n// Task remains blocked until ALL dependencies complete\nconsole.log(finalTask.status)  // 'blocked'\n\nawait completeTask(task1.id, result1)\nawait completeTask(task2.id, result2)\n\n// Still blocked - task3 not complete\nconst stillBlocked = await getTask(finalTask.id)\nconsole.log(stillBlocked.status)  // 'blocked'\n\nawait completeTask(task3.id, result3)\n\n// Now unblocked\nconst unblocked = await getTask(finalTask.id)\nconsole.log(unblocked.status)  // 'queued'\n```\n\n## Dependency Types\n\n```typescript\ninterface TaskDependency {\n  taskId: string\n  type: 'completion' | 'success' | 'any'\n}\n\n// Default: completion (task must complete, success or failure)\nconst task = await createTask({\n  function: func,\n  dependencies: ['task_1'],  // Same as [{ taskId: 'task_1', type: 'completion' }]\n})\n\n// Success: task must complete successfully\nconst strictTask = await createTask({\n  function: func,\n  dependencies: [{ taskId: 'task_1', type: 'success' }],\n})\n\n// Any: proceeds when dependency reaches any terminal state\nconst flexibleTask = await createTask({\n  function: func,\n  dependencies: [{ taskId: 'task_1', type: 'any' }],\n})\n```\n\n## Dependency Graph Utilities\n\n### Get Dependants\n\nFind tasks that depend on a given task:\n\n```typescript\nimport { getDependants } from 'digital-tasks'\n\nconst allTasks = await getAllProjectTasks(projectId)\nconst dependants = getDependants(task.id, allTasks)\n\n// Returns tasks that will be affected when this task completes\nconsole.log(dependants.map(t => t.name))\n```\n\n### Get Dependencies\n\nFind tasks that a given task depends on:\n\n```typescript\nimport { getDependencies } from 'digital-tasks'\n\nconst dependencies = getDependencies(task, allTasks)\n\n// Returns the actual task objects this task is waiting for\nconsole.log(dependencies.map(t => ({ id: t.id, status: t.status })))\n```\n\n### Get Ready Tasks\n\nFind tasks that can be executed now:\n\n```typescript\nimport { getReadyTasks } from 'digital-tasks'\n\nconst allTasks = await getAllProjectTasks(projectId)\nconst ready = getReadyTasks(allTasks)\n\n// Returns tasks with status 'queued' and no unsatisfied dependencies\nconsole.log(`${ready.length} tasks ready to execute`)\n```\n\n### Check for Cycles\n\nDetect circular dependencies:\n\n```typescript\nimport { hasCycles } from 'digital-tasks'\n\nconst tasks = [\n  { id: 'a', dependencies: ['b'] },\n  { id: 'b', dependencies: ['c'] },\n  { id: 'c', dependencies: ['a'] },  // Creates cycle!\n]\n\nconst cyclic = hasCycles(tasks)\nconsole.log(cyclic)  // true\n```\n\n### Topological Sort\n\nGet execution order:\n\n```typescript\nimport { sortTasks } from 'digital-tasks'\n\nconst sorted = sortTasks(allTasks)\n\n// Returns tasks in valid execution order\n// Tasks with no dependencies come first\nsorted.forEach((task, index) => {\n  console.log(`${index + 1}. ${task.name}`)\n})\n```\n\n## Dependency Visualization\n\n```typescript\nimport { visualizeDependencies } from 'digital-tasks'\n\nconst diagram = visualizeDependencies(allTasks, {\n  format: 'mermaid',\n})\n\nconsole.log(diagram)\n// graph TD\n//   task_1[Fetch Data]\n//   task_2[Process Data]\n//   task_3[Generate Report]\n//   task_1 --> task_2\n//   task_2 --> task_3\n```\n\n## Cascading Effects\n\n### Failed Dependencies\n\nWhen a dependency fails:\n\n```typescript\n// task2 depends on task1\nawait failTask(task1.id, 'Error occurred')\n\n// task2 can be configured to:\n// 1. Stay blocked (default for 'success' type)\n// 2. Automatically fail\n// 3. Unblock anyway ('any' type)\n\nconst task2 = await createTask({\n  function: func,\n  dependencies: [{ taskId: task1.id, type: 'success' }],\n  onDependencyFailed: 'fail',  // 'block' | 'fail' | 'ignore'\n})\n```\n\n### Cancelled Dependencies\n\n```typescript\nawait cancelTask(task1.id, 'No longer needed')\n\n// Dependent tasks can cascade cancel\nconst task2 = await createTask({\n  function: func,\n  dependencies: [task1.id],\n  onDependencyCancelled: 'cancel',  // 'block' | 'cancel' | 'ignore'\n})\n```\n\n## Dynamic Dependencies\n\nAdd or remove dependencies at runtime:\n\n```typescript\nimport { addDependency, removeDependency } from 'digital-tasks'\n\n// Add dependency\nawait addDependency(task2.id, task1.id)\n\n// Remove dependency\nawait removeDependency(task2.id, task1.id)\n```\n\n## Data Flow Between Tasks\n\nPass output from one task as input to dependents:\n\n```typescript\n// Task 1 produces data\nconst task1 = await createTask({\n  function: {\n    type: 'code',\n    name: 'fetchUsers',\n    output: 'array',\n  },\n})\n\n// Task 2 consumes task1's output\nconst task2 = await createTask({\n  function: {\n    type: 'code',\n    name: 'processUsers',\n    args: { users: 'Array of users' },\n  },\n  dependencies: [task1.id],\n  inputMapping: {\n    users: { from: task1.id, path: 'output' },\n  },\n})\n\n// When task1 completes, task2 receives its output\nawait completeTask(task1.id, [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }])\n// task2.input.users is now [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }]\n```\n\n## Parallel and Sequential Groups\n\n```typescript\nimport { createTask, parallel, sequential } from 'digital-tasks'\n\n// Parallel: all tasks can run simultaneously\nconst parallelGroup = parallel([\n  createTask({ function: func1 }),\n  createTask({ function: func2 }),\n  createTask({ function: func3 }),\n])\n\n// Sequential: each task depends on the previous\nconst sequentialGroup = sequential([\n  createTask({ function: step1 }),\n  createTask({ function: step2 }),\n  createTask({ function: step3 }),\n])\n// Automatically creates: step2 depends on step1, step3 depends on step2\n```\n\n## Best Practices\n\n1. **Avoid circular dependencies** - Use `hasCycles()` to validate\n2. **Keep dependency chains short** - Long chains increase latency\n3. **Use success type sparingly** - Consider if 'completion' suffices\n4. **Handle failed dependencies explicitly** - Configure cascade behavior\n5. **Visualize complex graphs** - Catch issues early\n\n\n# Project DSL\n\nURL: https://primitives.org.ai/task/dsl\n\n> Declarative task workflow definitions\n\n\n\n# Project DSL\n\nDefine complex task workflows using a declarative domain-specific language that combines tasks into parallel and sequential execution patterns.\n\n## Basic Building Blocks\n\n```typescript\nimport { task, parallel, sequential, createProject } from 'digital-tasks'\n\n// Create individual tasks\nconst design = task('Design mockups')\nconst spec = task('Write technical spec')\nconst implement = task('Implement feature')\nconst test = task('Write tests')\nconst review = task('Code review')\n```\n\n## Creating Projects\n\n```typescript\nconst project = createProject({\n  name: 'Launch Feature',\n  description: 'Ship the new dashboard feature',\n  tasks: [\n    parallel(design, spec),    // Run in parallel\n    sequential(implement, test), // Run in sequence\n    review,                      // After both groups complete\n  ],\n})\n\nconsole.log(project.name)     // 'Launch Feature'\nconsole.log(project.tasks)    // All tasks with dependencies set\n```\n\n## Parallel Execution\n\nTasks in a parallel group can execute simultaneously:\n\n```typescript\n// All three tasks can run at the same time\nconst planning = parallel(\n  task('Design UI'),\n  task('Write specs'),\n  task('Set up infrastructure'),\n)\n\n// Nested parallel groups\nconst development = parallel(\n  parallel(\n    task('Build API'),\n    task('Build database layer'),\n  ),\n  task('Build frontend'),\n)\n```\n\n## Sequential Execution\n\nTasks in a sequential group execute one after another:\n\n```typescript\n// Each task waits for the previous to complete\nconst deployment = sequential(\n  task('Run tests'),\n  task('Build artifacts'),\n  task('Deploy to staging'),\n  task('Run smoke tests'),\n  task('Deploy to production'),\n)\n```\n\n## Combining Patterns\n\n```typescript\nconst project = createProject({\n  name: 'Feature Development',\n  tasks: [\n    // Phase 1: Planning (parallel)\n    parallel(\n      task('Design mockups'),\n      task('Write technical spec'),\n      task('Set up project board'),\n    ),\n\n    // Phase 2: Implementation (mixed)\n    parallel(\n      sequential(\n        task('Implement backend'),\n        task('Write backend tests'),\n      ),\n      sequential(\n        task('Implement frontend'),\n        task('Write frontend tests'),\n      ),\n    ),\n\n    // Phase 3: Integration (sequential)\n    sequential(\n      task('Integration testing'),\n      task('Performance testing'),\n    ),\n\n    // Phase 4: Release\n    task('Deploy to production'),\n  ],\n})\n```\n\n## Task Options\n\n```typescript\nconst tasks = [\n  task('Critical task', { priority: 'critical' }),\n  task('Code task', { functionType: 'code' }),\n  task('AI task', { functionType: 'generative' }),\n  task('Human approval', { functionType: 'human' }),\n  task('Assigned task', {\n    assignTo: { type: 'human', id: 'user_123', name: 'John' },\n  }),\n]\n```\n\n## Fluent Builder API\n\nBuild projects with a chainable API:\n\n```typescript\nimport { workflow } from 'digital-tasks'\n\nconst project = workflow('Launch Feature')\n  .description('Ship the new dashboard')\n  .parallel(\n    task('Design'),\n    task('Spec'),\n  )\n  .then(\n    task('Implement'),\n  )\n  .parallel(\n    task('Test'),\n    task('Document'),\n  )\n  .then(\n    task('Review', { functionType: 'human' }),\n  )\n  .then(\n    task('Deploy'),\n  )\n  .build()\n```\n\n### Builder Methods\n\n```typescript\nworkflow('Name')\n  .description('Project description')\n  .parallel(...tasks)        // Add parallel group\n  .sequential(...tasks)      // Add sequential group (alias: .then())\n  .then(...tasks)           // Alias for sequential\n  .task(name, options)      // Add single task\n  .when(condition, tasks)   // Conditional tasks\n  .metadata({ key: 'value' }) // Add metadata\n  .build()                  // Create project\n```\n\n## Conditional Tasks\n\nInclude tasks based on conditions:\n\n```typescript\nconst project = workflow('Deploy')\n  .task('Build')\n  .when(config.runTests, [\n    task('Run unit tests'),\n    task('Run integration tests'),\n  ])\n  .task('Deploy')\n  .build()\n```\n\n## Named Groups\n\nCreate reusable task groups:\n\n```typescript\nimport { group } from 'digital-tasks'\n\n// Define reusable groups\nconst testingPhase = group('Testing', [\n  task('Unit tests'),\n  task('Integration tests'),\n  task('E2E tests'),\n])\n\nconst deploymentPhase = group('Deployment', [\n  sequential(\n    task('Build'),\n    task('Deploy staging'),\n    task('Deploy production'),\n  ),\n])\n\n// Use in projects\nconst project = createProject({\n  name: 'Release',\n  tasks: [\n    task('Development'),\n    testingPhase,\n    deploymentPhase,\n  ],\n})\n```\n\n## Templates\n\nCreate project templates:\n\n```typescript\nimport { template } from 'digital-tasks'\n\nconst featureTemplate = template({\n  name: 'Feature Development',\n  parameters: ['featureName', 'assignee'],\n  tasks: (params) => [\n    parallel(\n      task(`Design ${params.featureName}`),\n      task(`Spec ${params.featureName}`),\n    ),\n    task(`Implement ${params.featureName}`, {\n      assignTo: params.assignee,\n    }),\n    task('Review', { functionType: 'human' }),\n  ],\n})\n\n// Create project from template\nconst project = featureTemplate.create({\n  featureName: 'Dark Mode',\n  assignee: { type: 'human', id: 'user_123', name: 'Jane' },\n})\n```\n\n## Milestones\n\nMark progress points:\n\n```typescript\nimport { milestone } from 'digital-tasks'\n\nconst project = createProject({\n  name: 'Product Launch',\n  tasks: [\n    parallel(task('Design'), task('Spec')),\n    milestone('Planning Complete'),\n\n    parallel(task('Backend'), task('Frontend')),\n    milestone('Development Complete'),\n\n    sequential(task('QA'), task('Staging')),\n    milestone('Ready for Launch'),\n\n    task('Production Deploy'),\n  ],\n})\n```\n\n## Subtasks\n\nCreate hierarchical task structures:\n\n```typescript\nconst project = createProject({\n  name: 'Build Dashboard',\n  tasks: [\n    task('Implement Charts', {\n      subtasks: [\n        task('Line chart component'),\n        task('Bar chart component'),\n        task('Pie chart component'),\n      ],\n    }),\n    task('Implement Filters', {\n      subtasks: [\n        task('Date range filter'),\n        task('Category filter'),\n        task('Search filter'),\n      ],\n    }),\n  ],\n})\n```\n\n## Project Execution\n\n```typescript\nimport { executeProject } from 'digital-tasks'\n\n// Execute project\nconst execution = await executeProject(project, {\n  onTaskStart: (task) => console.log(`Starting: ${task.name}`),\n  onTaskComplete: (task) => console.log(`Completed: ${task.name}`),\n  onMilestone: (milestone) => console.log(`Milestone: ${milestone.name}`),\n})\n\n// Wait for completion\nawait execution.wait()\n\nconsole.log(execution.status)    // 'completed'\nconsole.log(execution.duration)  // Total time in ms\n```\n\n## Visualization\n\n```typescript\nimport { visualizeProject } from 'digital-tasks'\n\n// Generate Mermaid diagram\nconst diagram = visualizeProject(project, { format: 'mermaid' })\n\nconsole.log(diagram)\n// gantt\n//   title Launch Feature\n//   section Planning\n//   Design: a1, 2024-01-01, 3d\n//   Spec: a2, 2024-01-01, 2d\n//   section Development\n//   Implement: a3, after a1 a2, 5d\n//   ...\n```\n\n## Best Practices\n\n1. **Use meaningful names** - Task names should be self-documenting\n2. **Group related tasks** - Use named groups for clarity\n3. **Limit nesting depth** - Keep hierarchy manageable\n4. **Add milestones** - Mark significant progress points\n5. **Create templates** - Reuse common patterns\n6. **Visualize before executing** - Validate the workflow structure\n\n\n# Task\n\nURL: https://primitives.org.ai/task\n\n> Task management primitives for digital workers - combining functions with status, dependencies, and workflow orchestration\n\n\n\nWrap Functions with lifecycle management, making them executable units of work with status tracking, dependencies, and worker assignment. Every task is a **Function + metadata**.\n\n## What is a Task?\n\nA Task extends a [Function](/function) (Code, Generative, Agentic, or Human) with:\n\n* **Status tracking**: pending, queued, assigned, in\\_progress, blocked, completed, failed\n* **Priority levels**: low, normal, high, urgent, critical\n* **Worker assignment**: Who or what should complete it (agent, human, team)\n* **Dependencies**: Tasks that must complete first\n* **Progress tracking**: Percent complete, current step, estimated time\n\n```typescript\nimport { createTask } from 'digital-tasks'\nimport type { FunctionDefinition } from 'ai-functions'\n\n// Define the function this task executes\nconst summarizeFunction: FunctionDefinition = {\n  type: 'generative',\n  name: 'summarize',\n  description: 'Summarize a document',\n  args: { text: 'The text to summarize' },\n  output: 'string',\n  promptTemplate: 'Summarize: {{text}}',\n}\n\n// Create a task from the function\nconst task = await createTask({\n  function: summarizeFunction,\n  input: { text: 'Long article content...' },\n  priority: 'high',\n})\n\nconsole.log(task.id)      // task_1234567890_abc123\nconsole.log(task.status)  // 'queued'\n```\n\n## Task = Function + Metadata\n\n| Aspect       | Function            | Task                           |\n| ------------ | ------------------- | ------------------------------ |\n| Focus        | How to do something | What needs to be done          |\n| Duration     | Usually quick       | Can span hours or days         |\n| Assignment   | Implicit            | Explicit (human, agent, team)  |\n| Tracking     | Execution only      | Full lifecycle                 |\n| Dependencies | None                | Supports blocking dependencies |\n\n## Function Types\n\nTasks wrap one of four function types:\n\n```typescript\n// Code function - deterministic execution\nconst codeTask = await createTask({\n  function: {\n    type: 'code',\n    name: 'processData',\n    args: { data: 'Input data' },\n    output: 'object',\n    code: 'return transform(data)',\n    language: 'typescript',\n  },\n})\n\n// Generative function - AI generates content\nconst generativeTask = await createTask({\n  function: {\n    type: 'generative',\n    name: 'writeEmail',\n    args: { topic: 'Meeting follow-up' },\n    output: 'string',\n    promptTemplate: 'Write an email about: {{topic}}',\n  },\n})\n\n// Agentic function - AI with tools in a loop\nconst agenticTask = await createTask({\n  function: {\n    type: 'agentic',\n    name: 'research',\n    args: { query: 'Research topic' },\n    output: 'object',\n    tools: ['web_search', 'read_file'],\n  },\n})\n\n// Human function - requires human input\nconst humanTask = await createTask({\n  function: {\n    type: 'human',\n    name: 'approve',\n    description: 'Manager approval required',\n    args: { request: 'Approval request' },\n    output: 'object',\n    instructions: 'Please review and approve or reject',\n  },\n})\n```\n\n## Task Lifecycle\n\n```typescript\nimport {\n  createTask,\n  startTask,\n  updateProgress,\n  completeTask,\n  failTask,\n  cancelTask,\n} from 'digital-tasks'\n\n// 1. Create task\nconst task = await createTask({ function: myFunction })\n\n// 2. Start work\nawait startTask(task.id, { type: 'agent', id: 'agent_1', name: 'Worker' })\n\n// 3. Update progress\nawait updateProgress(task.id, 50, 'Processing data')\nawait updateProgress(task.id, 75, 'Generating output')\n\n// 4. Complete or fail\nawait completeTask(task.id, 'Task result')\n// or\nawait failTask(task.id, 'Error message')\n// or\nawait cancelTask(task.id, 'No longer needed')\n```\n\n### Status Flow\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  pending â”‚ -> â”‚  queued  â”‚ -> â”‚ in_progress â”‚ -> â”‚ completed â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n     â”‚               â”‚                 â”‚                  â”‚\n     v               v                 v                  v\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ scheduledâ”‚    â”‚ blocked â”‚      â”‚  failed  â”‚      â”‚ cancelledâ”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Project DSL\n\nDefine task workflows using the declarative DSL:\n\n```typescript\nimport { task, parallel, sequential, createProject, workflow } from 'digital-tasks'\n\n// Create individual tasks\nconst design = task('Design mockups', { priority: 'high' })\nconst spec = task('Write technical spec')\nconst backend = task('Implement backend', { functionType: 'code' })\nconst frontend = task('Implement frontend')\nconst tests = task('Write tests')\nconst review = task('Code review', { functionType: 'human' })\n\n// Organize into parallel and sequential groups\nconst project = createProject({\n  name: 'Launch Feature',\n  tasks: [\n    // These run in parallel\n    parallel(design, spec),\n    // These run sequentially\n    sequential(backend, frontend, tests),\n    // Final review\n    review,\n  ],\n})\n\n// Or use the fluent builder\nconst project2 = workflow('Launch Feature')\n  .parallel(\n    task('Design'),\n    task('Spec'),\n  )\n  .then(task('Implement'))\n  .then(task('Test'))\n  .build()\n```\n\n## Dependencies\n\nTasks can depend on other tasks:\n\n```typescript\nconst task1 = await createTask({ function: func1 })\nconst task2 = await createTask({\n  function: func2,\n  dependencies: [task1.id],  // task2 blocked until task1 completes\n})\n\nconsole.log(task2.status)  // 'blocked'\n\n// When task1 completes, task2 automatically unblocks\nawait completeTask(task1.id, 'done')\nconst updated = await getTask(task2.id)\nconsole.log(updated.status)  // 'queued'\n```\n\n## Dependency Graph Utilities\n\n```typescript\nimport {\n  getDependants,\n  getDependencies,\n  getReadyTasks,\n  hasCycles,\n  sortTasks,\n} from 'digital-tasks'\n\n// Get tasks that depend on this one\nconst dependants = getDependants(task.id, allTasks)\n\n// Get tasks this one depends on\nconst deps = getDependencies(task, allTasks)\n\n// Get tasks ready to execute (no unsatisfied deps)\nconst ready = getReadyTasks(allTasks)\n\n// Check for circular dependencies\nconst cyclic = hasCycles(allTasks)\n\n// Get topologically sorted task order\nconst sorted = sortTasks(allTasks)\n```\n\n## Task Queue\n\nManage task flow with priority-based queuing:\n\n```typescript\nimport { createTaskQueue, taskQueue } from 'digital-tasks'\n\n// Use global queue\nawait taskQueue.add(task)\nconst next = await taskQueue.getNextForWorker({ type: 'agent', id: 'agent_1' })\n\n// Or create isolated queue\nconst myQueue = createTaskQueue({ name: 'my-queue' })\n\n// Query tasks\nconst urgentTasks = await myQueue.query({\n  status: ['queued', 'in_progress'],\n  priority: ['urgent', 'critical'],\n  sortBy: 'priority',\n  sortOrder: 'desc',\n})\n\n// Get queue stats\nconst stats = await myQueue.stats()\n// { total: 100, byStatus: { queued: 50, ... }, byPriority: { high: 20, ... } }\n```\n\n## Markdown Integration\n\nBidirectional conversion between tasks and markdown checklists:\n\n```typescript\nimport { parseMarkdown, toMarkdown } from 'digital-tasks'\n\n// Parse markdown to project\nconst project = parseMarkdown(`\n# Launch Feature\n\n## Planning\n- [ ] Design mockups\n- [ ] Write technical spec\n- [x] Create project board\n\n## Implementation (sequential)\n1. [ ] Implement backend API\n2. [-] Implement frontend UI\n   - [ ] Create components\n   - [ ] Add state management\n3. [ ] Write tests\n\n## Deployment\n1. [ ] Deploy to staging\n2. [ ] QA testing\n3. [ ] Deploy to production\n`)\n\n// Convert project back to markdown\nconst md = toMarkdown(project)\n```\n\n### Markdown Syntax\n\n| Syntax   | Meaning                           |\n| -------- | --------------------------------- |\n| `- [ ]`  | Parallel/unordered task (pending) |\n| `1. [ ]` | Sequential/ordered task (pending) |\n| `[x]`    | Completed                         |\n| `[-]`    | In progress                       |\n| `[~]`    | Blocked                           |\n| `[!]`    | Failed                            |\n| `!!`     | Critical priority                 |\n| `!`      | Urgent priority                   |\n| `^`      | High priority                     |\n| `v`      | Low priority                      |\n\n## Worker Assignment\n\nTasks specify who can work on them:\n\n```typescript\n// Explicit assignment\nconst task = await createTask({\n  function: func,\n  assignTo: { type: 'human', id: 'user_123', name: 'John' },\n})\n\n// Worker type constraints\nconst task2 = await createTask({\n  function: humanFunc,  // type: 'human' -> allowedWorkers: ['human']\n})\n\n// Claim task\nawait taskQueue.claim(task.id, { type: 'agent', id: 'agent_1' })\n```\n\n## Waiting for Completion\n\n```typescript\nimport { waitForTask } from 'digital-tasks'\n\n// Wait for task to complete (with timeout)\nconst result = await waitForTask(task.id, {\n  timeout: 5 * 60 * 1000,  // 5 minutes\n  pollInterval: 1000,       // Check every second\n})\n\nif (result.success) {\n  console.log('Output:', result.output)\n  console.log('Duration:', result.metadata.duration)\n} else {\n  console.log('Error:', result.error.message)\n}\n```\n\n## Subtasks\n\nCreate hierarchical task structures:\n\n```typescript\nimport { createSubtask, getSubtasks } from 'digital-tasks'\n\nconst parent = await createTask({ function: parentFunc })\n\nconst sub1 = await createSubtask(parent.id, { function: subFunc1 })\nconst sub2 = await createSubtask(parent.id, { function: subFunc2 })\n\nconst subtasks = await getSubtasks(parent.id)\n// [sub1, sub2]\n```\n\n## Event History\n\nTasks track their full lifecycle:\n\n```typescript\nconst task = await createTask({ function: func })\nawait startTask(task.id, worker)\nawait addComment(task.id, 'Starting work', worker)\nawait updateProgress(task.id, 50, 'Halfway done')\nawait completeTask(task.id, 'result')\n\nconst updated = await getTask(task.id)\nconsole.log(updated.events)\n// [\n//   { type: 'created', timestamp: ..., message: 'Task created: func' },\n//   { type: 'assigned', timestamp: ..., actor: worker },\n//   { type: 'started', timestamp: ..., actor: worker },\n//   { type: 'comment', timestamp: ..., message: 'Starting work' },\n//   { type: 'progress', timestamp: ..., data: { percent: 50 } },\n//   { type: 'completed', timestamp: ... },\n// ]\n```\n\n## Types\n\n```typescript\nimport type {\n  Task,\n  TaskStatus,\n  TaskPriority,\n  WorkerRef,\n  WorkerType,\n  TaskDependency,\n  TaskProgress,\n  TaskEvent,\n  TaskResult,\n  TaskQueue,\n  FunctionDefinition,\n} from 'digital-tasks'\n\n// Task status\ntype TaskStatus =\n  | 'pending'\n  | 'queued'\n  | 'assigned'\n  | 'in_progress'\n  | 'blocked'\n  | 'review'\n  | 'completed'\n  | 'failed'\n  | 'cancelled'\n\n// Task priority\ntype TaskPriority = 'low' | 'normal' | 'high' | 'urgent' | 'critical'\n\n// Worker types\ntype WorkerType = 'agent' | 'human' | 'team' | 'any'\n```\n\n\n# Task Lifecycle\n\nURL: https://primitives.org.ai/task/lifecycle\n\n> Managing task states, progress, and completion\n\n\n\n# Task Lifecycle\n\nTasks progress through a well-defined lifecycle from creation to completion, with full tracking and event history.\n\n## Task States\n\n```typescript\ntype TaskStatus =\n  | 'pending'      // Created but not queued\n  | 'scheduled'    // Waiting for scheduled time\n  | 'queued'       // Ready to be worked on\n  | 'assigned'     // Assigned to a worker\n  | 'in_progress'  // Actively being worked on\n  | 'blocked'      // Waiting on dependencies\n  | 'review'       // Awaiting review/approval\n  | 'completed'    // Successfully finished\n  | 'failed'       // Failed with error\n  | 'cancelled'    // Manually cancelled\n```\n\n## Status Flow\n\n```\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚  pending â”‚ -> â”‚  queued  â”‚ -> â”‚ in_progress â”‚ -> â”‚ completed â”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n     â”‚               â”‚                 â”‚                  â”‚\n     v               v                 v                  v\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\nâ”‚ scheduledâ”‚    â”‚ blocked â”‚      â”‚  failed  â”‚      â”‚ cancelledâ”‚\nâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n```\n\n## Creating Tasks\n\n```typescript\nimport { createTask } from 'digital-tasks'\n\nconst task = await createTask({\n  function: {\n    type: 'generative',\n    name: 'summarize',\n    description: 'Summarize a document',\n    args: { text: 'The text to summarize' },\n    output: 'string',\n    promptTemplate: 'Summarize: {{text}}',\n  },\n  input: { text: 'Long article content...' },\n  priority: 'high',\n})\n\nconsole.log(task.id)      // task_1234567890_abc123\nconsole.log(task.status)  // 'queued'\n```\n\n## Starting Tasks\n\n```typescript\nimport { startTask } from 'digital-tasks'\n\n// Start task with worker assignment\nawait startTask(task.id, {\n  type: 'agent',\n  id: 'agent_1',\n  name: 'Worker Agent',\n})\n\n// Task is now in_progress\nconst updated = await getTask(task.id)\nconsole.log(updated.status)  // 'in_progress'\nconsole.log(updated.assignedTo)  // { type: 'agent', id: 'agent_1', ... }\n```\n\n## Progress Updates\n\n```typescript\nimport { updateProgress } from 'digital-tasks'\n\n// Update with percentage\nawait updateProgress(task.id, 25, 'Loading data')\nawait updateProgress(task.id, 50, 'Processing')\nawait updateProgress(task.id, 75, 'Generating output')\n\n// Access progress info\nconst task = await getTask(task.id)\nconsole.log(task.progress)\n// {\n//   percent: 75,\n//   currentStep: 'Generating output',\n//   estimatedTimeRemaining: 30000\n// }\n```\n\n## Completing Tasks\n\n```typescript\nimport { completeTask } from 'digital-tasks'\n\n// Complete with result\nawait completeTask(task.id, {\n  summary: 'The article discusses...',\n  wordCount: 150,\n})\n\nconst completed = await getTask(task.id)\nconsole.log(completed.status)  // 'completed'\nconsole.log(completed.result)  // { output: { summary: '...', wordCount: 150 } }\n```\n\n## Failing Tasks\n\n```typescript\nimport { failTask } from 'digital-tasks'\n\n// Fail with error message\nawait failTask(task.id, 'API rate limit exceeded')\n\n// Fail with structured error\nawait failTask(task.id, {\n  code: 'RATE_LIMIT',\n  message: 'API rate limit exceeded',\n  retryAfter: 60000,\n})\n\nconst failed = await getTask(task.id)\nconsole.log(failed.status)  // 'failed'\nconsole.log(failed.result?.error)  // { code: 'RATE_LIMIT', ... }\n```\n\n## Cancelling Tasks\n\n```typescript\nimport { cancelTask } from 'digital-tasks'\n\n// Cancel with reason\nawait cancelTask(task.id, 'No longer needed')\n\nconst cancelled = await getTask(task.id)\nconsole.log(cancelled.status)  // 'cancelled'\n```\n\n## Retrying Tasks\n\n```typescript\nimport { retryTask } from 'digital-tasks'\n\n// Retry a failed task\nconst retried = await retryTask(failedTask.id)\nconsole.log(retried.status)  // 'queued'\nconsole.log(retried.metadata.retryCount)  // 1\n\n// Retry with modified input\nconst retried2 = await retryTask(failedTask.id, {\n  input: { text: 'Modified input...' },\n})\n```\n\n## Event History\n\nTasks maintain a complete event history:\n\n```typescript\nconst task = await getTask(taskId)\n\nconsole.log(task.events)\n// [\n//   { type: 'created', timestamp: '...', message: 'Task created' },\n//   { type: 'queued', timestamp: '...' },\n//   { type: 'assigned', timestamp: '...', actor: { type: 'agent', ... } },\n//   { type: 'started', timestamp: '...', actor: { type: 'agent', ... } },\n//   { type: 'progress', timestamp: '...', data: { percent: 50 } },\n//   { type: 'completed', timestamp: '...' },\n// ]\n```\n\n### Adding Comments\n\n```typescript\nimport { addComment } from 'digital-tasks'\n\nawait addComment(task.id, 'Found an edge case, handling it', worker)\n\n// Comment appears in events\nconst task = await getTask(task.id)\nconst comments = task.events.filter(e => e.type === 'comment')\n```\n\n## Task Priority\n\n```typescript\ntype TaskPriority = 'low' | 'normal' | 'high' | 'urgent' | 'critical'\n\n// Create with priority\nconst urgentTask = await createTask({\n  function: func,\n  priority: 'urgent',\n})\n\n// Update priority\nimport { updateTask } from 'digital-tasks'\n\nawait updateTask(task.id, { priority: 'critical' })\n```\n\n### Priority Order\n\n```typescript\nconst priorityOrder = {\n  critical: 5,  // Do immediately\n  urgent: 4,    // Do next\n  high: 3,      // Important\n  normal: 2,    // Default\n  low: 1,       // When time permits\n}\n```\n\n## Scheduled Tasks\n\n```typescript\n// Schedule for future execution\nconst scheduled = await createTask({\n  function: func,\n  scheduledFor: new Date('2024-12-31T00:00:00Z'),\n})\n\nconsole.log(scheduled.status)  // 'scheduled'\n\n// Task will automatically move to 'queued' at scheduled time\n```\n\n## Task Metadata\n\n```typescript\nconst task = await getTask(taskId)\n\nconsole.log(task.metadata)\n// {\n//   createdAt: '2024-01-15T10:00:00Z',\n//   startedAt: '2024-01-15T10:05:00Z',\n//   completedAt: '2024-01-15T10:10:00Z',\n//   duration: 300000,  // 5 minutes in ms\n//   retryCount: 0,\n//   executionCount: 1,\n// }\n```\n\n## Waiting for Completion\n\n```typescript\nimport { waitForTask } from 'digital-tasks'\n\n// Wait with timeout\nconst result = await waitForTask(task.id, {\n  timeout: 5 * 60 * 1000,  // 5 minutes\n  pollInterval: 1000,       // Check every second\n})\n\nif (result.success) {\n  console.log('Output:', result.output)\n} else {\n  console.log('Error:', result.error)\n}\n```\n\n## Bulk Operations\n\n```typescript\nimport { bulkUpdateStatus, bulkCancel } from 'digital-tasks'\n\n// Update multiple tasks\nawait bulkUpdateStatus(['task_1', 'task_2', 'task_3'], 'queued')\n\n// Cancel multiple tasks\nawait bulkCancel(['task_4', 'task_5'], 'Sprint cancelled')\n```\n\n## State Transitions\n\nValid state transitions are enforced:\n\n```typescript\n// Valid transitions\npending -> queued, scheduled, cancelled\nscheduled -> queued, cancelled\nqueued -> assigned, blocked, cancelled\nassigned -> in_progress, queued, cancelled\nin_progress -> completed, failed, review, cancelled\nblocked -> queued, cancelled\nreview -> completed, in_progress, cancelled\n\n// Invalid transitions throw errors\nawait completeTask(pendingTask.id, result)  // Error: Cannot complete pending task\n```\n\n\n# Markdown Integration\n\nURL: https://primitives.org.ai/task/markdown\n\n> Convert between tasks and markdown checklists\n\n\n\n# Markdown Integration\n\nBidirectional conversion between task structures and markdown checklists enables human-readable task definitions and documentation.\n\n## Parsing Markdown\n\n```typescript\nimport { parseMarkdown } from 'digital-tasks'\n\nconst project = parseMarkdown(`\n# Launch Feature\n\n## Planning\n- [ ] Design mockups\n- [ ] Write technical spec\n- [x] Create project board\n\n## Implementation\n1. [ ] Build backend API\n2. [ ] Build frontend UI\n3. [ ] Write tests\n\n## Deployment\n- [ ] Deploy to staging\n- [ ] QA review\n- [ ] Deploy to production\n`)\n\nconsole.log(project.name)  // 'Launch Feature'\nconsole.log(project.tasks.length)  // 9 tasks\n```\n\n## Converting to Markdown\n\n```typescript\nimport { toMarkdown } from 'digital-tasks'\n\nconst project = createProject({\n  name: 'My Project',\n  tasks: [\n    parallel(\n      task('Design', { status: 'completed' }),\n      task('Spec', { status: 'in_progress' }),\n    ),\n    task('Implement'),\n  ],\n})\n\nconst md = toMarkdown(project)\nconsole.log(md)\n// # My Project\n//\n// ## Tasks\n// - [x] Design\n// - [-] Spec\n// - [ ] Implement\n```\n\n## Status Markers\n\n| Markdown | Status       | Description             |\n| -------- | ------------ | ----------------------- |\n| `[ ]`    | pending      | Not started             |\n| `[-]`    | in\\_progress | Currently working       |\n| `[x]`    | completed    | Finished                |\n| `[~]`    | blocked      | Waiting on dependencies |\n| `[!]`    | failed       | Failed with error       |\n| `[/]`    | cancelled    | Cancelled               |\n\n```typescript\nconst project = parseMarkdown(`\n- [ ] Pending task\n- [-] In progress task\n- [x] Completed task\n- [~] Blocked task\n- [!] Failed task\n- [/] Cancelled task\n`)\n```\n\n## Priority Markers\n\n| Marker | Priority | Description       |\n| ------ | -------- | ----------------- |\n| `!!`   | critical | Do immediately    |\n| `!`    | urgent   | Do next           |\n| `^`    | high     | Important         |\n| (none) | normal   | Default           |\n| `v`    | low      | When time permits |\n\n```typescript\nconst project = parseMarkdown(`\n- [ ] !! Critical task\n- [ ] ! Urgent task\n- [ ] ^ High priority task\n- [ ] Normal task\n- [ ] v Low priority task\n`)\n```\n\n## Parallel vs Sequential\n\n```typescript\n// Unordered lists = parallel (can run simultaneously)\nconst parallelMd = `\n- [ ] Task A\n- [ ] Task B\n- [ ] Task C\n`\n\n// Ordered lists = sequential (must run in order)\nconst sequentialMd = `\n1. [ ] Step 1\n2. [ ] Step 2\n3. [ ] Step 3\n`\n\nconst parallel = parseMarkdown(parallelMd)\n// Tasks have no dependencies on each other\n\nconst sequential = parseMarkdown(sequentialMd)\n// Step 2 depends on Step 1, Step 3 depends on Step 2\n```\n\n## Nested Tasks\n\n```typescript\nconst project = parseMarkdown(`\n# Feature Development\n\n- [ ] Implement backend\n  - [ ] Create API endpoints\n  - [ ] Add database models\n  - [ ] Write migrations\n- [ ] Implement frontend\n  - [ ] Build components\n  - [ ] Add state management\n  - [ ] Style with CSS\n`)\n\n// Creates parent tasks with subtasks\nconst backend = project.tasks.find(t => t.name === 'Implement backend')\nconsole.log(backend.subtasks.length)  // 3\n```\n\n## Sections as Groups\n\n```typescript\nconst project = parseMarkdown(`\n# My Project\n\n## Phase 1: Planning\n- [ ] Research\n- [ ] Design\n\n## Phase 2: Development\n1. [ ] Implement\n2. [ ] Test\n\n## Phase 3: Launch\n- [ ] Deploy\n- [ ] Monitor\n`)\n\n// Sections become task groups\nconsole.log(project.groups)\n// [\n//   { name: 'Phase 1: Planning', type: 'parallel', tasks: [...] },\n//   { name: 'Phase 2: Development', type: 'sequential', tasks: [...] },\n//   { name: 'Phase 3: Launch', type: 'parallel', tasks: [...] },\n// ]\n```\n\n## Function Type Hints\n\n```typescript\nconst project = parseMarkdown(`\n- [ ] Write code @code\n- [ ] Generate content @ai\n- [ ] Review changes @human\n- [ ] Research topic @agentic\n`)\n\n// Function types parsed from hints\nproject.tasks[0].function.type  // 'code'\nproject.tasks[1].function.type  // 'generative'\nproject.tasks[2].function.type  // 'human'\nproject.tasks[3].function.type  // 'agentic'\n```\n\n## Assignment Hints\n\n```typescript\nconst project = parseMarkdown(`\n- [ ] Design mockups @assign:john\n- [ ] Code review @assign:team:engineering\n- [ ] Deploy @assign:agent:deploy-bot\n`)\n\n// Assignments parsed from hints\nproject.tasks[0].assignTo  // { type: 'human', id: 'john' }\nproject.tasks[1].assignTo  // { type: 'team', id: 'engineering' }\nproject.tasks[2].assignTo  // { type: 'agent', id: 'deploy-bot' }\n```\n\n## Metadata in YAML Front Matter\n\n```typescript\nconst project = parseMarkdown(`\n---\nname: Q1 Planning\ndescription: Quarterly planning tasks\npriority: high\ndeadline: 2024-03-31\n---\n\n# Q1 Planning\n\n- [ ] Set goals\n- [ ] Allocate resources\n- [ ] Define milestones\n`)\n\nconsole.log(project.metadata)\n// { priority: 'high', deadline: '2024-03-31' }\n```\n\n## Roundtrip Conversion\n\n```typescript\nimport { parseMarkdown, toMarkdown } from 'digital-tasks'\n\n// Parse markdown to project\nconst project = parseMarkdown(originalMd)\n\n// Make changes\nawait completeTask(project.tasks[0].id, result)\n\n// Convert back to markdown\nconst updatedMd = toMarkdown(project)\n\n// Markdown reflects task completion\n// - [x] First task (was - [ ])\n```\n\n## Formatting Options\n\n```typescript\nconst md = toMarkdown(project, {\n  includeStatus: true,       // Include status markers\n  includePriority: true,     // Include priority markers\n  includeAssignments: true,  // Include @assign hints\n  includeFunctionType: true, // Include @code, @ai hints\n  groupByStatus: false,      // Group tasks by status\n  includeMetadata: true,     // Include YAML front matter\n  checkboxStyle: 'github',   // 'github' | 'standard'\n})\n```\n\n## Diff and Sync\n\n```typescript\nimport { diffMarkdown, syncMarkdown } from 'digital-tasks'\n\n// Compare two markdown versions\nconst diff = diffMarkdown(oldMd, newMd)\nconsole.log(diff.added)    // New tasks\nconsole.log(diff.removed)  // Removed tasks\nconsole.log(diff.changed)  // Status changes\n\n// Sync external markdown with project\nconst synced = syncMarkdown(project, externalMd, {\n  conflictResolution: 'external',  // 'project' | 'external' | 'manual'\n})\n```\n\n## File Integration\n\n```typescript\nimport { loadMarkdownFile, saveMarkdownFile } from 'digital-tasks'\n\n// Load from file\nconst project = await loadMarkdownFile('./TODO.md')\n\n// Make changes\nawait updateTask(project.tasks[0].id, { status: 'completed' })\n\n// Save back to file\nawait saveMarkdownFile(project, './TODO.md')\n```\n\n## Best Practices\n\n1. **Use consistent formatting** - Stick to one style throughout\n2. **Keep nesting shallow** - Deep nesting is hard to read\n3. **Use sections for phases** - Organize with markdown headers\n4. **Add metadata in front matter** - Keep task list clean\n5. **Sync regularly** - Keep markdown and project in sync\n6. **Use ordered lists for sequences** - Makes dependencies clear\n\n\n# Task Queue\n\nURL: https://primitives.org.ai/task/queue\n\n> Priority-based task queuing and worker management\n\n\n\n# Task Queue\n\nThe task queue manages work distribution, prioritization, and worker assignment for efficient task execution.\n\n## Basic Queue Operations\n\n```typescript\nimport { taskQueue, createTaskQueue } from 'digital-tasks'\n\n// Use global queue\nawait taskQueue.add(task)\n\n// Or create isolated queue\nconst myQueue = createTaskQueue({ name: 'my-queue' })\nawait myQueue.add(task)\n```\n\n## Adding Tasks\n\n```typescript\n// Add single task\nawait taskQueue.add(task)\n\n// Add multiple tasks\nawait taskQueue.addBatch([task1, task2, task3])\n\n// Add with options\nawait taskQueue.add(task, {\n  priority: 'high',\n  delayUntil: new Date('2024-12-01'),\n})\n```\n\n## Getting Next Task\n\n```typescript\n// Get next task for a worker\nconst worker = { type: 'agent', id: 'agent_1', name: 'Worker' }\nconst next = await taskQueue.getNextForWorker(worker)\n\nif (next) {\n  console.log(`Starting task: ${next.name}`)\n  await startTask(next.id, worker)\n}\n```\n\n### Worker Capabilities\n\n```typescript\n// Worker with specific capabilities\nconst worker = {\n  type: 'agent',\n  id: 'agent_1',\n  name: 'Specialized Agent',\n  capabilities: ['code', 'generative'],  // Can handle these function types\n}\n\n// Queue matches tasks to worker capabilities\nconst next = await taskQueue.getNextForWorker(worker)\n// Only returns tasks the worker can handle\n```\n\n## Claiming Tasks\n\n```typescript\n// Claim a specific task\nconst claimed = await taskQueue.claim(taskId, worker)\n\nif (claimed) {\n  console.log('Task claimed successfully')\n} else {\n  console.log('Task already claimed by another worker')\n}\n```\n\n## Releasing Tasks\n\n```typescript\n// Release task back to queue (e.g., worker going offline)\nawait taskQueue.release(taskId)\n\n// Release with reason\nawait taskQueue.release(taskId, {\n  reason: 'Worker shutting down',\n  requeue: true,  // Put back in queue vs leave unassigned\n})\n```\n\n## Query Tasks\n\n```typescript\n// Query with filters\nconst results = await taskQueue.query({\n  status: ['queued', 'in_progress'],\n  priority: ['urgent', 'critical'],\n  functionType: ['generative'],\n  assignedTo: { type: 'agent', id: 'agent_1' },\n  createdAfter: new Date('2024-01-01'),\n  createdBefore: new Date('2024-12-31'),\n})\n\n// Sort results\nconst sorted = await taskQueue.query({\n  status: ['queued'],\n  sortBy: 'priority',    // 'priority' | 'createdAt' | 'scheduledFor'\n  sortOrder: 'desc',     // 'asc' | 'desc'\n  limit: 10,\n  offset: 0,\n})\n```\n\n## Queue Statistics\n\n```typescript\nconst stats = await taskQueue.stats()\n\nconsole.log(stats)\n// {\n//   total: 100,\n//   byStatus: {\n//     queued: 50,\n//     in_progress: 20,\n//     completed: 25,\n//     failed: 5,\n//   },\n//   byPriority: {\n//     critical: 5,\n//     urgent: 10,\n//     high: 20,\n//     normal: 50,\n//     low: 15,\n//   },\n//   byFunctionType: {\n//     code: 30,\n//     generative: 40,\n//     agentic: 20,\n//     human: 10,\n//   },\n//   avgWaitTime: 30000,      // ms\n//   avgProcessingTime: 60000, // ms\n// }\n```\n\n## Priority Queue\n\nTasks are processed by priority:\n\n```typescript\n// Critical tasks processed first\nawait taskQueue.add(normalTask)\nawait taskQueue.add(criticalTask)\nawait taskQueue.add(urgentTask)\n\n// getNextForWorker returns in priority order:\n// 1. criticalTask\n// 2. urgentTask\n// 3. normalTask\n```\n\n### Priority Escalation\n\n```typescript\n// Automatically escalate priority based on wait time\nconst queue = createTaskQueue({\n  name: 'escalating-queue',\n  escalation: {\n    enabled: true,\n    rules: [\n      { waitTime: 5 * 60 * 1000, escalateTo: 'high' },    // 5 min -> high\n      { waitTime: 15 * 60 * 1000, escalateTo: 'urgent' }, // 15 min -> urgent\n      { waitTime: 30 * 60 * 1000, escalateTo: 'critical' }, // 30 min -> critical\n    ],\n  },\n})\n```\n\n## Fair Scheduling\n\nEnsure all task types get processed:\n\n```typescript\nconst queue = createTaskQueue({\n  name: 'fair-queue',\n  scheduling: {\n    strategy: 'fair',\n    weights: {\n      code: 1,\n      generative: 2,    // Process more generative tasks\n      agentic: 1,\n      human: 0.5,       // Human tasks less frequently auto-assigned\n    },\n  },\n})\n```\n\n## Dead Letter Queue\n\nHandle tasks that repeatedly fail:\n\n```typescript\nconst queue = createTaskQueue({\n  name: 'main-queue',\n  deadLetter: {\n    enabled: true,\n    maxRetries: 3,\n    destination: 'failed-tasks',  // Move to this queue after max retries\n  },\n})\n\n// Check dead letter queue\nconst failed = await deadLetterQueue.query({ status: ['failed'] })\n```\n\n## Worker Pool\n\nManage multiple workers:\n\n```typescript\nimport { createWorkerPool } from 'digital-tasks'\n\nconst pool = createWorkerPool({\n  queue: taskQueue,\n  workers: [\n    { type: 'agent', id: 'agent_1', capabilities: ['code'] },\n    { type: 'agent', id: 'agent_2', capabilities: ['generative'] },\n    { type: 'agent', id: 'agent_3', capabilities: ['agentic'] },\n  ],\n  concurrency: 3,  // Max concurrent tasks per worker\n})\n\n// Start processing\nawait pool.start()\n\n// Stop gracefully\nawait pool.stop({ waitForCurrent: true })\n```\n\n## Rate Limiting\n\nControl task processing rate:\n\n```typescript\nconst queue = createTaskQueue({\n  name: 'rate-limited',\n  rateLimit: {\n    tasksPerSecond: 10,\n    burstSize: 20,\n  },\n})\n```\n\n## Queue Events\n\n```typescript\ntaskQueue.on('task:added', (task) => {\n  console.log(`Task added: ${task.id}`)\n})\n\ntaskQueue.on('task:claimed', ({ task, worker }) => {\n  console.log(`Task ${task.id} claimed by ${worker.name}`)\n})\n\ntaskQueue.on('task:completed', (task) => {\n  console.log(`Task ${task.id} completed`)\n})\n\ntaskQueue.on('task:failed', ({ task, error }) => {\n  console.log(`Task ${task.id} failed: ${error}`)\n})\n\ntaskQueue.on('queue:empty', () => {\n  console.log('Queue is empty')\n})\n```\n\n## Batch Processing\n\n```typescript\n// Process tasks in batches\nconst batch = await taskQueue.getBatch({\n  size: 10,\n  worker,\n  timeout: 5000,  // Wait up to 5s for batch to fill\n})\n\n// Process all tasks\nconst results = await Promise.all(\n  batch.map(task => processTask(task))\n)\n\n// Complete all\nawait taskQueue.completeBatch(\n  batch.map((task, i) => ({ taskId: task.id, result: results[i] }))\n)\n```\n\n## Isolation and Namespacing\n\n```typescript\n// Create isolated queues for different purposes\nconst userQueue = createTaskQueue({ name: 'user-tasks' })\nconst systemQueue = createTaskQueue({ name: 'system-tasks' })\nconst batchQueue = createTaskQueue({ name: 'batch-jobs' })\n\n// Each queue is independent\nawait userQueue.add(userTask)\nawait systemQueue.add(systemTask)\n```\n\n## Best Practices\n\n1. **Set appropriate priorities** - Reserve critical/urgent for truly time-sensitive work\n2. **Use worker capabilities** - Match tasks to appropriate workers\n3. **Monitor queue depth** - Alert on growing backlogs\n4. **Configure dead letter** - Don't lose failed tasks\n5. **Use rate limiting** - Protect downstream services\n6. **Implement fair scheduling** - Prevent task type starvation\n\n\n# Clients\n\nURL: https://primitives.org.ai/service/clients\n\n> Connect to services\n\n\n\n# Clients\n\nUse the `Client()` function to connect to and consume services.\n\n## Basic Usage\n\n```typescript\nimport { Client } from 'services-as-software'\n\nconst client = Client({\n  url: 'https://api.example.com/service',\n})\n\nconst result = await client.call('translate', {\n  text: 'Hello',\n  to: 'es',\n})\n```\n\n## Authentication\n\n### API Key\n\n```typescript\nconst client = Client({\n  url: 'https://api.example.com/service',\n  auth: {\n    type: 'api-key',\n    credentials: {\n      apiKey: 'your-api-key',\n    },\n  },\n})\n```\n\n### Bearer Token\n\n```typescript\nconst client = Client({\n  url: 'https://api.example.com/service',\n  auth: {\n    type: 'bearer',\n    credentials: {\n      token: 'your-jwt-token',\n    },\n  },\n})\n```\n\n### OAuth\n\n```typescript\nconst client = Client({\n  url: 'https://api.example.com/service',\n  auth: {\n    type: 'oauth',\n    credentials: {\n      clientId: 'client-id',\n      clientSecret: 'client-secret',\n      tokenUrl: 'https://auth.example.com/token',\n    },\n  },\n})\n```\n\n### Basic Auth\n\n```typescript\nconst client = Client({\n  url: 'https://api.example.com/service',\n  auth: {\n    type: 'basic',\n    credentials: {\n      username: 'user',\n      password: 'pass',\n    },\n  },\n})\n```\n\n## Client Methods\n\n### call(endpoint, input)\n\nCall a service endpoint:\n\n```typescript\nconst result = await client.call('endpoint-name', {\n  param1: 'value1',\n  param2: 'value2',\n})\n```\n\n### do(action, input)\n\nExecute an action (alias for call):\n\n```typescript\nconst result = await client.do('translate', {\n  text: 'Hello',\n  to: 'es',\n})\n```\n\n## Service Operations\n\nServices expose helpers for common operations:\n\n### ask()\n\nAsk a question:\n\n```typescript\nconst answer = await client.ask('What is the capital of France?')\n```\n\n### generate()\n\nGenerate content:\n\n```typescript\nconst content = await client.generate({\n  type: 'blog-post',\n  topic: 'AI trends',\n  length: 'medium',\n})\n```\n\n### is()\n\nType checking/validation:\n\n```typescript\nconst valid = await client.is(email, 'valid-email')\n```\n\n## Error Handling\n\n```typescript\nimport { Client, ServiceError } from 'services-as-software'\n\nconst client = Client({ url: 'https://api.example.com' })\n\ntry {\n  const result = await client.call('process', { data: '...' })\n} catch (error) {\n  if (error instanceof ServiceError) {\n    console.error(`Service error: ${error.code} - ${error.message}`)\n    console.error(`Status: ${error.status}`)\n  }\n}\n```\n\n## Retry Configuration\n\n```typescript\nconst client = Client({\n  url: 'https://api.example.com/service',\n  retry: {\n    attempts: 3,\n    delay: 1000,        // ms\n    backoff: 'exponential',\n  },\n})\n```\n\n## Timeout Configuration\n\n```typescript\nconst client = Client({\n  url: 'https://api.example.com/service',\n  timeout: 30000,  // 30 seconds\n})\n```\n\n## Complete Example\n\n```typescript\nimport { Client, ServiceError } from 'services-as-software'\n\n// Create client\nconst translationClient = Client({\n  url: 'https://translation.api.example.com',\n  auth: {\n    type: 'api-key',\n    credentials: {\n      apiKey: process.env.TRANSLATION_API_KEY,\n    },\n  },\n  timeout: 10000,\n  retry: {\n    attempts: 3,\n    delay: 500,\n    backoff: 'exponential',\n  },\n})\n\n// Use client\nasync function translateDocument(text: string, targetLang: string) {\n  try {\n    const result = await translationClient.call('translate', {\n      text,\n      to: targetLang,\n    })\n\n    return {\n      translated: result.translatedText,\n      confidence: result.confidence,\n      detectedLanguage: result.sourceLanguage,\n    }\n  } catch (error) {\n    if (error instanceof ServiceError) {\n      if (error.status === 429) {\n        // Rate limited\n        throw new Error('Translation service rate limit exceeded')\n      }\n      throw new Error(`Translation failed: ${error.message}`)\n    }\n    throw error\n  }\n}\n\n// Usage\nconst result = await translateDocument('Hello, world!', 'es')\nconsole.log(result.translated)\n// \"Â¡Hola, mundo!\"\n```\n\n## Batch Requests\n\nFor multiple requests:\n\n```typescript\nconst results = await Promise.all([\n  client.call('translate', { text: 'Hello', to: 'es' }),\n  client.call('translate', { text: 'Goodbye', to: 'es' }),\n  client.call('translate', { text: 'Thank you', to: 'es' }),\n])\n```\n\n## Type Definition\n\n```typescript\ninterface ClientConfig {\n  url: string\n  auth?: {\n    type: 'api-key' | 'bearer' | 'oauth' | 'basic'\n    credentials: Record<string, string>\n  }\n  timeout?: number\n  retry?: {\n    attempts: number\n    delay: number\n    backoff?: 'linear' | 'exponential'\n  }\n  headers?: Record<string, string>\n}\n```\n\n\n# Defining Services\n\nURL: https://primitives.org.ai/service/defining\n\n> Create AI-powered services\n\n\n\n# Defining Services\n\nThe `Service()` function creates AI-powered services that operate as softwareâ€”scalable, always-on, and continuously improving.\n\n## Basic Usage\n\n```typescript\nimport { Service, POST } from 'services-as-software'\n\nconst translationService = Service({\n  name: 'translation-service',\n  version: '1.0.0',\n  description: 'AI-powered translation service',\n\n  pricing: {\n    model: 'per-use',\n    pricePerUnit: 0.01,\n    currency: 'USD',\n  },\n\n  endpoints: [\n    POST({\n      name: 'translate',\n      path: '/translate',\n      handler: async (input) => {\n        // Translation logic\n        return {\n          translatedText: `Translated: ${input.text}`,\n          confidence: 0.95,\n        }\n      },\n    }),\n  ],\n})\n```\n\n## Service Properties\n\n| Property      | Description           |\n| ------------- | --------------------- |\n| `name`        | Service identifier    |\n| `version`     | Semantic version      |\n| `description` | Service description   |\n| `pricing`     | Pricing configuration |\n| `endpoints`   | Service endpoints     |\n| `plans`       | Subscription plans    |\n| `kpis`        | Performance metrics   |\n\n## Complete Example\n\n```typescript\nimport { Service, POST, GET } from 'services-as-software'\n\nconst codeReviewService = Service({\n  name: 'code-review',\n  version: '2.0.0',\n  description: 'AI-powered code review service',\n\n  pricing: {\n    model: 'per-use',\n    pricePerUnit: 0.10,\n    currency: 'USD',\n  },\n\n  endpoints: [\n    POST({\n      name: 'review',\n      path: '/review',\n      handler: async (input, context) => {\n        const { code, language } = input\n\n        // Perform AI code review\n        const issues = await analyzeCode(code, language)\n        const suggestions = await generateSuggestions(issues)\n\n        return {\n          issues,\n          suggestions,\n          score: calculateScore(issues),\n          reviewed_at: new Date().toISOString(),\n        }\n      },\n    }),\n\n    GET({\n      name: 'languages',\n      path: '/languages',\n      handler: async () => {\n        return {\n          supported: ['javascript', 'typescript', 'python', 'go', 'rust'],\n        }\n      },\n    }),\n  ],\n\n  plans: [\n    {\n      id: 'starter',\n      name: 'Starter',\n      pricing: { model: 'subscription', basePrice: 29, currency: 'USD', interval: 'monthly' },\n      entitlements: ['basic-review'],\n      features: ['100 reviews/month', 'Basic suggestions'],\n    },\n    {\n      id: 'pro',\n      name: 'Pro',\n      pricing: { model: 'subscription', basePrice: 99, currency: 'USD', interval: 'monthly' },\n      entitlements: ['basic-review', 'advanced-review', 'security-scan'],\n      features: ['Unlimited reviews', 'Security scanning', 'Custom rules'],\n    },\n  ],\n\n  kpis: [\n    {\n      id: 'reviews-per-day',\n      name: 'Daily Reviews',\n      calculate: async () => getDailyReviewCount(),\n      target: 1000,\n    },\n    {\n      id: 'avg-response-time',\n      name: 'Avg Response Time',\n      calculate: async () => getAvgResponseTime(),\n      target: 5000, // 5 seconds\n    },\n  ],\n})\n```\n\n## Calling the Service\n\n```typescript\n// Direct invocation\nconst result = await translationService.call('translate', {\n  text: 'Hello, world!',\n  to: 'es',\n})\nconsole.log(result.translatedText)\n// \"Â¡Hola, mundo!\"\n```\n\n## Service Types\n\n### Analysis Services\n\nTransform data into insights:\n\n```typescript\nconst sentimentService = Service({\n  name: 'sentiment-analysis',\n  version: '1.0.0',\n\n  endpoints: [\n    POST({\n      name: 'analyze',\n      handler: async ({ text }) => ({\n        sentiment: 'positive',\n        confidence: 0.92,\n        emotions: ['joy', 'trust'],\n      }),\n    }),\n  ],\n})\n```\n\n### Creation Services\n\nGenerate content and artifacts:\n\n```typescript\nconst contentService = Service({\n  name: 'content-generation',\n  version: '1.0.0',\n\n  endpoints: [\n    POST({\n      name: 'generate',\n      handler: async ({ topic, type, tone }) => ({\n        content: '...',\n        wordCount: 500,\n        readingTime: '2 min',\n      }),\n    }),\n  ],\n})\n```\n\n### Processing Services\n\nHandle operational tasks:\n\n```typescript\nconst invoiceService = Service({\n  name: 'invoice-processing',\n  version: '1.0.0',\n\n  endpoints: [\n    POST({\n      name: 'extract',\n      handler: async ({ document }) => ({\n        vendor: 'Acme Corp',\n        amount: 1500.00,\n        currency: 'USD',\n        dueDate: '2024-12-31',\n      }),\n    }),\n  ],\n})\n```\n\n## Type Definition\n\n```typescript\ninterface ServiceDefinition {\n  name: string\n  version?: string\n  description?: string\n  pricing?: PricingDefinition\n  endpoints?: EndpointDefinition[]\n  plans?: PlanDefinition[]\n  kpis?: KPIDefinition[]\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Endpoints\n\nURL: https://primitives.org.ai/service/endpoints\n\n> Define service endpoints\n\n\n\n# Endpoints\n\nEndpoints define how clients interact with your service. Use HTTP method helpers for a clean, declarative API.\n\n## HTTP Method Helpers\n\n```typescript\nimport { POST, GET, PUT, DELETE, PATCH } from 'services-as-software'\n```\n\n| Method     | Description                   |\n| ---------- | ----------------------------- |\n| `POST()`   | Create resources, submit data |\n| `GET()`    | Retrieve resources            |\n| `PUT()`    | Replace resources             |\n| `PATCH()`  | Update resources              |\n| `DELETE()` | Remove resources              |\n\n## Basic Endpoint\n\n```typescript\nimport { Service, POST } from 'services-as-software'\n\nconst service = Service({\n  name: 'my-service',\n  endpoints: [\n    POST({\n      name: 'process',\n      path: '/process',\n      handler: async (input, context) => {\n        return { processed: true }\n      },\n    }),\n  ],\n})\n```\n\n## Endpoint Properties\n\n```typescript\nPOST({\n  name: 'endpoint-name',       // Identifier\n  path: '/path',               // URL path\n  handler: async (input, context) => {\n    // Implementation\n    return result\n  },\n  rateLimit: {                 // Optional rate limiting\n    requests: 100,\n    window: 60,\n  },\n  auth: true,                  // Require authentication\n  description: 'What it does', // Documentation\n})\n```\n\n## Handler Function\n\nThe handler receives two parameters:\n\n```typescript\nhandler: async (input, context) => {\n  // input - Request body/params\n  // context - Request context (user, headers, etc.)\n\n  return { result: 'data' }\n}\n```\n\n### Input\n\nContains the request data:\n\n```typescript\nPOST({\n  name: 'translate',\n  handler: async (input) => {\n    const { text, targetLanguage } = input\n    // Process input\n    return { translated: '...' }\n  },\n})\n```\n\n### Context\n\nContains request metadata:\n\n```typescript\nPOST({\n  name: 'protected',\n  handler: async (input, context) => {\n    const { user, headers, ip } = context\n\n    if (!user) {\n      throw new Error('Unauthorized')\n    }\n\n    return { userId: user.id }\n  },\n})\n```\n\n## Multiple Endpoints\n\n```typescript\nconst apiService = Service({\n  name: 'api-service',\n  endpoints: [\n    GET({\n      name: 'list',\n      path: '/items',\n      handler: async () => {\n        return { items: await db.items.findMany() }\n      },\n    }),\n\n    GET({\n      name: 'get',\n      path: '/items/:id',\n      handler: async ({ id }) => {\n        return await db.items.findById(id)\n      },\n    }),\n\n    POST({\n      name: 'create',\n      path: '/items',\n      handler: async (data) => {\n        return await db.items.create(data)\n      },\n    }),\n\n    PUT({\n      name: 'update',\n      path: '/items/:id',\n      handler: async ({ id, ...data }) => {\n        return await db.items.update(id, data)\n      },\n    }),\n\n    DELETE({\n      name: 'delete',\n      path: '/items/:id',\n      handler: async ({ id }) => {\n        await db.items.delete(id)\n        return { deleted: true }\n      },\n    }),\n  ],\n})\n```\n\n## Rate Limiting\n\nAdd rate limits per endpoint:\n\n```typescript\nPOST({\n  name: 'expensive-operation',\n  path: '/generate',\n  rateLimit: {\n    requests: 10,    // Max requests\n    window: 60,      // Per 60 seconds\n  },\n  handler: async (input) => {\n    // Rate-limited operation\n  },\n})\n```\n\n## Authentication\n\nRequire authentication:\n\n```typescript\nPOST({\n  name: 'protected',\n  path: '/private',\n  auth: true,\n  handler: async (input, context) => {\n    // context.user is guaranteed to exist\n    return { userId: context.user.id }\n  },\n})\n```\n\n## Error Handling\n\nReturn errors from handlers:\n\n```typescript\nPOST({\n  name: 'validate',\n  handler: async (input) => {\n    if (!input.data) {\n      throw new Error('Data is required')\n    }\n\n    if (!isValid(input.data)) {\n      return {\n        error: {\n          code: 'VALIDATION_ERROR',\n          message: 'Invalid data format',\n        },\n      }\n    }\n\n    return { valid: true }\n  },\n})\n```\n\n## Async Operations\n\nFor long-running tasks:\n\n```typescript\nPOST({\n  name: 'generate-report',\n  handler: async (input, context) => {\n    // Start async job\n    const jobId = await jobs.create({\n      type: 'report',\n      params: input,\n    })\n\n    return {\n      jobId,\n      status: 'processing',\n      checkUrl: `/jobs/${jobId}`,\n    }\n  },\n})\n\nGET({\n  name: 'check-job',\n  path: '/jobs/:id',\n  handler: async ({ id }) => {\n    const job = await jobs.get(id)\n    return {\n      status: job.status,\n      result: job.result,\n    }\n  },\n})\n```\n\n## Generic Endpoint Helper\n\nFor more control, use the generic `Endpoint`:\n\n```typescript\nimport { Endpoint } from 'services-as-software'\n\nEndpoint({\n  method: 'POST',\n  name: 'custom',\n  path: '/custom',\n  handler: async (input) => {\n    return { custom: true }\n  },\n})\n```\n\n## Type Definition\n\n```typescript\ninterface EndpointConfig {\n  name: string\n  path?: string\n  handler: (input: any, context: Context) => Promise<any>\n  rateLimit?: {\n    requests: number\n    window: number\n  }\n  auth?: boolean\n  description?: string\n}\n```\n\n\n# Service\n\nURL: https://primitives.org.ai/service\n\n> Services-as-Softwareâ€”AI delivering work traditionally performed by humans\n\n\n\nAI systems that deliver work traditionally performed by humans, packaged as callable services that scale infinitely and improve continuously.\n\n## The Shift\n\nTraditional services require human labor for every unit of output. Services-as-Software encapsulate expertise, judgment, and execution into software that:\n\n* Scales without proportional headcount\n* Operates 24/7 with consistent quality\n* Improves from every interaction\n* Costs marginal compute instead of salaries\n\n```typescript\nimport { service, sla, pricing } from 'services-as-software'\n\nconst codeReviewService = service({\n  name: 'code-review',\n  description: 'Expert code review for pull requests',\n\n  // What the service does\n  input: z.object({\n    repository: z.string(),\n    pullRequest: z.number(),\n    reviewType: z.enum(['security', 'performance', 'general']),\n  }),\n\n  output: z.object({\n    approved: z.boolean(),\n    comments: z.array(reviewComment),\n    summary: z.string(),\n    suggestions: z.array(codeSuggestion),\n  }),\n\n  // How it's delivered\n  implementation: {\n    agent: codeReviewAgent,\n    workflow: codeReviewWorkflow,\n    escalation: { to: 'senior-engineers', when: 'complexity > 8' },\n  },\n\n  // Service guarantees\n  sla: sla({\n    responseTime: '< 30 minutes',\n    accuracy: '> 95%',\n    availability: '99.9%',\n  }),\n\n  // Pricing model\n  pricing: pricing({\n    model: 'per-review',\n    base: 5.00,\n    modifiers: [\n      { when: 'lines > 500', multiply: 1.5 },\n      { when: 'reviewType = security', multiply: 2.0 },\n    ],\n  }),\n})\n```\n\n## Service Types\n\n### Analysis Services\n\nTransform data into insights:\n\n```typescript\nconst competitorAnalysis = service({\n  name: 'competitor-analysis',\n\n  input: z.object({\n    company: z.string(),\n    aspects: z.array(z.enum(['pricing', 'features', 'positioning', 'market'])),\n  }),\n\n  output: z.object({\n    report: z.string(),\n    keyFindings: z.array(z.string()),\n    recommendations: z.array(z.string()),\n    sources: z.array(z.string()),\n  }),\n\n  implementation: {\n    agent: researchAgent,\n    tools: [webSearch, documentAnalysis, dataExtraction],\n    humanReview: { when: 'report.confidence < 0.8' },\n  },\n})\n```\n\n### Creation Services\n\nGenerate content and artifacts:\n\n```typescript\nconst blogWritingService = service({\n  name: 'blog-writing',\n\n  input: z.object({\n    topic: z.string(),\n    tone: z.enum(['professional', 'casual', 'technical']),\n    length: z.enum(['short', 'medium', 'long']),\n    seoKeywords: z.array(z.string()).optional(),\n  }),\n\n  output: z.object({\n    title: z.string(),\n    content: z.string(),\n    excerpt: z.string(),\n    suggestedImages: z.array(z.string()),\n  }),\n\n  implementation: {\n    workflow: contentCreationWorkflow,\n    stages: ['research', 'outline', 'draft', 'edit', 'polish'],\n    humanInLoop: { stage: 'edit', optional: true },\n  },\n})\n```\n\n### Processing Services\n\nHandle operational tasks:\n\n```typescript\nconst invoiceProcessing = service({\n  name: 'invoice-processing',\n\n  input: z.object({\n    document: z.string(), // URL or base64\n    format: z.enum(['pdf', 'image', 'email']),\n  }),\n\n  output: z.object({\n    vendor: z.string(),\n    amount: z.number(),\n    currency: z.string(),\n    lineItems: z.array(lineItemSchema),\n    dueDate: z.date(),\n    confidence: z.number(),\n  }),\n\n  implementation: {\n    function: extractInvoiceData,\n    validation: validateExtraction,\n    humanReview: { when: 'confidence < 0.9' },\n  },\n})\n```\n\n## Quality Guarantees\n\nServices come with explicit quality commitments:\n\n```typescript\nconst qualityService = service({\n  name: 'quality-service',\n\n  quality: {\n    // Accuracy metrics\n    accuracy: {\n      target: 0.95,\n      measurement: 'human-evaluated-sample',\n      sampleRate: 0.1,\n    },\n\n    // Consistency\n    consistency: {\n      acrossInputs: 'high',\n      overTime: 'stable',\n    },\n\n    // Handling edge cases\n    edgeCases: {\n      detection: 'automatic',\n      handling: 'escalate-to-human',\n    },\n  },\n\n  feedback: {\n    collectFrom: ['customer-ratings', 'outcome-tracking'],\n    improveFrom: 'continuous-learning',\n  },\n})\n```\n\n## Human Escalation\n\nServices seamlessly escalate to humans when needed:\n\n```typescript\nconst hybridService = service({\n  name: 'customer-support',\n\n  escalation: {\n    // Automatic escalation triggers\n    triggers: [\n      { condition: 'sentiment < -0.5', priority: 'high' },\n      { condition: 'topic = refund AND amount > 1000', priority: 'medium' },\n      { condition: 'attempts > 3', priority: 'low' },\n    ],\n\n    // Where to escalate\n    destinations: [\n      { tier: 1, team: 'support-team', sla: '5m' },\n      { tier: 2, team: 'senior-support', sla: '15m' },\n      { tier: 3, team: 'support-managers', sla: '1h' },\n    ],\n\n    // Context passed to human\n    handoff: {\n      include: ['conversation-history', 'customer-profile', 'ai-analysis'],\n      suggestActions: true,\n    },\n  },\n})\n```\n\n## Service Consumption\n\n```typescript\n// Direct invocation\nconst review = await codeReviewService.invoke({\n  repository: 'org/repo',\n  pullRequest: 123,\n  reviewType: 'general',\n})\n\n// Async with callback\nconst job = await codeReviewService.submit({\n  repository: 'org/repo',\n  pullRequest: 123,\n  reviewType: 'security',\n}, {\n  callback: 'https://my-app.com/webhooks/review-complete',\n})\n\n// Batch processing\nconst results = await codeReviewService.batch([\n  { repository: 'org/repo1', pullRequest: 1, reviewType: 'general' },\n  { repository: 'org/repo2', pullRequest: 2, reviewType: 'general' },\n  { repository: 'org/repo3', pullRequest: 3, reviewType: 'general' },\n])\n```\n\n## Continuous Improvement\n\nServices learn and improve over time:\n\n```typescript\nconst improvingService = service({\n  name: 'improving-service',\n\n  learning: {\n    // Learn from corrections\n    fromCorrections: {\n      collectVia: 'feedback-api',\n      applyAs: 'fine-tuning',\n      frequency: 'weekly',\n    },\n\n    // Learn from outcomes\n    fromOutcomes: {\n      track: ['customer-satisfaction', 'task-success'],\n      optimize: 'satisfaction',\n    },\n\n    // A/B testing\n    experiments: {\n      enabled: true,\n      variants: ['baseline', 'new-prompt', 'different-model'],\n      metric: 'accuracy',\n    },\n  },\n})\n```\n\n## Pricing Models\n\n```typescript\n// Per-unit pricing\nconst perUnit = pricing({\n  model: 'per-unit',\n  unitPrice: 0.10,\n  unit: 'document-processed',\n})\n\n// Tiered pricing\nconst tiered = pricing({\n  model: 'tiered',\n  tiers: [\n    { upTo: 1000, unitPrice: 0.10 },\n    { upTo: 10000, unitPrice: 0.08 },\n    { upTo: Infinity, unitPrice: 0.05 },\n  ],\n})\n\n// Subscription pricing\nconst subscription = pricing({\n  model: 'subscription',\n  plans: [\n    { name: 'starter', monthly: 99, includes: 1000 },\n    { name: 'growth', monthly: 299, includes: 5000 },\n    { name: 'enterprise', custom: true },\n  ],\n})\n```\n\n\n# Metrics\n\nURL: https://primitives.org.ai/service/metrics\n\n> Track service performance\n\n\n\n# Metrics\n\nTrack service health and performance with KPIs and OKRs.\n\n## KPIs\n\nDefine Key Performance Indicators for your service:\n\n```typescript\nimport { Service, KPI } from 'services-as-software'\n\nconst service = Service({\n  name: 'translation-service',\n  kpis: [\n    {\n      id: 'daily-requests',\n      name: 'Daily Requests',\n      calculate: async () => {\n        return await db.requests.countToday()\n      },\n      target: 10000,\n    },\n    {\n      id: 'avg-response-time',\n      name: 'Average Response Time',\n      calculate: async () => {\n        return await metrics.getAvgResponseTime()\n      },\n      target: 500,  // 500ms\n      unit: 'ms',\n    },\n    {\n      id: 'error-rate',\n      name: 'Error Rate',\n      calculate: async () => {\n        const errors = await metrics.getErrorCount()\n        const total = await metrics.getTotalRequests()\n        return (errors / total) * 100\n      },\n      target: 1,  // Less than 1%\n      unit: '%',\n    },\n  ],\n})\n```\n\n### KPI Helper\n\n```typescript\nimport { KPI } from 'services-as-software'\n\nconst requestsKPI = KPI({\n  id: 'requests',\n  name: 'Total Requests',\n  calculate: async () => db.requests.count(),\n  target: 100000,\n  period: 'monthly',\n})\n```\n\n### KPI Properties\n\n| Property    | Description                         |\n| ----------- | ----------------------------------- |\n| `id`        | Unique identifier                   |\n| `name`      | Display name                        |\n| `calculate` | Async function to get current value |\n| `target`    | Target value                        |\n| `unit`      | Unit of measurement                 |\n| `period`    | Measurement period                  |\n\n## OKRs\n\nDefine Objectives and Key Results:\n\n```typescript\nimport { Service, OKR } from 'services-as-software'\n\nconst service = Service({\n  name: 'ai-service',\n  okrs: [\n    {\n      objective: 'Improve Service Reliability',\n      keyResults: [\n        {\n          description: 'Achieve 99.9% uptime',\n          metric: 'uptime',\n          target: 99.9,\n          current: 99.5,\n        },\n        {\n          description: 'Reduce p99 latency to under 200ms',\n          metric: 'p99_latency',\n          target: 200,\n          current: 350,\n        },\n        {\n          description: 'Reduce error rate to under 0.1%',\n          metric: 'error_rate',\n          target: 0.1,\n          current: 0.5,\n        },\n      ],\n      period: 'Q1 2024',\n    },\n  ],\n})\n```\n\n### OKR Helper\n\n```typescript\nimport { OKR } from 'services-as-software'\n\nconst reliabilityOKR = OKR({\n  objective: 'World-class reliability',\n  period: 'Q1 2024',\n  owner: 'Engineering',\n  keyResults: [\n    {\n      description: 'Achieve 99.99% uptime',\n      target: 99.99,\n      current: 99.9,\n    },\n  ],\n})\n```\n\n## Accessing Metrics\n\n### kpis()\n\nGet current KPI values:\n\n```typescript\nimport { kpis } from 'services-as-software'\n\nconst metrics = await kpis(service)\n// [\n//   { id: 'daily-requests', name: 'Daily Requests', value: 8500, target: 10000, achievement: 85 },\n//   { id: 'avg-response-time', name: 'Average Response Time', value: 450, target: 500, achievement: 110 },\n// ]\n```\n\n### okrs()\n\nGet current OKR progress:\n\n```typescript\nimport { okrs } from 'services-as-software'\n\nconst progress = await okrs(service)\n// [\n//   {\n//     objective: 'Improve Service Reliability',\n//     progress: 75,\n//     keyResults: [\n//       { description: 'Achieve 99.9% uptime', progress: 99.5 },\n//       ...\n//     ]\n//   }\n// ]\n```\n\n### entitlements()\n\nCheck user entitlements:\n\n```typescript\nimport { entitlements } from 'services-as-software'\n\nconst userEntitlements = await entitlements(userId)\n// ['api-access', 'premium-features', 'priority-support']\n```\n\n## Common KPIs\n\n### Response Time\n\n```typescript\nKPI({\n  id: 'response-time',\n  name: 'Average Response Time',\n  calculate: async () => {\n    const times = await metrics.getResponseTimes()\n    return times.reduce((a, b) => a + b, 0) / times.length\n  },\n  target: 100,\n  unit: 'ms',\n})\n```\n\n### Throughput\n\n```typescript\nKPI({\n  id: 'throughput',\n  name: 'Requests per Second',\n  calculate: async () => {\n    return await metrics.getRPS()\n  },\n  target: 1000,\n  unit: 'rps',\n})\n```\n\n### Error Rate\n\n```typescript\nKPI({\n  id: 'error-rate',\n  name: 'Error Rate',\n  calculate: async () => {\n    const errors = await metrics.getErrors()\n    const total = await metrics.getTotal()\n    return (errors / total) * 100\n  },\n  target: 0.1,\n  unit: '%',\n})\n```\n\n### Availability\n\n```typescript\nKPI({\n  id: 'availability',\n  name: 'Service Availability',\n  calculate: async () => {\n    const uptime = await health.getUptime()\n    const total = await health.getTotalTime()\n    return (uptime / total) * 100\n  },\n  target: 99.9,\n  unit: '%',\n})\n```\n\n## Dashboards\n\nBuild dashboards from metrics:\n\n```typescript\nimport { kpis } from 'services-as-software'\n\nasync function getDashboardData() {\n  const metrics = await kpis(service)\n\n  return {\n    summary: {\n      healthy: metrics.filter(k => k.achievement >= 100).length,\n      atRisk: metrics.filter(k => k.achievement < 100 && k.achievement >= 80).length,\n      critical: metrics.filter(k => k.achievement < 80).length,\n    },\n    metrics: metrics.map(k => ({\n      name: k.name,\n      value: k.value,\n      target: k.target,\n      achievement: k.achievement,\n      status: k.achievement >= 100 ? 'healthy' : k.achievement >= 80 ? 'warning' : 'critical',\n    })),\n  }\n}\n```\n\n## Alerts\n\nSet up alerts based on metrics:\n\n```typescript\nimport { kpis, notify } from 'services-as-software'\n\nasync function checkMetrics() {\n  const metrics = await kpis(service)\n\n  for (const metric of metrics) {\n    if (metric.achievement < 80) {\n      await notify({\n        channel: 'slack',\n        message: `Alert: ${metric.name} is at ${metric.achievement}% of target`,\n        webhook: process.env.SLACK_ALERTS_WEBHOOK,\n      })\n    }\n  }\n}\n\n// Check every 5 minutes\nevery('5m', checkMetrics)\n```\n\n## Type Definition\n\n```typescript\ninterface KPIDefinition {\n  id: string\n  name: string\n  calculate: () => Promise<number>\n  target: number\n  unit?: string\n  period?: 'daily' | 'weekly' | 'monthly' | 'quarterly'\n}\n\ninterface OKRDefinition {\n  objective: string\n  keyResults: {\n    description: string\n    metric?: string\n    target: number\n    current?: number\n  }[]\n  period?: string\n  owner?: string\n}\n```\n\n\n# Operations\n\nURL: https://primitives.org.ai/service/operations\n\n> Service operation helpers\n\n\n\n# Operations\n\nServices-as-software provides helper functions for common service operations.\n\n## Available Helpers\n\n| Helper        | Description        |\n| ------------- | ------------------ |\n| `ask()`       | Ask a question     |\n| `deliver()`   | Deliver results    |\n| `do()`        | Execute a task     |\n| `every()`     | Scheduled tasks    |\n| `generate()`  | Generate content   |\n| `is()`        | Validation         |\n| `notify()`    | Send notifications |\n| `on()`        | Event handlers     |\n| `order()`     | Place orders       |\n| `queue()`     | Queue management   |\n| `quote()`     | Request quotes     |\n| `subscribe()` | Subscriptions      |\n\n## ask()\n\nAsk a question and get an answer:\n\n```typescript\nimport { ask } from 'services-as-software'\n\nconst answer = await ask('What is the capital of France?')\n// \"Paris\"\n\nconst answer = await ask({\n  question: 'What are the top 3 programming languages?',\n  context: 'For web development in 2024',\n})\n// [\"JavaScript\", \"TypeScript\", \"Python\"]\n```\n\n## deliver()\n\nDeliver results to a destination:\n\n```typescript\nimport { deliver } from 'services-as-software'\n\nawait deliver({\n  to: 'webhook',\n  url: 'https://example.com/webhook',\n  payload: { result: 'data' },\n})\n\nawait deliver({\n  to: 'email',\n  address: 'user@example.com',\n  subject: 'Your report is ready',\n  body: reportContent,\n})\n```\n\n## do()\n\nExecute a task:\n\n```typescript\nimport { do as execute } from 'services-as-software'\n\nconst result = await execute('translate', {\n  text: 'Hello',\n  to: 'es',\n})\n\nconst result = await execute({\n  task: 'analyze-sentiment',\n  input: { text: 'I love this product!' },\n})\n```\n\n## every()\n\nSchedule recurring tasks:\n\n```typescript\nimport { every } from 'services-as-software'\n\n// Run every hour\nevery('1h', async () => {\n  await generateReport()\n})\n\n// Run daily at 9 AM\nevery('0 9 * * *', async () => {\n  await sendDailySummary()\n})\n\n// Run every 30 minutes\nevery('30m', async () => {\n  await checkHealth()\n})\n```\n\n### Schedule Formats\n\n| Format        | Description      |\n| ------------- | ---------------- |\n| `'30s'`       | Every 30 seconds |\n| `'5m'`        | Every 5 minutes  |\n| `'1h'`        | Every hour       |\n| `'1d'`        | Every day        |\n| `'* * * * *'` | Cron syntax      |\n\n## generate()\n\nGenerate content:\n\n```typescript\nimport { generate } from 'services-as-software'\n\nconst content = await generate({\n  type: 'blog-post',\n  topic: 'AI in healthcare',\n  length: 'medium',\n  tone: 'professional',\n})\n\nconst image = await generate({\n  type: 'image',\n  prompt: 'A futuristic city at sunset',\n  style: 'photorealistic',\n})\n```\n\n## is()\n\nValidate or check types:\n\n```typescript\nimport { is } from 'services-as-software'\n\nconst valid = await is(email, 'valid-email')\n// true\n\nconst spam = await is(content, 'spam')\n// false\n\nconst appropriate = await is(text, 'appropriate-content')\n// true\n```\n\n## notify()\n\nSend notifications:\n\n```typescript\nimport { notify } from 'services-as-software'\n\nawait notify({\n  channel: 'slack',\n  message: 'Deployment complete!',\n  webhook: process.env.SLACK_WEBHOOK,\n})\n\nawait notify({\n  channel: 'email',\n  to: 'team@example.com',\n  subject: 'Alert: High CPU Usage',\n  body: 'Server load exceeded threshold.',\n})\n\nawait notify({\n  channel: 'sms',\n  to: '+1234567890',\n  message: 'Your order has shipped!',\n})\n```\n\n## on()\n\nRegister event handlers:\n\n```typescript\nimport { on } from 'services-as-software'\n\non('order.created', async (event) => {\n  await sendConfirmationEmail(event.order)\n  await updateInventory(event.order.items)\n})\n\non('payment.succeeded', async (event) => {\n  await fulfillOrder(event.orderId)\n})\n\non('user.signup', async (event) => {\n  await sendWelcomeEmail(event.user)\n  await createTrialSubscription(event.user)\n})\n```\n\n## order()\n\nPlace orders:\n\n```typescript\nimport { order } from 'services-as-software'\n\nconst confirmation = await order({\n  service: 'translation',\n  input: {\n    document: 'path/to/doc.pdf',\n    targetLanguages: ['es', 'fr', 'de'],\n  },\n  delivery: 'express',\n})\n```\n\n## queue()\n\nManage job queues:\n\n```typescript\nimport { queue } from 'services-as-software'\n\n// Add to queue\nconst job = await queue.add('process-video', {\n  videoUrl: 'https://example.com/video.mp4',\n  format: 'mp4',\n})\n\n// Check status\nconst status = await queue.status(job.id)\n// { status: 'processing', progress: 45 }\n\n// Get result\nconst result = await queue.result(job.id)\n```\n\n## quote()\n\nRequest a quote:\n\n```typescript\nimport { quote } from 'services-as-software'\n\nconst estimate = await quote({\n  service: 'translation',\n  input: {\n    wordCount: 5000,\n    sourceLanguage: 'en',\n    targetLanguage: 'ja',\n  },\n})\n// { price: 150, currency: 'USD', turnaround: '24h' }\n```\n\n## subscribe()\n\nManage subscriptions:\n\n```typescript\nimport { subscribe } from 'services-as-software'\n\n// Subscribe to a plan\nconst subscription = await subscribe({\n  plan: 'pro',\n  customer: 'cus_123',\n})\n\n// Subscribe to events\nconst unsubscribe = subscribe.events('order.*', (event) => {\n  console.log('Order event:', event)\n})\n\n// Later: unsubscribe\nunsubscribe()\n```\n\n## Combining Helpers\n\n```typescript\nimport { on, notify, queue, generate } from 'services-as-software'\n\non('document.uploaded', async (event) => {\n  // Queue processing\n  const job = await queue.add('process-document', {\n    documentId: event.documentId,\n  })\n\n  // Generate summary\n  const summary = await generate({\n    type: 'summary',\n    source: event.documentUrl,\n    length: 'short',\n  })\n\n  // Notify user\n  await notify({\n    channel: 'email',\n    to: event.user.email,\n    subject: 'Document processed',\n    body: `Summary: ${summary}`,\n  })\n})\n```\n\n\n# Plans\n\nURL: https://primitives.org.ai/service/plans\n\n> Create subscription plans\n\n\n\n# Plans\n\nDefine subscription plans with features, entitlements, and pricing tiers.\n\n## Basic Plan\n\n```typescript\nimport { Service, Plan } from 'services-as-software'\n\nconst service = Service({\n  name: 'my-service',\n  plans: [\n    {\n      id: 'pro',\n      name: 'Pro Plan',\n      pricing: {\n        model: 'subscription',\n        basePrice: 49.99,\n        currency: 'USD',\n        interval: 'monthly',\n      },\n      features: ['Unlimited API calls', '24/7 support'],\n    },\n  ],\n})\n```\n\n## Plan Helper\n\nUse the `Plan()` helper for better ergonomics:\n\n```typescript\nimport { Service, Plan } from 'services-as-software'\n\nconst service = Service({\n  name: 'my-service',\n  plans: [\n    Plan({\n      id: 'starter',\n      name: 'Starter',\n      pricing: {\n        model: 'subscription',\n        basePrice: 29,\n        currency: 'USD',\n        interval: 'monthly',\n      },\n      entitlements: ['api-access', 'basic-support'],\n      features: [\n        '1,000 requests/month',\n        'Email support',\n        'Basic analytics',\n      ],\n    }),\n  ],\n})\n```\n\n## Plan Properties\n\n| Property       | Description              |\n| -------------- | ------------------------ |\n| `id`           | Unique identifier        |\n| `name`         | Display name             |\n| `pricing`      | Pricing configuration    |\n| `entitlements` | Access permissions       |\n| `features`     | Feature list for display |\n| `limits`       | Usage limits             |\n\n## Entitlements\n\nControl access to features:\n\n```typescript\nPlan({\n  id: 'pro',\n  name: 'Pro',\n  entitlements: [\n    'api-access',\n    'webhook-access',\n    'priority-support',\n    'advanced-analytics',\n    'custom-integrations',\n  ],\n})\n```\n\nCheck entitlements at runtime:\n\n```typescript\nPOST({\n  name: 'advanced-feature',\n  handler: async (input, context) => {\n    if (!context.entitlements.includes('advanced-analytics')) {\n      throw new Error('Upgrade to Pro for this feature')\n    }\n    // Feature logic\n  },\n})\n```\n\n## Usage Limits\n\nSet plan limits:\n\n```typescript\nPlan({\n  id: 'starter',\n  name: 'Starter',\n  limits: {\n    requestsPerMonth: 1000,\n    storageGB: 5,\n    teamMembers: 3,\n    projects: 10,\n  },\n})\n```\n\n## Complete Example\n\n```typescript\nimport { Service, Plan } from 'services-as-software'\n\nconst analyticService = Service({\n  name: 'analytics-service',\n  version: '1.0.0',\n\n  plans: [\n    Plan({\n      id: 'free',\n      name: 'Free',\n      pricing: { model: 'free' },\n      entitlements: ['basic-analytics'],\n      features: [\n        '100 events/day',\n        '7 day retention',\n        'Basic reports',\n      ],\n      limits: {\n        eventsPerDay: 100,\n        retentionDays: 7,\n        dashboards: 1,\n      },\n    }),\n\n    Plan({\n      id: 'startup',\n      name: 'Startup',\n      pricing: {\n        model: 'subscription',\n        basePrice: 49,\n        currency: 'USD',\n        interval: 'monthly',\n      },\n      entitlements: ['basic-analytics', 'custom-events', 'export'],\n      features: [\n        '10,000 events/day',\n        '30 day retention',\n        'Custom events',\n        'CSV export',\n        'Email reports',\n      ],\n      limits: {\n        eventsPerDay: 10000,\n        retentionDays: 30,\n        dashboards: 5,\n        teamMembers: 5,\n      },\n    }),\n\n    Plan({\n      id: 'growth',\n      name: 'Growth',\n      pricing: {\n        model: 'subscription',\n        basePrice: 199,\n        currency: 'USD',\n        interval: 'monthly',\n      },\n      entitlements: ['basic-analytics', 'custom-events', 'export', 'api-access', 'webhooks'],\n      features: [\n        '100,000 events/day',\n        '90 day retention',\n        'API access',\n        'Webhooks',\n        'Priority support',\n        'Custom dashboards',\n      ],\n      limits: {\n        eventsPerDay: 100000,\n        retentionDays: 90,\n        dashboards: 20,\n        teamMembers: 20,\n        apiRequestsPerDay: 10000,\n      },\n    }),\n\n    Plan({\n      id: 'enterprise',\n      name: 'Enterprise',\n      pricing: {\n        model: 'custom',\n        contactUrl: 'https://analytics.example.com/enterprise',\n      },\n      entitlements: ['*'],  // All entitlements\n      features: [\n        'Unlimited events',\n        'Unlimited retention',\n        'Dedicated support',\n        'SLA guarantee',\n        'On-premise option',\n        'Custom integrations',\n      ],\n      limits: {\n        eventsPerDay: Infinity,\n        retentionDays: Infinity,\n        dashboards: Infinity,\n        teamMembers: Infinity,\n      },\n    }),\n  ],\n})\n```\n\n## Annual Discounts\n\nOffer yearly pricing:\n\n```typescript\nPlan({\n  id: 'pro-monthly',\n  name: 'Pro (Monthly)',\n  pricing: {\n    model: 'subscription',\n    basePrice: 99,\n    currency: 'USD',\n    interval: 'monthly',\n  },\n}),\n\nPlan({\n  id: 'pro-yearly',\n  name: 'Pro (Yearly)',\n  pricing: {\n    model: 'subscription',\n    basePrice: 948,  // $79/month equivalent (20% off)\n    currency: 'USD',\n    interval: 'yearly',\n  },\n})\n```\n\n## Trial Periods\n\nAdd free trials:\n\n```typescript\nPlan({\n  id: 'pro',\n  name: 'Pro',\n  pricing: {\n    model: 'subscription',\n    basePrice: 99,\n    currency: 'USD',\n    interval: 'monthly',\n  },\n  trial: {\n    days: 14,\n    requiresCard: false,\n  },\n})\n```\n\n## Type Definition\n\n```typescript\ninterface PlanDefinition {\n  id: string\n  name: string\n  pricing: PricingDefinition\n  entitlements?: string[]\n  features?: string[]\n  limits?: Record<string, number>\n  trial?: {\n    days: number\n    requiresCard?: boolean\n  }\n  metadata?: Record<string, unknown>\n}\n```\n\n\n# Pricing\n\nURL: https://primitives.org.ai/service/pricing\n\n> Configure service pricing\n\n\n\n# Pricing\n\nServices-as-software supports multiple pricing models to match your business needs.\n\n## Pricing Models\n\n| Model          | Description        |\n| -------------- | ------------------ |\n| `free`         | No cost            |\n| `fixed`        | One-time payment   |\n| `per-use`      | Pay per request    |\n| `subscription` | Recurring payment  |\n| `tiered`       | Volume-based tiers |\n| `custom`       | Custom pricing     |\n\n## Free\n\nNo payment required:\n\n```typescript\nconst service = Service({\n  name: 'free-service',\n  pricing: {\n    model: 'free',\n  },\n})\n```\n\n## Fixed Price\n\nOne-time payment:\n\n```typescript\nconst service = Service({\n  name: 'fixed-service',\n  pricing: {\n    model: 'fixed',\n    price: 99.00,\n    currency: 'USD',\n  },\n})\n```\n\n## Per-Use\n\nPay per request or unit:\n\n```typescript\nconst service = Service({\n  name: 'usage-service',\n  pricing: {\n    model: 'per-use',\n    pricePerUnit: 0.01,   // $0.01 per request\n    currency: 'USD',\n  },\n})\n```\n\n### Usage with Multipliers\n\nDifferent rates for different operations:\n\n```typescript\nconst service = Service({\n  name: 'ai-service',\n  pricing: {\n    model: 'per-use',\n    pricePerUnit: 0.01,\n    currency: 'USD',\n    multipliers: {\n      'basic-query': 1,      // $0.01\n      'advanced-query': 5,   // $0.05\n      'batch-process': 10,   // $0.10\n    },\n  },\n})\n```\n\n## Subscription\n\nRecurring payments:\n\n```typescript\nconst service = Service({\n  name: 'subscription-service',\n  pricing: {\n    model: 'subscription',\n    basePrice: 49.99,\n    currency: 'USD',\n    interval: 'monthly',  // or 'yearly'\n  },\n})\n```\n\n### With Usage Limits\n\n```typescript\nconst service = Service({\n  name: 'limited-subscription',\n  pricing: {\n    model: 'subscription',\n    basePrice: 99,\n    currency: 'USD',\n    interval: 'monthly',\n    includes: 1000,              // 1000 requests included\n    overagePrice: 0.05,          // $0.05 per additional request\n  },\n})\n```\n\n## Tiered Pricing\n\nVolume-based pricing:\n\n```typescript\nconst service = Service({\n  name: 'tiered-service',\n  pricing: {\n    model: 'tiered',\n    currency: 'USD',\n    tiers: [\n      { upTo: 1000, pricePerUnit: 0.10 },    // First 1000: $0.10\n      { upTo: 10000, pricePerUnit: 0.08 },   // 1001-10000: $0.08\n      { upTo: 100000, pricePerUnit: 0.05 },  // 10001-100000: $0.05\n      { upTo: Infinity, pricePerUnit: 0.02 }, // 100001+: $0.02\n    ],\n  },\n})\n```\n\n## Custom Pricing\n\nFor enterprise or special cases:\n\n```typescript\nconst service = Service({\n  name: 'enterprise-service',\n  pricing: {\n    model: 'custom',\n    contactUrl: 'https://example.com/contact-sales',\n    description: 'Contact us for enterprise pricing',\n  },\n})\n```\n\n## Currency Support\n\nSupported currencies:\n\n```typescript\npricing: {\n  model: 'subscription',\n  basePrice: 49.99,\n  currency: 'USD',  // or 'EUR', 'GBP', 'JPY', etc.\n}\n```\n\n| Currency          | Code  |\n| ----------------- | ----- |\n| US Dollar         | `USD` |\n| Euro              | `EUR` |\n| British Pound     | `GBP` |\n| Japanese Yen      | `JPY` |\n| Canadian Dollar   | `CAD` |\n| Australian Dollar | `AUD` |\n\n## Billing Intervals\n\nFor subscriptions:\n\n| Interval    | Description      |\n| ----------- | ---------------- |\n| `monthly`   | Billed monthly   |\n| `yearly`    | Billed annually  |\n| `quarterly` | Billed quarterly |\n\n## Example: SaaS Pricing\n\n```typescript\nconst saasService = Service({\n  name: 'saas-platform',\n  version: '1.0.0',\n\n  // Default pricing\n  pricing: {\n    model: 'subscription',\n    basePrice: 0,\n    currency: 'USD',\n    interval: 'monthly',\n  },\n\n  // Subscription plans\n  plans: [\n    {\n      id: 'free',\n      name: 'Free',\n      pricing: { model: 'free' },\n      features: ['100 requests/month', 'Community support'],\n    },\n    {\n      id: 'starter',\n      name: 'Starter',\n      pricing: {\n        model: 'subscription',\n        basePrice: 29,\n        currency: 'USD',\n        interval: 'monthly',\n      },\n      features: ['1,000 requests/month', 'Email support', 'API access'],\n    },\n    {\n      id: 'pro',\n      name: 'Pro',\n      pricing: {\n        model: 'subscription',\n        basePrice: 99,\n        currency: 'USD',\n        interval: 'monthly',\n        includes: 10000,\n        overagePrice: 0.01,\n      },\n      features: ['10,000 requests/month', 'Priority support', 'Custom integrations'],\n    },\n    {\n      id: 'enterprise',\n      name: 'Enterprise',\n      pricing: {\n        model: 'custom',\n        contactUrl: 'https://example.com/enterprise',\n      },\n      features: ['Unlimited requests', 'Dedicated support', 'SLA guarantee', 'Custom deployment'],\n    },\n  ],\n})\n```\n\n## Type Definition\n\n```typescript\ninterface PricingDefinition {\n  model: 'free' | 'fixed' | 'per-use' | 'subscription' | 'tiered' | 'custom'\n  price?: number\n  basePrice?: number\n  pricePerUnit?: number\n  currency?: string\n  interval?: 'monthly' | 'yearly' | 'quarterly'\n  includes?: number\n  overagePrice?: number\n  multipliers?: Record<string, number>\n  tiers?: Array<{\n    upTo: number\n    pricePerUnit: number\n  }>\n  contactUrl?: string\n  description?: string\n}\n```\n\n\n# Providers\n\nURL: https://primitives.org.ai/service/providers\n\n> Connect to cloud providers\n\n\n\n# Providers\n\nUse providers to connect to services across different cloud platforms.\n\n## Basic Usage\n\n```typescript\nimport { providers } from 'services-as-software'\n\nconst aws = providers.aws({\n  accessKeyId: 'key',\n  secretAccessKey: 'secret',\n  region: 'us-east-1',\n})\n\nconst translate = aws.service('translate')\nconst result = await translate.do('translate', { text: 'Hello', to: 'es' })\n```\n\n## Built-in Providers\n\n### AWS\n\n```typescript\nconst aws = providers.aws({\n  accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n  region: 'us-east-1',\n})\n\n// Use AWS services\nconst translate = aws.service('translate')\nconst comprehend = aws.service('comprehend')\nconst textract = aws.service('textract')\n```\n\n### Google Cloud\n\n```typescript\nconst gcp = providers.gcp({\n  projectId: process.env.GCP_PROJECT_ID,\n  credentials: JSON.parse(process.env.GCP_CREDENTIALS),\n})\n\n// Use GCP services\nconst translate = gcp.service('translate')\nconst vision = gcp.service('vision')\nconst speech = gcp.service('speech')\n```\n\n### Azure\n\n```typescript\nconst azure = providers.azure({\n  subscriptionId: process.env.AZURE_SUBSCRIPTION_ID,\n  tenantId: process.env.AZURE_TENANT_ID,\n  clientId: process.env.AZURE_CLIENT_ID,\n  clientSecret: process.env.AZURE_CLIENT_SECRET,\n})\n\n// Use Azure services\nconst cognitive = azure.service('cognitive')\nconst translator = azure.service('translator')\n```\n\n## Provider Interface\n\nAll providers share a common interface:\n\n```typescript\ninterface Provider {\n  service(name: string): ServiceClient\n  list(): string[]\n  health(): Promise<HealthStatus>\n}\n```\n\n### service(name)\n\nGet a client for a specific service:\n\n```typescript\nconst translate = provider.service('translate')\n```\n\n### list()\n\nList available services:\n\n```typescript\nconst services = provider.list()\n// ['translate', 'comprehend', 'textract', ...]\n```\n\n### health()\n\nCheck provider health:\n\n```typescript\nconst status = await provider.health()\n// { status: 'healthy', latency: 45 }\n```\n\n## Custom Providers\n\nCreate custom providers:\n\n```typescript\nimport { Provider } from 'services-as-software'\n\nconst myProvider = Provider({\n  name: 'my-provider',\n  baseUrl: 'https://api.myservice.com',\n  auth: {\n    type: 'api-key',\n    credentials: {\n      apiKey: process.env.MY_API_KEY,\n    },\n  },\n  services: {\n    translate: '/v1/translate',\n    summarize: '/v1/summarize',\n    analyze: '/v1/analyze',\n  },\n})\n\n// Use custom provider\nconst translate = myProvider.service('translate')\nconst result = await translate.do('translate', { text: 'Hello' })\n```\n\n## Multi-Provider Example\n\nUse multiple providers together:\n\n```typescript\nimport { providers } from 'services-as-software'\n\n// Configure providers\nconst aws = providers.aws({ /* config */ })\nconst gcp = providers.gcp({ /* config */ })\n\n// Translation service that falls back between providers\nasync function translate(text: string, to: string) {\n  try {\n    // Try AWS first\n    const awsTranslate = aws.service('translate')\n    return await awsTranslate.do('translate', { text, to })\n  } catch (error) {\n    // Fall back to GCP\n    const gcpTranslate = gcp.service('translate')\n    return await gcpTranslate.do('translate', { text, to })\n  }\n}\n```\n\n## Provider Configuration\n\n### Connection Pooling\n\n```typescript\nconst aws = providers.aws({\n  accessKeyId: 'key',\n  secretAccessKey: 'secret',\n  region: 'us-east-1',\n  connectionPool: {\n    maxConnections: 10,\n    keepAlive: true,\n  },\n})\n```\n\n### Retry Policy\n\n```typescript\nconst gcp = providers.gcp({\n  projectId: 'project-id',\n  credentials: { /* ... */ },\n  retry: {\n    attempts: 3,\n    delay: 1000,\n    backoff: 'exponential',\n  },\n})\n```\n\n### Timeout Settings\n\n```typescript\nconst azure = providers.azure({\n  subscriptionId: 'sub-id',\n  timeout: 30000,  // 30 seconds\n})\n```\n\n## Environment Variables\n\nRecommended environment setup:\n\n```bash\n# AWS\nAWS_ACCESS_KEY_ID=your-key\nAWS_SECRET_ACCESS_KEY=your-secret\nAWS_REGION=us-east-1\n\n# GCP\nGCP_PROJECT_ID=your-project\nGCP_CREDENTIALS='{\"type\":\"service_account\",...}'\n\n# Azure\nAZURE_SUBSCRIPTION_ID=your-sub\nAZURE_TENANT_ID=your-tenant\nAZURE_CLIENT_ID=your-client\nAZURE_CLIENT_SECRET=your-secret\n```\n\n## Type Definition\n\n```typescript\ninterface ProviderConfig {\n  name?: string\n  baseUrl?: string\n  auth?: AuthConfig\n  services?: Record<string, string>\n  connectionPool?: {\n    maxConnections?: number\n    keepAlive?: boolean\n  }\n  retry?: RetryConfig\n  timeout?: number\n}\n\ninterface AWSConfig {\n  accessKeyId: string\n  secretAccessKey: string\n  region: string\n  sessionToken?: string\n}\n\ninterface GCPConfig {\n  projectId: string\n  credentials: object\n}\n\ninterface AzureConfig {\n  subscriptionId: string\n  tenantId: string\n  clientId: string\n  clientSecret: string\n}\n```\n"}