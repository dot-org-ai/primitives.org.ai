/**
 * RPC Types and Wrappers
 *
 * Core abstractions for RPC-based actions and events with proper
 * Input/Output type distinctions and context handling.
 *
 * @module core/rpc
 */

/**
 * RPC Promise type - a promise that supports pipelining.
 * When rpc.do is available, this will be the actual RPCPromise type.
 * Otherwise, it falls back to a standard Promise.
 */
export type RPCPromise<T> = Promise<T>

/**
 * Execution context passed to event handlers and actions.
 * Contains the RPC proxy for making additional calls.
 *
 * @example
 * ```ts
 * const handler: EventHandler<ContactCreated> = (event, ctx) => {
 *   // Access RPC proxy for chained calls
 *   const company = await ctx.$.companies.get({ id: event.data.companyId })
 *
 *   // Access current user/session
 *   console.log(ctx.user?.id)
 * }
 * ```
 */
export interface ExecutionContext<TProxy = unknown> {
  /** RPC proxy for making additional calls */
  $: TProxy

  /** Current authenticated user (if any) */
  user?: {
    id: string
    email?: string
    name?: string
    roles?: string[]
  }

  /** Request metadata */
  request?: {
    id: string
    timestamp: Date
    source?: string
    ip?: string
  }

  /** Domain context */
  domain?: {
    url: string
    name: string
  }

  /** Trace/span IDs for distributed tracing */
  trace?: {
    traceId: string
    spanId: string
    parentSpanId?: string
  }

  /** Arbitrary metadata */
  metadata?: Record<string, unknown>
}

/**
 * Makes specified keys optional in a type.
 * Used to create Input types from base types.
 *
 * @example
 * ```ts
 * type ContactInput = PartialKeys<Contact, 'id' | 'createdAt' | 'updatedAt'>
 * ```
 */
export type PartialKeys<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>

/**
 * Makes specified keys required in a type.
 * Used to create Output types with guaranteed fields.
 *
 * @example
 * ```ts
 * type ContactOutput = RequiredKeys<Contact, 'id' | 'createdAt'>
 * ```
 */
export type RequiredKeys<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>

/**
 * Standard fields that are auto-generated on creation.
 * These should be optional in Input types.
 */
export type AutoGeneratedFields = 'id' | 'createdAt' | 'updatedAt'

/**
 * Creates an Input type from a base type by making
 * auto-generated fields optional.
 *
 * @example
 * ```ts
 * // Base type
 * interface Contact {
 *   id: string
 *   email: string
 *   firstName?: string
 *   createdAt: Date
 *   updatedAt: Date
 * }
 *
 * // Input type - id, createdAt, updatedAt are optional
 * type ContactInput = Input<Contact>
 * // { id?: string; email: string; firstName?: string; createdAt?: Date; updatedAt?: Date }
 * ```
 */
export type Input<T> = PartialKeys<T, Extract<keyof T, AutoGeneratedFields>>

/**
 * Creates an Output type from a base type by ensuring
 * all fields that should exist on output are required.
 *
 * @example
 * ```ts
 * // Output type - id, createdAt, updatedAt are guaranteed
 * type ContactOutput = Output<Contact>
 * ```
 */
export type Output<T> = T

/**
 * Generic action definition for CRUD and custom operations.
 * Actions take typed input and return typed output via RPC.
 *
 * @typeParam TInput - The input parameters type
 * @typeParam TOutput - The return value type
 *
 * @example
 * ```ts
 * interface ContactActions {
 *   create: Action<ContactInput, Contact>
 *   get: Action<{ id: string }, Contact>
 *   update: Action<{ id: string } & Partial<Contact>, Contact>
 *   delete: Action<{ id: string }, void>
 *   list: Action<ListParams, PaginatedResult<Contact>>
 * }
 * ```
 */
export type Action<TInput, TOutput> = (input: TInput) => RPCPromise<TOutput>

/**
 * Event handler callback type.
 * Receives the event object and execution context.
 *
 * @typeParam TEvent - The event type being handled
 * @typeParam TProxy - The RPC proxy type available in context
 *
 * @example
 * ```ts
 * const onContactCreated: EventHandler<ContactCreatedEvent, CRMProxy> = async (event, ctx) => {
 *   // event.type is 'contact.created'
 *   // event.data contains the contact
 *   // ctx.$ is the CRM RPC proxy
 *
 *   if (event.data.lifecycleStage === 'lead') {
 *     await ctx.$.deals.create({
 *       contactId: event.data.id,
 *       stage: 'new'
 *     })
 *   }
 * }
 * ```
 */
export type EventHandler<TEvent, TProxy = unknown> = (
  event: TEvent,
  context: ExecutionContext<TProxy>
) => void | Promise<void>

/**
 * Event subscription function type.
 * Returns an unsubscribe function.
 *
 * @typeParam TEvent - The event type to subscribe to
 * @typeParam TProxy - The RPC proxy type available in context
 *
 * @example
 * ```ts
 * const unsubscribe = contacts.on('created', async (event, ctx) => {
 *   console.log('Contact created:', event.data.email)
 * })
 *
 * // Later, to stop listening
 * unsubscribe()
 * ```
 */
export type EventSubscription<TEvent, TProxy = unknown> = (
  handler: EventHandler<TEvent, TProxy>
) => () => void

/**
 * Base event structure for all domain events.
 *
 * @typeParam TType - String literal type for the event name
 * @typeParam TData - The event payload type
 *
 * @example
 * ```ts
 * type ContactCreatedEvent = BaseEvent<'contact.created', Contact>
 * // { type: 'contact.created'; data: Contact; timestamp: Date; ... }
 * ```
 */
export interface BaseEvent<TType extends string = string, TData = unknown> {
  /** Event type identifier (e.g., 'contact.created') */
  type: TType

  /** Event payload */
  data: TData

  /** When the event occurred */
  timestamp: Date

  /** Unique event ID */
  id?: string

  /** Additional context/metadata */
  metadata?: Record<string, unknown>

  /** Source that emitted the event */
  source?: string

  /** Correlation ID for tracking related events */
  correlationId?: string
}

/**
 * Event emitter interface for publishing events.
 *
 * @typeParam TEvents - Map of event names to event types
 *
 * @example
 * ```ts
 * interface ContactEvents {
 *   created: BaseEvent<'contact.created', Contact>
 *   updated: BaseEvent<'contact.updated', { before: Contact; after: Contact }>
 *   deleted: BaseEvent<'contact.deleted', { id: string }>
 * }
 *
 * const emitter: EventEmitter<ContactEvents> = ...
 * emitter.emit('created', { data: newContact })
 * ```
 */
export interface EventEmitter<TEvents extends Record<string, BaseEvent>> {
  /** Emit an event */
  emit<K extends keyof TEvents>(
    event: K,
    payload: Omit<TEvents[K], 'type' | 'timestamp'>
  ): void

  /** Subscribe to an event */
  on<K extends keyof TEvents, TProxy = unknown>(
    event: K,
    handler: EventHandler<TEvents[K], TProxy>
  ): () => void

  /** Subscribe to an event (once) */
  once<K extends keyof TEvents, TProxy = unknown>(
    event: K,
    handler: EventHandler<TEvents[K], TProxy>
  ): () => void

  /** Remove all handlers for an event */
  off<K extends keyof TEvents>(event: K): void
}

/**
 * Resource with standard CRUD actions.
 *
 * @typeParam T - The resource type
 * @typeParam TInput - Input type for create/update (defaults to Input<T>)
 *
 * @example
 * ```ts
 * interface Contacts extends CRUDResource<Contact> {
 *   // Additional actions beyond CRUD
 *   merge: Action<{ sourceId: string; targetId: string }, Contact>
 *   search: Action<SearchParams, Contact[]>
 * }
 * ```
 */
export interface CRUDResource<T, TInput = Input<T>> {
  /** Create a new resource */
  create: Action<TInput, T>

  /** Get a resource by ID */
  get: Action<{ id: string }, T>

  /** Update a resource */
  update: Action<{ id: string } & Partial<TInput>, T>

  /** Delete a resource */
  delete: Action<{ id: string }, void>

  /** List resources with pagination */
  list: Action<ListParams, PaginatedResult<T>>
}

/**
 * Standard pagination parameters.
 */
export interface ListParams {
  /** Maximum number of results */
  limit?: number

  /** Pagination cursor or offset */
  cursor?: string
  offset?: number

  /** Sort field */
  orderBy?: string

  /** Sort direction */
  order?: 'asc' | 'desc'

  /** Filter conditions */
  filter?: Record<string, unknown>

  /** Search query */
  query?: string
}

/**
 * Paginated result wrapper.
 *
 * @typeParam T - The item type
 */
export interface PaginatedResult<T> {
  /** Result items */
  items: T[]

  /** Total count (if available) */
  total?: number

  /** Next page cursor */
  nextCursor?: string

  /** Whether there are more results */
  hasMore: boolean
}

/**
 * Action result with metadata.
 *
 * @typeParam T - The result data type
 */
export interface ActionResult<T> {
  /** Result data */
  data: T

  /** Success indicator */
  success: boolean

  /** Error message (if failed) */
  error?: string

  /** Execution metadata */
  meta?: {
    duration?: number
    requestId?: string
    cached?: boolean
  }
}

/**
 * Batch action input.
 *
 * @typeParam T - The individual item type
 */
export interface BatchInput<T> {
  /** Items to process */
  items: T[]

  /** Whether to continue on errors */
  continueOnError?: boolean
}

/**
 * Batch action result.
 *
 * @typeParam T - The individual result type
 */
export interface BatchResult<T> {
  /** Successful results */
  succeeded: T[]

  /** Failed items with errors */
  failed: Array<{
    item: unknown
    error: string
  }>

  /** Total processed */
  total: number
}

/**
 * Type helper to extract event types from an actions interface.
 *
 * @example
 * ```ts
 * // Given actions return types, infer event payloads
 * type Events = InferEvents<ContactActions>
 * ```
 */
export type InferEvents<TActions> = {
  [K in keyof TActions as `${string & K}ed`]: TActions[K] extends Action<unknown, infer O>
    ? BaseEvent<`${string & K}ed`, O>
    : never
}
