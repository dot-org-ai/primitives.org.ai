---
title: Function
description: The atomic unit of computation—Code, Generative, Agentic, and Human unified under one abstraction
---

# Function

The Function primitive is the atomic unit of computation in Primitives.org.ai. It unifies four fundamentally different types of work under a single abstraction, enabling seamless composition regardless of whether work is done by code, AI, or humans.

## The Four Types

### Code Functions

Traditional deterministic functions. They take inputs, execute logic, and return outputs. These are the functions you already know—pure computation that always produces the same output for the same input.

```typescript
const calculateTax = fn({
  name: 'calculate-tax',
  type: 'code',
  input: z.object({ amount: z.number(), rate: z.number() }),
  output: z.object({ tax: z.number(), total: z.number() }),
  execute: ({ amount, rate }) => ({
    tax: amount * rate,
    total: amount * (1 + rate),
  }),
})
```

### Generative Functions

AI-powered functions that generate outputs from prompts. These leverage language models, image generators, or other generative AI to produce text, code, images, or structured data.

```typescript
const summarizeDocument = fn({
  name: 'summarize-document',
  type: 'generative',
  input: z.object({ document: z.string(), maxLength: z.number() }),
  output: z.object({ summary: z.string(), keyPoints: z.array(z.string()) }),
  model: 'claude-sonnet-4-20250514',
  prompt: ({ document, maxLength }) => `
    Summarize this document in ${maxLength} words or less.
    Extract key points as bullet items.

    Document:
    ${document}
  `,
})
```

### Agentic Functions

Functions that reason, plan, and execute multi-step tasks autonomously. Unlike generative functions that produce a single output, agentic functions can use tools, make decisions, and iterate until a goal is achieved.

```typescript
const researchTopic = fn({
  name: 'research-topic',
  type: 'agentic',
  input: z.object({ topic: z.string(), depth: z.enum(['shallow', 'deep']) }),
  output: z.object({
    findings: z.array(z.object({
      source: z.string(),
      insight: z.string()
    })),
    synthesis: z.string(),
  }),
  tools: [webSearch, readDocument, extractData],
  maxIterations: 10,
})
```

### Human Functions

Human-in-the-loop tasks that require human judgment, creativity, or approval. These integrate seamlessly into workflows, with the orchestration layer handling assignment, notifications, and timeout policies.

```typescript
const approveExpense = fn({
  name: 'approve-expense',
  type: 'human',
  input: z.object({
    amount: z.number(),
    description: z.string(),
    requestedBy: z.string()
  }),
  output: z.object({
    approved: z.boolean(),
    notes: z.string().optional()
  }),
  assignment: {
    role: 'finance-approver',
    escalation: { after: '24h', to: 'finance-manager' },
  },
  ui: 'expense-approval-form',
})
```

## Unified Interface

All four function types share the same interface, making them interchangeable in workflows and compositions:

```typescript
interface Function<I, O> {
  name: string
  type: 'code' | 'generative' | 'agentic' | 'human'
  input: Schema<I>
  output: Schema<O>

  // Execute the function
  invoke(input: I): Promise<O>

  // Get execution metadata
  metadata(): FunctionMetadata
}
```

This means you can swap a human approval for an AI approval, or replace a generative function with code, without changing any calling code.

## Composition

Functions compose naturally. The output of one becomes the input of another:

```typescript
const processDocument = pipe(
  extractText,      // code: extract text from PDF
  summarize,        // generative: summarize with AI
  reviewSummary,    // human: verify accuracy
  publishSummary,   // code: publish to CMS
)
```

## Error Handling

Each function type has appropriate error handling:

- **Code**: Standard try/catch with typed errors
- **Generative**: Retry policies, fallback models, output validation
- **Agentic**: Iteration limits, stuck detection, human escalation
- **Human**: Timeouts, escalation paths, reassignment rules

```typescript
const robustFunction = fn({
  name: 'robust-operation',
  type: 'generative',
  // ... other config
  retry: { maxAttempts: 3, backoff: 'exponential' },
  fallback: fallbackFunction,
  validation: (output) => output.confidence > 0.8,
})
```

## Observability

All function invocations are traced with:

- Execution duration and resource usage
- Input/output logging (with PII redaction)
- Token usage for AI functions
- Assignment and completion times for human functions

```typescript
const result = await myFunction.invoke(input)

console.log(result.metadata)
// {
//   executionId: 'exec_abc123',
//   duration: 1234,
//   type: 'generative',
//   tokens: { input: 150, output: 89 },
//   cost: 0.0012,
// }
```
