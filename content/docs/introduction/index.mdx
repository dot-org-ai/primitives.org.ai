---
title: Introduction
description: The fundamental abstractions for building AI-native software
---

# Primitives.org.ai

Primitives.org.ai provides the fundamental abstractions for building software where humans and AI work together seamlessly. These core primitives compose together to build anything—from simple functions to entire businesses.

## Core Primitives

| Primitive | Description |
|-----------|-------------|
| [Function](/function) | The atomic unit of computation with four types: Code, Generative, Agentic, and Human. |
| [Database](/database) | Persistent state for structured data and vector embeddings. |
| [Workflow](/workflow) | Orchestrate complex processes with durable execution or state machines. |
| [Task](/task) | Discrete units of work with assignment, tracking, and outcomes. |
| [Agent](/agent) | Truly autonomous entities with real identity and long-term memory. |
| [Human](/human) | Human-in-the-loop for approvals, reviews, and judgment calls. |
| [Product](/product) | Compose primitives into complete products with declarative interfaces. |
| [Service](/service) | Services-as-Software—AI delivering work traditionally done by humans. |
| [Business](/business) | Business-as-Code—traditional processes manifested as code. |

## Philosophy

The age of AI requires new primitives. Traditional software abstractions assume deterministic execution and human-only workflows. Primitives.org.ai is built from first principles for a world where:

- **Computation is heterogeneous** — Code, AI models, autonomous agents, and humans all participate in the same workflows
- **Execution is uncertain** — Generative and agentic functions produce variable outputs that require different handling patterns
- **State is distributed** — Context flows across systems, conversations, and time horizons
- **Work is collaborative** — AI and humans hand off tasks seamlessly, each contributing their strengths

## The Stack

From low-level to high-level:

```
┌─────────────────────────────────────────────────────────┐
│                       Business                          │
│            Business-as-Code organizations               │
├─────────────────────────────────────────────────────────┤
│                       Service                           │
│            Services-as-Software delivery                │
├─────────────────────────────────────────────────────────┤
│                       Product                           │
│            Composed products and interfaces             │
├─────────────────────────────────────────────────────────┤
│              Agent              │         Human         │
│      Autonomous entities        │   Human-in-the-loop   │
├─────────────────────────────────────────────────────────┤
│              Task               │       Workflow        │
│        Units of work            │    Orchestration      │
├─────────────────────────────────────────────────────────┤
│            Function             │       Database        │
│       Atomic computation        │   Persistent state    │
└─────────────────────────────────────────────────────────┘
```

## Getting Started

Start by understanding the [Function](/function) primitive—it's the foundation everything else builds upon. From there:

1. **[Database](/database)** — Store state and enable semantic search
2. **[Workflow](/workflow)** — Orchestrate functions with durability
3. **[Task](/task)** — Manage discrete units of work
4. **[Agent](/agent)** — Create autonomous entities
5. **[Human](/human)** — Integrate human judgment
6. **[Product](/product)** — Compose into products
7. **[Service](/service)** — Package as services
8. **[Business](/business)** — Build organizations

## Quick Example

```typescript
import { fn } from 'ai-functions'
import { workflow } from 'ai-workflows'
import { agent } from 'autonomous-agents'
import { human } from 'human-in-the-loop'

// Define a function that can be code, AI, or human
const reviewCode = fn({
  name: 'review-code',
  type: 'agentic',
  input: z.object({ code: z.string(), context: z.string() }),
  output: z.object({ approved: z.boolean(), feedback: z.string() }),
})

// Add human approval for sensitive changes
const securityApproval = human.approval({
  name: 'security-approval',
  assignTo: { role: 'security-team' },
  when: 'changes.includes("auth") || changes.includes("crypto")',
})

// Orchestrate with durable execution
const prWorkflow = workflow({
  name: 'pr-review',
  steps: [
    reviewCode,
    securityApproval,
    mergePR,
  ],
})

// Create an autonomous agent
const reviewerAgent = agent({
  name: 'code-reviewer',
  identity: { email: 'reviewer@company.com', slack: '@code-reviewer' },
  capabilities: [reviewCode, prWorkflow],
})
```

## Packages

All primitives are available as NPM packages. See the [Packages](/packages) section for installation and usage.
