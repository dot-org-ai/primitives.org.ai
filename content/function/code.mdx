---
title: Code Function
description: Functions that generate executable code
---

When `ai.doSomething()` needs to produce executable code, it becomes a Code Function.

## Examples

```typescript
// Generate authentication middleware
const middleware = await ai.generateAuthMiddleware({
  provider: 'jwt',
  roles: ['admin', 'user', 'guest'],
})
// Returns:
// export function authMiddleware(req, res, next) {
//   const token = req.headers.authorization?.split(' ')[1]
//   if (!token) return res.status(401).json({ error: 'No token' })
//   try {
//     const decoded = jwt.verify(token, process.env.JWT_SECRET)
//     req.user = decoded
//     next()
//   } catch (err) {
//     return res.status(403).json({ error: 'Invalid token' })
//   }
// }

// Generate a React component
const component = await ai.createDataTable({
  features: ['sorting', 'filtering', 'pagination'],
  framework: 'react',
})
// Returns:
// export function DataTable({ data, columns }) {
//   const [sortKey, setSortKey] = useState(null)
//   const [filter, setFilter] = useState('')
//   const [page, setPage] = useState(0)
//   ...
// }

// Generate a database migration
const migration = await ai.createMigration({
  action: 'add users table',
  columns: ['id', 'email', 'name', 'created_at'],
})
// Returns:
// CREATE TABLE users (
//   id SERIAL PRIMARY KEY,
//   email VARCHAR(255) UNIQUE NOT NULL,
//   name VARCHAR(255),
//   created_at TIMESTAMP DEFAULT NOW()
// );

// Generate a CLI tool
const cli = await ai.buildCLI({
  name: 'deploy',
  commands: ['start', 'stop', 'status', 'logs'],
})
// Returns:
// #!/usr/bin/env node
// import { Command } from 'commander'
// const program = new Command()
// program.name('deploy').description('Deployment CLI')
// ...

// Generate API route handlers
const routes = await ai.generateCRUDRoutes({
  resource: 'products',
  database: 'prisma',
})
// Returns:
// export async function GET(req) { ... }
// export async function POST(req) { ... }
// export async function PUT(req) { ... }
// export async function DELETE(req) { ... }
```

## Behind the Scenes

When you call `ai.generateAuthMiddleware(requirements)`, here's what happens:

```typescript
// 1. define() is called with inferred schema
const generateAuthMiddleware = define('generateAuthMiddleware', {
  args: {
    provider: 'Auth provider (jwt | oauth | session)',
    roles: ['List of role names'],
  },
  returns: 'code',  // Code Function indicator
  language: 'typescript',
})

// 2. The function is classified as a Code Function because:
//    - Name contains "generate" + technical term
//    - Returns type is 'code'
//    - Output is meant to be executed

// 3. Code-specific generation runs:
//    - Syntax validation
//    - Import detection
//    - Type inference
//    - Formatting
```

## Classification Signals

A function becomes a Code Function when:

| Signal | Examples |
|--------|----------|
| Name patterns | `generate*`, `create*`, `build*` + technical terms |
| Return type | `'code'`, `'typescript'`, `'sql'`, etc. |
| Context | Framework, language, or tool mentioned |
| Structure | Expects executable output |

## Options

Code Functions accept additional options:

```typescript
const result = await ai.generateComponent(spec, {
  language: 'typescript',    // Target language
  framework: 'react',        // Framework context
  style: 'functional',       // Code style preference
  includeTests: true,        // Generate tests too
})
```
